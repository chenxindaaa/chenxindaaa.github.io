<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/Programming/Docker/Docker/"/>
    <url>/Programming/Docker/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker教程">Docker教程</h1><h2 id="一docker三要素">一、Docker三要素：</h2><ol type="1"><li>image <span class="math inline">\(\rightarrow\)</span> class</li><li>container <span class="math inline">\(\rightarrow\)</span> instance</li><li>repository <span class="math inline">\(\rightarrow\)</span> 存放image的场所，官方registry称为Docker Hub</li></ol><h2 id="二安装">二、安装</h2><p><a href="https://docs.docker.com/engine/">步骤</a></p><p><code>Note：Set up the repository</code></p><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云镜像加速</a></p><h2 id="三docker常用命令">三、Docker常用命令</h2><h3 id="帮助启动类命令">3.1 帮助启动类命令</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl start docker  <span class="hljs-comment"># 启动docker</span><br><span class="hljs-params">system</span>ctl stop docker  <span class="hljs-comment"># 停止docker</span><br><span class="hljs-params">system</span>ctl restart docker  <span class="hljs-comment"># 重启docker</span><br><span class="hljs-params">system</span>ctl status docker  <span class="hljs-comment"># 查看docker状态</span><br><span class="hljs-params">system</span>ctl enable docker  <span class="hljs-comment"># 开机启动</span><br>docker info  <span class="hljs-comment"># 查看docker概要信息</span><br>docker --help  <span class="hljs-comment"># 查看docker总体帮助文档</span><br>docker 具体命令 --help  <span class="hljs-comment"># 查看docker命令帮助文档</span><br></code></pre></td></tr></table></figure><h3 id="镜像命令">3.2 镜像命令</h3><ul><li>docker images [OPTIONS]：列出本地主机上的镜像<ul><li>各个选项说明: REPOSITORY：表示镜像的仓库源 TAG：镜像的标签版本号 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</li><li>OPTIONS说明：<ul><li>-a :列出本地所有的镜像（含历史映像层）</li><li>-q :只显示镜像ID。</li></ul></li></ul></li><li>docker search [OPTIONS] 镜像名字：搜索镜像<ul><li>OPTIONS说明：<ul><li>--limit : 只列出N个镜像，默认25个 e.g. docker search --limit 5 redis</li></ul></li></ul></li><li>docker pull 某个XXX镜像名字：下载镜像<ul><li>docker pull 镜像名字:[TAG] 没有TAG就是最新版等价于docker pull 镜像名字:latest</li></ul></li><li>docker system df：查看镜像/容器/数据卷所占的空间</li><li>docker rmi 某个XXX镜像名字ID：删除镜像<ul><li>删除单个 docker rmi -f 镜像ID</li><li>删除多个 docker rmi -f 镜像名1:TAG 镜像名2:TAG</li><li>删除全部 docker rmi -f $(docker images -qa) ### 3.3 容器命令</li></ul></li><li>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]：新建+启动容器<ul><li>OPTIONS说明：有些是一个减号，有些是两个减号<ul><li>--name="容器新名字" 为容器指定一个名称；</li><li>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</li><li>启动交互式容器(前台有伪终端，等待交互)<ul><li>-i：以交互模式运行容器，通常与 -t 同时使用；(interactive)</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；(terminal)</li><li>e.g. docker run -it ubuntu /bin/bash： 使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令 /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。要退出终端，直接输入 exit:</li></ul></li><li>-P: 随机端口映射，大写P</li><li>-p: 指定端口映射，小写p</li></ul></li></ul></li><li>docker ps [OPTIONS]：·列出当前所有正在运行的容器<ul><li>OPTIONS说明<ul><li>-a：列出当前所有正在运行的容器+历史上运行过的</li><li>-l：显示最近创建的容器。</li><li>-n：显示最近n个创建的容器。</li><li>-q：静默模式，只显示容器编号。</li></ul></li></ul></li><li>退出容器 关系 指向 进入正在运行的容器并以命令行交互 ·两种退出方式 ·exit ·run进去容器，exit退出，容器停止 ·ctrl+p+q ·run进去容器，ctrl+p+q退出，容器不停止 ·启动已停止运行的容器 ·docker start 容器ID或者容器名</li><li>重启容器 ·docker restart 容器ID或者容器名 ·停止容器 ·docker stop 容器ID或者容器名 ·强制停止容器 ·docker kill 容器ID或容器名 ·删除已停止的容器 ·docker rm 容器ID ·一次性删除多个容器实例 ·docker rm -f $(docker ps -a -q) ·docker ps -a -q | xargs docker rm</li></ul><h2 id="reference">Reference:</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1gr4y1U7CY?p=1&amp;vd_source=bd05c11d5f9bf6d6b4849b57473d2194">尚硅谷Docker实战教程</a> <a href="https://space.bilibili.com/393424102">JJacobb</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMake</title>
    <link href="/Programming/C-C/CMake/CMake/"/>
    <url>/Programming/C-C/CMake/CMake/</url>
    
    <content type="html"><![CDATA[<h1 id="最小配置示例">最小配置示例</h1><h2 id="cmakelists.txt">CMakelists.txt</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cmake<span class="hljs-constructor">_minimum_required(VERSION 3.0)</span>  # cmake最低版本<br>project(sample CXX)  # 项目名称<br>add<span class="hljs-constructor">_library(<span class="hljs-params">sample</span> <span class="hljs-params">sample</span>.<span class="hljs-params">cpp</span>)</span>  # 添加库<br>add<span class="hljs-constructor">_executable(<span class="hljs-params">sample_exe</span> <span class="hljs-params">sample_exe</span>.<span class="hljs-params">cpp</span>)</span>  # 添加可执行程序<br></code></pre></td></tr></table></figure><h2 id="相关函数">相关函数</h2><ul><li>project：定义工程名称，并可指定工程支持的语言<ul><li>project(projectname [CXX] [C] [Java][C CXX])</li><li>项目对应的变量：<ul><li>PROJECT_NAME：项目名称</li><li>PROJECT_SOURCE_DIR：项目源码根目录</li><li>PROJECT_VERSION：项目版本</li><li>PROJECT_BINARY_DIR：项目生成的临时二进制目录，用于存放配置/编译中间文件。</li></ul></li></ul></li><li>add_library：生成库文件<ul><li>add_library(libname [SHARED|STATIC|MODULE][EXCLUDE_FROM_ALL] source)<ul><li>libname： 库名称</li><li>source：源文件，可以使用列表变量，也可以直接添加源文件名称，还可以使用函数 target_source 添加源文件</li><li>SHARED：声明该库仅被作为动态库生成</li><li>STATIC 声明该库仅被作为静态库生成</li></ul></li></ul></li><li>add_executable：生成可执行文件<ul><li>add_executable(exename source)</li></ul></li></ul><h2 id="生成项目">生成项目</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">cmake -G <span class="hljs-string">&quot;Unix Makefiles&quot;</span> ..<br>make<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cmake.exe -S .<span class="hljs-regexp">/sample -B ./</span>sample/binary -G <span class="hljs-string">&quot;Visual Studio 16 2019&quot;</span> -A x64<br>cmake.exe --build .<span class="hljs-regexp">/sample/</span>binary<br></code></pre></td></tr></table></figure><h3 id="命令行参数">命令行参数</h3><ul><li>-S 顶级CMakeLists.txt（包含project声明）所在路径。</li><li>-B 存放临时编译的二进制文件（.obj、.ilk等）和编译器对应的配置文件路径。</li><li>-G 编译器名称</li><li>-A 架构名称</li><li>-D 使用该变量以向cmake传入各种参数，包括选项及覆盖cmake提供的各种默认变量值。</li><li>--toolchain cmake toolchain文件路径。</li><li>--install-prefix 安装的二进制存放路径。</li><li>--trace / --trace-expand 调试时使用，用于打印已执行的cmake代码及行号。否则仅输出函数message中的内容。</li><li>--build 使用cmake直接调用编译器编译项目。</li><li>--config 选择需要编译的项目配置类型。</li><li>--install 安装已编译好的二进制文件至 CMAKE_INSTALL_PREFIX 中。</li></ul><h1 id="依赖管理">依赖管理</h1><h2 id="查找依赖">查找依赖</h2><ul><li><p><a href="https://link.zhihu.com/?target=https://cmake.org/cmake/help/latest/command/find_package.html#id7">find_package</a>：使用预先设置的配置文件来查找依赖项 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs inform7">find_package(PACKAGE_NAME_CASE_SENSITIVE<br>             <span class="hljs-comment">[version]</span> <span class="hljs-comment">[EXACT]</span> <span class="hljs-comment">[QUIET]</span><br>             <span class="hljs-comment">[REQUIRED]</span> <span class="hljs-comment">[<span class="hljs-comment">[COMPONENTS]</span> <span class="hljs-comment">[components...]</span>]</span><br>             <span class="hljs-comment">[OPTIONAL_COMPONENTS components...]</span><br>             <span class="hljs-comment">[CONFIG|NO_MODULE]</span><br>             <span class="hljs-comment">[NO_POLICY_SCOPE]</span><br>             <span class="hljs-comment">[NAMES name1 <span class="hljs-comment">[name2 ...]</span>]</span><br>             <span class="hljs-comment">[CONFIGS config1 <span class="hljs-comment">[config2 ...]</span>]</span><br>             <span class="hljs-comment">[HINTS path1 <span class="hljs-comment">[path2 ... ]</span>]</span><br>             <span class="hljs-comment">[PATHS path1 <span class="hljs-comment">[path2 ... ]</span>]</span><br>             <span class="hljs-comment">[PATH_SUFFIXES suffix1 <span class="hljs-comment">[suffix2 ...]</span>]</span><br>             <span class="hljs-comment">[NO_DEFAULT_PATH]</span><br>             <span class="hljs-comment">[NO_PACKAGE_ROOT_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_ENVIRONMENT_PATH]</span><br>             <span class="hljs-comment">[NO_SYSTEM_ENVIRONMENT_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_PACKAGE_REGISTRY]</span><br>             <span class="hljs-comment">[NO_CMAKE_BUILDS_PATH]</span> # Deprecated; does nothing.<br>             <span class="hljs-comment">[NO_CMAKE_SYSTEM_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]</span><br>             <span class="hljs-comment">[CMAKE_FIND_ROOT_PATH_BOTH |</span><br><span class="hljs-comment">              ONLY_CMAKE_FIND_ROOT_PATH |</span><br><span class="hljs-comment">              NO_CMAKE_FIND_ROOT_PATH)</span><br></code></pre></td></tr></table></figure></p><p>常用参数：</p><ul><li>PACKAGE_NAME_CASE_SENSITIVE 查找的库的名称，大小写敏感，与之对应的是调用了包含此名称的配置文件。</li><li>version 依赖的版本号。如果依赖的配置同时提供了版本文件，则会使用该值对比配置中的版本而确定是否可以使用。</li><li>EXACT 版本号必须严格对应配置中的版本号。</li><li>QUIET 关闭了查找信息（不包含查找失败/错误信息）的输出。</li><li>REQUIRED 如果库没找到就报错。</li><li>CONFIG 该关键字声明了需要使用 依赖项通过自己的cmake代码 使用cmake 自动生成的 配置文件，入口配置文件名称一般为 <LOW_CASE_PACKAGE_NAME>-config.cmake 或 <ALL_CASE_PACKAGE_NAME>Config.cmake 。</li></ul></li><li><p>find_library：原始的cmake查找依赖方式，直接查找依赖项库文件。 <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog">find_library (<br>          &lt;<span class="hljs-symbol">LIBRARY_NAME</span>&gt;<br>          name | <span class="hljs-symbol">NAMES</span> name1 [name2 ...] [<span class="hljs-symbol">NAMES_PER_DIR</span>]<br>          [<span class="hljs-symbol">HINTS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>          [<span class="hljs-symbol">PATHS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>          [<span class="hljs-symbol">PATH_SUFFIXES</span> suffix1 [suffix2 ...]]<br>          [<span class="hljs-symbol">DOC</span> <span class="hljs-string">&quot;cache documentation string&quot;</span>]<br>          [<span class="hljs-symbol">NO_CACHE</span>]<br>          [<span class="hljs-symbol">REQUIRED</span>]<br>          [<span class="hljs-symbol">NO_DEFAULT_PATH</span>]<br>          [<span class="hljs-symbol">NO_PACKAGE_ROOT_PATH</span>]<br>          [<span class="hljs-symbol">NO_CMAKE_PATH</span>]<br>          [<span class="hljs-symbol">NO_CMAKE_ENVIRONMENT_PATH</span>]<br>          [<span class="hljs-symbol">NO_SYSTEM_ENVIRONMENT_PATH</span>]<br>          [<span class="hljs-symbol">NO_CMAKE_SYSTEM_PATH</span>]<br>          [<span class="hljs-symbol">CMAKE_FIND_ROOT_PATH_BOTH</span> |<br>           <span class="hljs-symbol">ONLY_CMAKE_FIND_ROOT_PATH</span> |<br>           <span class="hljs-symbol">NO_CMAKE_FIND_ROOT_PATH</span>]<br>         )<br></code></pre></td></tr></table></figure></p><ul><li>LIBRARY_NAME：由于直接查找库文件而不是查找配置文件，此名称仅作为结果中宏的前缀使用。</li><li>NAMES：此项声明了库文件的名称。值得注意的是，在UNIX-style系统中，自动添加“lib”作为库名称的前缀。</li><li>NAMES_PER_DIR：一个名称遍历查找一次，再用另一个名称遍历查找一次。而不是根据路径使用多个名称遍历。</li><li>查找完成后：<ul><li>如果查找到，则会设置 LIBRARY_NAME 为查找到的库文件的名称（包含全路径）。</li><li>如果没有查找到，则会将 LIBRARY_NAME 设置为 <LIBRARY_NAME>-NOTFOUND 。</li></ul><p>所以这里和 find_package 又有不同，我们应当使用以下代码判断是否查找到:</p><p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">PACKAGE_NAME</span> <span class="hljs-variable">MATCHES</span> <span class="hljs-string">&quot;-NOTFOUND&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-title">message</span>(<span class="hljs-variable">FATAL_ERROR</span> <span class="hljs-string">&quot;$&#123;PACKAGE_NAME&#125; not found!&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-title">endif</span>()</span><br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>find_path：这个函数一般是查找头文件或其他的 非库文件 且 非可执行程序。其函数原型为： <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog">find_path (<br>         &lt;<span class="hljs-symbol">FILE_NAME</span>&gt;<br>         name | <span class="hljs-symbol">NAMES</span> name1 [name2 ...]<br>         [<span class="hljs-symbol">HINTS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>         [<span class="hljs-symbol">PATHS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>         [<span class="hljs-symbol">PATH_SUFFIXES</span> suffix1 [suffix2 ...]]<br>         [<span class="hljs-symbol">DOC</span> <span class="hljs-string">&quot;cache documentation string&quot;</span>]<br>         [<span class="hljs-symbol">NO_CACHE</span>]<br>         [<span class="hljs-symbol">REQUIRED</span>]<br>         [<span class="hljs-symbol">NO_DEFAULT_PATH</span>]<br>         [<span class="hljs-symbol">NO_PACKAGE_ROOT_PATH</span>]<br>         [<span class="hljs-symbol">NO_CMAKE_PATH</span>]<br>         [<span class="hljs-symbol">NO_CMAKE_ENVIRONMENT_PATH</span>]<br>         [<span class="hljs-symbol">NO_SYSTEM_ENVIRONMENT_PATH</span>]<br>         [<span class="hljs-symbol">NO_CMAKE_SYSTEM_PATH</span>]<br>         [<span class="hljs-symbol">CMAKE_FIND_ROOT_PATH_BOTH</span> |<br>          <span class="hljs-symbol">ONLY_CMAKE_FIND_ROOT_PATH</span> |<br>          <span class="hljs-symbol">NO_CMAKE_FIND_ROOT_PATH</span>]<br>        )<br></code></pre></td></tr></table></figure> 一般情况下，由于需要cmake表达式来让cmake判断使用哪个配置的库，我们通常这么写：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">find_path</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;_INCLUDE_DIR NAMES header.h PATH_SUFFIXES include/...)</span></span><br><br><span class="hljs-function"><span class="hljs-title">find_library</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;_LIBRARY_RELEASE NAMES name1 name2)</span></span><br><span class="hljs-function"><span class="hljs-title">find_library</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;_LIBRARY_DEBUG NAMES name1d name2d)</span></span><br><span class="hljs-function"><span class="hljs-title">select_library_configurations</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;)</span></span><br>...<br>target_*(target_name $&#123;&lt;PACKAGE_NAME&gt;&#125;)<br></code></pre></td></tr></table></figure></li><li><p>find_program：这个函数专门用于查找可执行程序</p></li></ul><h2 id="使用依赖">使用依赖</h2><p>经过了上面的狂轰乱炸，我们终于可以使用依赖项了。我们可以将查找到的依赖项用于多个函数中，例如添加头文件路径，添加链接库，添加编译选项等。</p><p>对于不同的查找方式，配置文件或cmake提供了不同的使用方式：</p><ul><li><p>宏 例如 <PACKAGE_NAME>_INCLUDE_DIRS 和 <PACKAGE_NAME>_LIBRARIES 这种方式。</p><p>对于头文件来讲，直接加到include_directories中就好了。而对于库来讲，则复杂点：</p><p>由于不能混合使用debug库及release库，cmake必须明确知道在不同配置下使用哪个库。所以宏中一般使用到了cmake表达式来处理这种情况，比如： <span class="math inline">\(&lt;\)</span><CONFIG:DEBUG>:library.lib&gt; <span class="math inline">\(&lt;\)</span>{NOT:$<CONFIG:DEBUG>&gt;:libraryd.lib&gt; 所以我们在写配置时，尽量将debug和release库均查找后使用 select_library_configurations 来生成表达式以便不同配置下使用。</p></li><li><p>target target 就简单的多了，因为它是一个object，cmake函数可以轻松提取 target 包含的需要使用的属性来使用。 当然，target 包含非namespace与namespace两种形式，不过使用上没区别。 ## 内部依赖</p></li><li><p>add_dependencies： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_dependencies(&lt;<span class="hljs-params">target</span>&gt; [&lt;<span class="hljs-params">target</span>-<span class="hljs-params">dependency</span>&gt;]<span class="hljs-operator">...</span>)</span><br></code></pre></td></tr></table></figure> 向前者添加依赖项（后者），可以添加多个。在编译或某些配置时，优先处理后者。</p></li></ul><h1 id="编译相关函数">编译相关函数</h1><h2 id="关键字">关键字</h2><ul><li><p>target target在cmake中是一个很重要的概念，可以理解为一个实例化对象， 一般是由add_executable()，add_library() 或 add_custom_target() 命令之一创建，它包含了例如以下内容：</p><ul><li>相关的源文件列表</li><li>相关的编译选项</li><li>相关的依赖库</li><li>相关的头文件路径列表</li><li>相关的库文件路径列表</li><li>相关的其他属性</li></ul></li><li>PUBLC PRIVATE INTERFACE 例如 target_link_libraries(A [PUBLIC/PRIVATE/INTERFACE] B)<ul><li>PUBLIC 依赖项B仅链接到目标A，若有C链接了目标A，C不链接依赖项B。</li><li>PRIVATE 依赖项B并不链接到目标A，若有C链接了目标A，C会链接依赖项B。</li><li>INTERFACE 依赖项B链接到目标A，若有C链接了目标A，C也会链接依赖项B。 &gt; <a href="https://www.jianshu.com/p/07761ff7838e">CMake 中的 PUBLIC，PRIVATE，INTERFACE</a></li></ul></li></ul><h2 id="相关函数-1">相关函数</h2><ul><li><p>target_compile_options：向目标添加编译选项 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_compile_options(&lt;<span class="hljs-keyword">target</span>&gt; [BEFORE]<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_compile_options(<span class="hljs-params">sample</span> PUBLIC <span class="hljs-operator">/</span><span class="hljs-params">arch</span>=<span class="hljs-params">avx2</span> <span class="hljs-operator">/</span>Wall)</span><br></code></pre></td></tr></table></figure></p></li><li><p>target_compile_definitions：向目标添加预设宏声明及定义</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_compile_definitions(&lt;<span class="hljs-keyword">target</span>&gt;<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">target_compile_definitions</span><span class="hljs-params">(sample PRIVATE BUILD_DLL PUBLIC <span class="hljs-string">&quot;-DPI=3.14159&quot;</span>)</span></span><br></code></pre></td></tr></table></figure></li><li><p>target_include_directories：声明了编译目标时查找使用头文件的路径。</p><p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_include_directories(&lt;<span class="hljs-keyword">target</span>&gt; [SYSTEM] [AFTER|BEFORE]<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure></p>例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_include_directories(<span class="hljs-params">sample</span> PUBLIC <span class="hljs-params">public</span><span class="hljs-operator">/</span><span class="hljs-params">include</span><span class="hljs-operator">/</span><span class="hljs-params">sample</span> PRIVATE <span class="hljs-params">sample</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>target_link_libraries：声明了链接时需要参与的依赖库名称或target，其名称可包含完整路径。</p><p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_link_libraries(&lt;<span class="hljs-keyword">target</span>&gt;<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">sample</span> PUBLIC CURL::<span class="hljs-params">curl</span> <span class="hljs-params">glib</span> <span class="hljs-params">m</span>)</span><br></code></pre></td></tr></table></figure> 注意：由于一个target中包含多个属性，一般情况下包含了头文件路径。所以使用target作为参数传入此函数时，无需调用 target_include_directories 再次声明添加头文件路径。</p></li><li><p>target_link_libraries：声明了链接时查找依赖库的路径。 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_link_libraries(&lt;<span class="hljs-keyword">target</span>&gt; [BEFORE]<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">sample</span> PUBLIC <span class="hljs-params">third_party</span><span class="hljs-operator">/</span><span class="hljs-params">libs</span><span class="hljs-operator">/</span><span class="hljs-params">x86</span><span class="hljs-operator">/</span><span class="hljs-params">rel</span>)</span><br></code></pre></td></tr></table></figure></p></li></ul><h2 id="target族函数注意事项">target族函数注意事项</h2><p>当需要使用cmake export关键字导出声明的target并附带其中的 PUBLIC 属性时，我们必须 将PUBLIC / PRIVATE / INTERFACE 关键字向这类 target 族函数补齐。且如果一个 target 族函数声明了这三个关键字其中之一，该 target 所属的其他 target 族函数均应当声明关键字。且对于包含路径的值，我们需要声明此值的使用范围：</p><p>编译/链接时使用。必须使用绝对路径。 导出以向下游提供。必须使用相对路径。 所以，我们通常情况下使用以下方式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">target_include_directories(sample <span class="hljs-variable constant_">PRIVATE</span> <span class="hljs-variable">$&lt;</span><span class="hljs-variable constant_">BUILD_INTERFACE</span><span class="hljs-symbol">:</span><span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">CMAKE_SOURCE_DIR</span>&#125;/header/<span class="hljs-keyword">include</span>&gt; <span class="hljs-variable constant_">PUBLIC</span> <span class="hljs-variable">$&lt;</span><span class="hljs-variable constant_">INSTALL_INTERFACE</span><span class="hljs-symbol">:include&gt;</span>)<br></code></pre></td></tr></table></figure><h1 id="reference">Reference</h1><p><a href="https://www.zhihu.com/column/c_1490802622991306752">CMake教程系列</a></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C/C++</category>
      
      <category>CMake</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Academic Writing</title>
    <link href="/Research/Academic-Writing/Effective%20Academic%20Writing/"/>
    <url>/Research/Academic-Writing/Effective%20Academic%20Writing/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="884eb34aa131356643002d0cd5f5394ddc245abd3d301c7f73327a88f55c0138">4630436162ade97ba2718b7d0c4b3b6376f3306e7b9798bdbcb35e81f16aa19b0645320c632847b028c3598cd6616474b46847a04718e53a8112e5f830a8601402ac7c967a18b3f2c246eb0842b3f1834dcd342e58490f5f43bb9235f219e267c2057d968dc7f9f0c13f4da67311d41d6307b40c73edf852f5130449a36972a60c4f3027ea91ae6eb486c7e688ec83d5217ee00edaacb992b47c85caca964b868c2a11ebe6995a3a9dc6e9eb096384f2bc7e3a896140b5196286ea0b5488fc7b82565e00dde5f228946a2bc1646740a85c83d258bcc9c9e1336a05e162b61f643a23c6918fe92d7b29f688ac06e493f91ab4593fe200b362628211b6e846b800c9c248fe44c53ff2667764aab91272eee93ce7b5095d64fca552631a8011710303bf6c16305ccf6fc83e7a5ff6b87a3e88daa2ca433105897a84f7784d9d7a1b295007504ba39fa4bc3a91a16c14b55cb2a057f88d8b416577972886b38af0b647033bc4e820138c7f8e97078ef12dd082c497da4ecbc07f15aae90f07969306c6e2ef2a46020f4350ab537820fbdc6fe370536ff12094d18ed90b2b56b89bc44ef82e716a1fab0aa5fa996b922c32cf3de91bed20d7f957d58bdbcb83889c89fdad2dac4c6fa69f894d9ca6731aef0993bdaca2aa3571235ba900e2aec284c7dfa47f1001e728c6119a7c511cfb18e15ae0c5eb4ea796b59b4cedd7d1d8dce50f827bbeb89877010bf9fd6228545161b273ce998ae8439c0232480fc54a8b83fc13955c892b122bcbc0979e4134eb5979d73e949bd3296db0b0603fcf7cb3aba716edf2d59ddcab5097613582a255e1d276de91fd368bbee7fc36e744f81b44faa9f9d01b4778ec80aa12b36733f392d0e8a285ca4b815261ff8eb5e52f7a1c2c5bb636aed8046008424b281fed923e0ed8767e0b747022bd9e84f37a98382c22c2e71a27bf48cbd983e4f11cd647a8ef8551cb2420275c644215ce3047884884708b0dea219e06e6b5686e63263423532963d145cc7681e075a275045f2d431a7f0c14a6c89b11c09834f2add1f8b357f093a3d65b9586276b2d1a0f978dcaa075ebfc73149c2fcb7dd42c0d98084db4124f63215ab5322e3f35a7b87acbcaa51d600b4952cf77d8b153b272ed51690be4a1fc2c05c2555455e4b48043a99f65b2a473827a7f8c9391b6cd9bc065ac47456e19adf238bc1523a88845b1bb8d0bcba6c5920703e666c84baf56175185e5394f5416a3a61524f6f6eeaffa0a10d3ec4130ed5bcb2f4ecd0035dc55368e56be470976013ffd2021647b72f0f03a11216815b104582c39ea319dea2e0e122eaebef6ad2e7eb64da008e9f46a3135ffd1f8afcc9370c67a4a7b36b19e0c41134a5d9eb436893c3befe20ee158c7599ef09f5be1fe2c813e46fd098d5b3d58010981bfb65724925568b03241a6700112f5309a2fb697ca6feae78763eb6ce007f58584bc427cf36e40fb73b52d368d42e750907a45e2c278d0706fdc3d58a3b80957fb1db474fb6bcb792b8eefe8937ed647b41505dbfa76faf4ebc7659a25c8a8933a6325519279482f7cb912afc0f54aac82131055ba630f78dbd03523379b516351698e6bf4fc9caa8ff981c2f3b546f4f205191f65074c34bcfd56cd2cb156c082cf2ddf7b531d433d743e98f01e239a00688c89b2badbacaf643c282cd1edffd79b416cfa72f76935893a1cd737eb14afcbe3b77820920526d6a561a80e9882e5abd5aaec8446d33a82aaeb1f136ff13ccb2ebceb986f205c02f72d6d72bf9ac567e9dbd3cbf88b5288fb10503630d78154078616f21eca79a735b0180930aa718f1ac16fd05bceca0b57e328ca484b437190663cac2c1e150537f4702c2bd4fbad4956b466ae864e9668cf74af991e24b6e6ab8d56cbb28fa33d59f5e0335e166b2be064c69ba17695d15ce6add2f0421fd821f91a4c0e8bd7060d31d3486dbe4c44ad3dc3c0a0249398a735522bb44faa8c39ae87ec82c710d84585d59e5b45818e14c80b09a384220000a941ffb87c25545f14fd8f960194c1cca76977213d859ce816355c45a955a0cd590a9284f534c48ad88e0d1879fafcd48a4f8ae432eaec7855030c17e8815483d41df9070775b4644d1ef162001ada1c03d3b624040a9ff382803fbd14d2070813a38c5080bc8f2c077d51532c9a45aacc508f24d29edf97659e01c33c9e1eef91d97fcad8e73b9461cccfccefb9308451791e33a0b001e2d6a60fc070589b856cf0327b83c246d371afd2be783c9a3cf826bdffc5c4c5a3b1cbc1dc8ee051068f26f4a633e4530418534295dc339896d5000d14d66141455fb260e5c0c9ef4960a1e0fa8f14b1dcdcab0a948ebf5c319b4e7c77bf11903b897ca59edd0d7307c3afc3dd22678b2627c4d2e1d236d601c1a2ea927540c994317ce04377843fa3a10201a32dee352e7327db229a7161ec3d2fc4111175ce355290af2db716ed1c5a5ee07ec91e8d6da8bfd8c8dc4743e48929f9fa6bf1ac482116cd04402c42f02e4af8c980a33b8b2cc7f80dde4276257a0ec29e349f959af3fe4c068fa84bfd60b54a509db9f00b9d6d212475613f7cebb0688a03bd73b92a47c4838f4f1031f7a476da37cd6c684c0066022edb690ca7cafcd6e7e5ef7d77be1370411ff74cbad329f0effd1a4adb4e687a21c4bc315830f9c56e9d930f02cac1a0cf448cce4fd8e0c7b86b3c374314f9840dd34c4d2579590fa9e978996d4995237dbbd33221c255d71ab94cd01a9768a40105273cd38c9da308e7b39b95146ec53d8a07a2fed15a7aa83dbad116ecf3f4ce8509f6aafe0646d06708f3077985bffab2c470eea3eab98848fe1cb1ffe83484d7697da9c3d7b5fb534be5bafd059f5ef6efafbcc0641429cf8dab809e188b0d6f266cdf4e69240c4666e9b9ae46b1ecce232dfe8f11a6e152556efdbe02cc1933652412c9b3b504371b2a83969dcd69ade13fdee569233f03e8843d24b2ccf97e2f17c8974ef45abfb0b6af08c89705204d7b4c4cea26a2dc3879c64cac84540cf114a428c9e35f7672d9c8d3d1d925da86277975089c7ddba7ceabba2625a1868f9cd19a9d4babdc1eb28828e6a0e1d00aff02014d519f9a88fff7cf6c753f9c70098aab988672eb2db2e64bafb977d16514046e50dd055aef45b32a79ec4b640706a0834a4c4cdfa5aacc91ab49478e890e2a44c2bdb5ed6242fa9f06e6061afef5aed1eccd2f12d6a846f1c833df7c7059bd271b1936352f98b57a7ef13dffe97b3fc808279a26f9e71e171ada71162aaeb8648d20db6fcbd04d57db2e7fa8c3aa4d60710ddc0fbdb5f6c6268c007659a1c2d001565d8da7ae0bedb9949a55032e639eb0c90007d5036fde75835150ab5d73f7f2fbb8967941e11e01df648728d86ddff782a5264062832823849ab84de4c5a2c11784e33a3f884c40a1262b89eed302689e4b31c0933850a68f443bab26b2e5d9c21d3f7df3080f6ef59a680befe584bb9ccb92065f8817ae6665f82b57a6ab927c5fe99dfed3086479ffac6ef7d6094885426458cf1baba9ff58c429d0f541e5d8ee781d424a9651446ed95f477b19f5045e002e6229383489d505d554f59b2c34c50d1c1c959134d0fb65a620494a903640dc8a68360faa94daad34698e8b6742cefc79a5edbb4488a5c57b2de18aa2805d974b01eeae4a89fdd3a2eb90463148a8627dfa1f80adfec7d49a22d9d49ca40b51eddb4412b8242d1d2a9ec3e08b4b5f23b087750fc6a57e2463056578c440fd9a464f6c93b532540b8fc457a1438d3b0b0dfb12c7b374076238aa74554a8b0a768f65c3fa9f631d965198d3ef92e6338f5e3a85da00ecaf7ca079ab1114e19784923bdb5ce364820c04d02f27f7921b977f8e4ec78f3526fe5cdaa839be7f99f1bf425e6c5f1ab5c49c19d59332fbc31c1250effbbb9440f58860fb04fabcbfa10b496744434c25be3b30112069aa70cb89d47162897194f483aea7274248ee3562b78c258ec940c42832fd883fb180657c6c25c5b260953681254c2c69acb99b973ed0642f50bd8d546ac3662822227bae7d0b23683b23ac006bee519ad90e1f8fb955512602b5e63d426e1fdd0b25f8b5dc1bcf6ad69a2562542f6b6a8fa2c3f52e5adf334149c933b31d330cfa80930f96610c08469cf933bbd514c5e60d8625b0c067f17ae3cb0df5323989a3093e8e03d688d0e39cbf4912a5c15afda6bffc4600ec087d45f412bb0baf110a1316d8d112174612565dc6958409c199e9dbabd106fd15e3dc682be7506fd0a17904ecf29fed4fbb707afefc9238147180ab8babd06cd109bf9052ddb1a41b4546602794ab3e716ebbec68764abf0efc6772644bb707ed19b6a8f3e6ae55689bca17b2f3ade7aa1b621f7815a574753fcf6cebf36c7faad4d35adc02067c5542bd1fc5fa204f8b4e05b5db4b24a039addac7334bca3672185e4347a1edd597e041c22101370b69d8a009d1c2807557d2e8eddacb203fb1b65d57b65ec76812aac495955d815b828a19a8ea28eb688faa3174e353469dcd6a798ba251ac8bcb859d0a3186d894c37a458bd5900b64032619e6b90ca6fc50d1c02871e93f1fd2ef04867e94729336093e957565833e2378acdde413d3809f80dd8926722e40802071a075d821193854f8a6897e1b755fd3c2df4c48c835d661b8cef3951fd2f9332ee372c7a73f9b5169637f27323de587c244ccbb74496d7858fa6615a2ccf8ffd1f275af2c2676b5a690a45f11713dc359b265b5becc77e5bd81bbc882497bd87ea0ae4036e7a839b63109ed36070b3f288d22a7ee92cc3abda2a590c0748c829dff9c7aafbf67141c79473073b49125dfbe0a49b61784b32bef59e29bd4a981c6e0005abc21a5707fd1ec1985ec05a32c4609ec9aca814c9a33e0a1f998040286b4791dbd19e14ffba621d3beed50c2e52e489d5fa59331a32a980a3e5d170e8399e5b1587a184d7581d40563d2a2a78483bcde61aa70d9124b4666f967dce66308d1650e83779bc2ca30a40fcb08460626309bb8579f7294774ee3cd724c8d1627c3c8bd61b633db93913c78bd2ae7f4c4e127d5059426b99f436e5fbfe0aaea91429a3e719729bdcde0de370a79319468490f0f0faa5cc3d48ebe29e45270b9510eb1aea434d21395eba8d7087f7ba130b9ee3b90168da40ff2f2007c57319c2c89d51766391d4d4ea6b382d8b1e7de01c6f9dbc722da2677a5092c01130803f914cb588f9edae85bae01828d474ad178f7db211dd09bb69a1b2a14985abd6442874ebf661b6a9af3f45d1526e46b6c5015e6404f6937583ceb268928d57a07a9590a5840ca01d1bc47388dbf65cae8c5633384a61f747b3e372ddcba14a3881896b7d9bb60a4a606d86f015d66c3f7271adf1d39b908412155b13f0fadab002cf994ac3ec3840ccf1533d4367aa2e2ecfd9feb94d648e19758ab733b4151006df010b093bb80f412c33d85568af416865921455d18f8a326fb7eb0d8ead24a6a7780acd65e304d1002cbc783e4b54ff3a4cd62cd4e6e55297b98d7762636b6ce430f82e8c67af0fb2f241e4636108c13b8396c3da53304d1415266cab311d799aff31833562ddfb08e970d4caea0428a41bb6f0167dbe7918260b1c5af5046e1bf7f1d75f98379918b08b58d9ed026f16f6dde5a9fe5513c9d6e213eb1cef2b7ce3a59c40d24799c8bf51fd9b7083dffd5184bb49457ce7c4e0fe0a60a404da7b834e563b725efa0bfd93dba180d446bbf83ec88676b88dc98683f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my blog, enter password to read.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Academic Writing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dive into DL</title>
    <link href="/Programming/DL/Dive%20into%20DL/"/>
    <url>/Programming/DL/Dive%20into%20DL/</url>
    
    <content type="html"><![CDATA[<p><a href="https://chenxindaaa.com/Programming/DL/PyTorch/Dive%20into%20DL-Linear%20Regression/">Linear Regression</a></p><p><a href="https://chenxindaaa.com/Programming/DL/CV/Dive%20into%20DL-Softmax%20Classification/">Softmax Classification</a></p><p><a href="https://chenxindaaa.com/Programming/DL/CV/Dive%20into%20DL-Multilayer%20Perceptron/">Multilayer Perceptron</a></p><p><a href="https://chenxindaaa.com/Programming/DL/NLP/Dive%20into%20DL-Text%20Prepare/">Text Prepare</a></p><p><a href="https://chenxindaaa.com/Programming/DL/NLP/Dive%20into%20DL-Language%20Model/">Language Model</a></p><p><a href="https://chenxindaaa.com/Programming/DL/NLP/Dive%20into%20DL-Recurrent%20Neural%20Network/">Recurrent Neural Network</a></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>DL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode</title>
    <link href="/Programming/Leetcode/Leetcode/"/>
    <url>/Programming/Leetcode/Leetcode/</url>
    
    <content type="html"><![CDATA[<p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：2.两数相加/">2.两数相加</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：4.寻找两个有序数组的中位数/">4.寻找两个有序数组的中位数</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：5.最长回文子串/">5.最长回文子串</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：7.整数反转/">7.整数反转</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：8.字符串转换整数/">8.字符串转换整数</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：9.回文数/">9.回文数</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：11.盛最多水的容器/">11.盛最多水的容器</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：14.最长公共前缀/">14.最长公共前缀</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：15.三数之和/">15.三数之和</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：16.最接近的三数之和/">16.最接近的三数之和</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：20.有效的括号/">20.有效的括号</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：21.合并两个有序链表/">21.合并两个有序链表</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：23.合并K个排序链表/">23.合并K个排序链表</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：26.删除排序数组中重复的项/">26.删除排序数组中重复的项</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：33.搜索旋转排序数组/">33.搜索旋转排序数组</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：43.字符串相乘/">43.字符串相乘</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：46.全排列/">46.全排列</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：53.最大子序和/">53.最大子序和</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：54.螺旋矩阵/">54.螺旋矩阵</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：59.螺旋矩阵二/">59.螺旋矩阵二</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：61.旋转链表/">61.旋转链表</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：62.不同路径/">62.不同路径</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：70.爬楼梯/">70.爬楼梯</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：78.子集/">78.子集</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：88.合并两个有序数组/">88.合并两个有序数组</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：89.格雷编码/">89.格雷编码</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：104.二叉树最大深度/">104.二叉树最大深度</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：121.买卖股票的最佳时机/">121.买卖股票的最佳时机</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：122.买卖股票的最佳时机II/">122.买卖股票的最佳时机II</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：124.二叉树最大路径和/">124.二叉树最大路径和</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：136.只出现一次的数字/">136.只出现一次的数字</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：141.环形链表/">141.环形链表</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：142.环形链表II/">142.环形链表II</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：146.LRU缓存机制/">146.LRU缓存机制</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：148.排序链表/">148.排序链表</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：155.最小栈/">155.最小栈</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：160.相交链表/">160.相交链表</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：169.众数/">169.众数</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：206.反转链表/">206.反转链表</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：215.数组中的第K个最大元素/">215.数组中的第K个最大元素</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：217.存在重复元素/">217.存在重复元素</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：230.二叉搜索树中第K小的元素/">230.二叉搜索树中第K小的元素</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：231.2的幂/">231.2的幂</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：235.二叉搜索树的最近公共祖先/">235.二叉搜索树的最近公共祖先</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：236.二叉树的最近公共祖先/">236.二叉树的最近公共祖先</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：237.%20删除链表中的节点/">237. 删除链表中的节点</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：238.%20除自身以外数组的乘积/">238. 除自身以外数组的乘积</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：292.%20Nim%20游戏/">292. Nim 游戏</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：344.%20反转字符串/">344. 反转字符串</a></p><p><a href="https://chenxindaaa.com/Programming/Leetcode/Leetcode实战：557.%20反转字符串中的单词%20III/">557. 反转字符串中的单词 III</a></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dive into DL: Language Model</title>
    <link href="/Programming/DL/NLP/Dive%20into%20DL/Dive%20into%20DL-Language%20Model/"/>
    <url>/Programming/DL/NLP/Dive%20into%20DL/Dive%20into%20DL-Language%20Model/</url>
    
    <content type="html"><![CDATA[<h1 id="语言模型">语言模型</h1><p>一段自然语言文本可以看作是一个离散时间序列，给定一个长度为<span class="math inline">\(T\)</span>的词的序列<span class="math inline">\(w_1, w_2, \ldots, w_T\)</span>，语言模型的目标就是评估该序列是否合理，即计算该序列的概率：</p><p><span class="math display">\[P(w_1, w_2, \ldots, w_T).\]</span></p><p>本节我们介绍基于统计的语言模型，主要是<span class="math inline">\(n\)</span>元语法（<span class="math inline">\(n\)</span>-gram）。在后续内容中，我们将会介绍基于神经网络的语言模型。</p><h2 id="语言模型-1">语言模型</h2><p>假设序列<span class="math inline">\(w_1, w_2, \ldots, w_T\)</span>中的每个词是依次生成的，我们有</p><p>$$</p><p><span class="math display">\[\begin{align*}P(w_1, w_2, \ldots, w_T)&amp;= \prod_{t=1}^T P(w_t \mid w_1, \ldots, w_{t-1})\\&amp;= P(w_1)P(w_2 \mid w_1) \cdots P(w_T \mid w_1w_2\cdots w_{T-1})\end{align*}\]</span></p><p>$$</p><p>例如，一段含有4个词的文本序列的概率</p><p><span class="math display">\[P(w_1, w_2, w_3, w_4) =  P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_1, w_2) P(w_4 \mid w_1, w_2, w_3).\]</span></p><p>语言模型的参数就是词的概率以及给定前几个词情况下的条件概率。设训练数据集为一个大型文本语料库，如维基百科的所有条目，词的概率可以通过该词在训练数据集中的相对词频来计算，例如，<span class="math inline">\(w_1\)</span>的概率可以计算为：</p><p>$$</p><p>P(w_1) = </p><p>$$</p><p>其中<span class="math inline">\(n(w_1)\)</span>为语料库中以<span class="math inline">\(w_1\)</span>作为第一个词的文本的数量，<span class="math inline">\(n\)</span>为语料库中文本的总数量。</p><p>类似的，给定<span class="math inline">\(w_1\)</span>情况下，<span class="math inline">\(w_2\)</span>的条件概率可以计算为：</p><p>$$</p><p>P(w_2 w_1) = </p><p>$$</p><p>其中<span class="math inline">\(n(w_1, w_2)\)</span>为语料库中以<span class="math inline">\(w_1\)</span>作为第一个词，<span class="math inline">\(w_2\)</span>作为第二个词的文本的数量。</p><h2 id="n元语法">n元语法</h2><p>序列长度增加，计算和存储多个词共同出现的概率的复杂度会呈指数级增加。<span class="math inline">\(n\)</span>元语法通过马尔可夫假设简化模型，马尔科夫假设是指一个词的出现只与前面<span class="math inline">\(n\)</span>个词相关，即<span class="math inline">\(n\)</span>阶马尔可夫链（Markov chain of order <span class="math inline">\(n\)</span>），如果<span class="math inline">\(n=1\)</span>，那么有<span class="math inline">\(P(w_3 \mid w_1, w_2) = P(w_3 \mid w_2)\)</span>。基于<span class="math inline">\(n-1\)</span>阶马尔可夫链，我们可以将语言模型改写为</p><p><span class="math display">\[P(w_1, w_2, \ldots, w_T) = \prod_{t=1}^T P(w_t \mid w_{t-(n-1)}, \ldots, w_{t-1}) .\]</span></p><p>以上也叫<span class="math inline">\(n\)</span>元语法（<span class="math inline">\(n\)</span>-grams），它是基于<span class="math inline">\(n - 1\)</span>阶马尔可夫链的概率语言模型。例如，当<span class="math inline">\(n=2\)</span>时，含有4个词的文本序列的概率就可以改写为：</p><p>$$</p><p><span class="math display">\[\begin{align*}P(w_1, w_2, w_3, w_4)&amp;= P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_1, w_2) P(w_4 \mid w_1, w_2, w_3)\\&amp;= P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_2) P(w_4 \mid w_3)\end{align*}\]</span></p><p>$$</p><p>当<span class="math inline">\(n\)</span>分别为1、2和3时，我们将其分别称作一元语法（unigram）、二元语法（bigram）和三元语法（trigram）。例如，长度为4的序列<span class="math inline">\(w_1, w_2, w_3, w_4\)</span>在一元语法、二元语法和三元语法中的概率分别为</p><p>$$</p><p>\begin{aligned} P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2) P(w_3) P(w_4) ,\ P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2 w_1) P(w_3 w_2) P(w_4 w_3) ,\ P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2 w_1) P(w_3 w_1, w_2) P(w_4 w_2, w_3) . \end{aligned}</p><p>$$</p><p>当<span class="math inline">\(n\)</span>较小时，<span class="math inline">\(n\)</span>元语法往往并不准确。例如，在一元语法中，由三个词组成的句子“你走先”和“你先走”的概率是一样的。然而，当<span class="math inline">\(n\)</span>较大时，<span class="math inline">\(n\)</span>元语法需要计算并存储大量的词频和多词相邻频率。</p><p>思考：<span class="math inline">\(n\)</span>元语法可能有哪些缺陷？</p><ol type="1"><li>参数空间过大</li><li>数据稀疏</li></ol><h1 id="语言模型数据集">语言模型数据集</h1><h2 id="读取数据集">读取数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/kesci/input/jaychou_lyrics4703/jaychou_lyrics.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    corpus_chars = f.read()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(corpus_chars))<br><span class="hljs-built_in">print</span>(corpus_chars[: <span class="hljs-number">40</span>])<br>corpus_chars = corpus_chars.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>)<br>corpus_chars = corpus_chars[: <span class="hljs-number">10000</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">63282想要有直升机想要和你飞到宇宙去想要和你融化在一起融化在宇宙里我每天每天每</code></pre><h2 id="建立字符索引">建立字符索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">idx_to_char = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(corpus_chars)) <span class="hljs-comment"># 去重，得到索引到字符的映射</span><br>char_to_idx = &#123;char: i <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(idx_to_char)&#125; <span class="hljs-comment"># 字符到索引的映射</span><br>vocab_size = <span class="hljs-built_in">len</span>(char_to_idx)<br><span class="hljs-built_in">print</span>(vocab_size)<br><br>corpus_indices = [char_to_idx[char] <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> corpus_chars]  <span class="hljs-comment"># 将每个字符转化为索引，得到一个索引的序列</span><br>sample = corpus_indices[: <span class="hljs-number">20</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;chars:&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>.join([idx_to_char[idx] <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> sample]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;indices:&#x27;</span>, sample)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1027chars: 想要有直升机 想要和你飞到宇宙去 想要和indices: [1022, 648, 1025, 366, 208, 792, 199, 1022, 648, 641, 607, 625, 26, 155, 130, 5, 199, 1022, 648, 641]</code></pre><p>定义函数<code>load_data_jay_lyrics</code>，在后续章节中直接调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data_jay_lyrics</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/kesci/input/jaychou_lyrics4703/jaychou_lyrics.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        corpus_chars = f.read()<br>    corpus_chars = corpus_chars.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>)<br>    corpus_chars = corpus_chars[<span class="hljs-number">0</span>:<span class="hljs-number">10000</span>]<br>    idx_to_char = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(corpus_chars))<br>    char_to_idx = <span class="hljs-built_in">dict</span>([(char, i) <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(idx_to_char)])<br>    vocab_size = <span class="hljs-built_in">len</span>(char_to_idx)<br>    corpus_indices = [char_to_idx[char] <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> corpus_chars]<br>    <span class="hljs-keyword">return</span> corpus_indices, char_to_idx, idx_to_char, vocab_size<br></code></pre></td></tr></table></figure><h2 id="时序数据的采样">时序数据的采样</h2><p>在训练中我们需要每次随机读取小批量样本和标签。与之前章节的实验数据不同的是，时序数据的一个样本通常包含连续的字符。假设时间步数为5，样本序列为5个字符，即“想”“要”“有”“直”“升”。该样本的标签序列为这些字符分别在训练集中的下一个字符，即“要”“有”“直”“升”“机”，即<span class="math inline">\(X\)</span>=“想要有直升”，<span class="math inline">\(Y\)</span>=“要有直升机”。</p><p>现在我们考虑序列“想要有直升机，想要和你飞到宇宙去”，如果时间步数为5，有以下可能的样本和标签： * <span class="math inline">\(X\)</span>：“想要有直升”，<span class="math inline">\(Y\)</span>：“要有直升机” * <span class="math inline">\(X\)</span>：“要有直升机”，<span class="math inline">\(Y\)</span>：“有直升机，” * <span class="math inline">\(X\)</span>：“有直升机，”，<span class="math inline">\(Y\)</span>：“直升机，想” * ... * <span class="math inline">\(X\)</span>：“要和你飞到”，<span class="math inline">\(Y\)</span>：“和你飞到宇” * <span class="math inline">\(X\)</span>：“和你飞到宇”，<span class="math inline">\(Y\)</span>：“你飞到宇宙” * <span class="math inline">\(X\)</span>：“你飞到宇宙”，<span class="math inline">\(Y\)</span>：“飞到宇宙去”</p><p>可以看到，如果序列的长度为<span class="math inline">\(T\)</span>，时间步数为<span class="math inline">\(n\)</span>，那么一共有<span class="math inline">\(T-n\)</span>个合法的样本，但是这些样本有大量的重合，我们通常采用更加高效的采样方式。我们有两种方式对时序数据进行采样，分别是随机采样和相邻采样。</p><h3 id="随机采样">随机采样</h3><p>下面的代码每次从数据里随机采样一个小批量。其中批量大小<code>batch_size</code>是每个小批量的样本数，<code>num_steps</code>是每个样本所包含的时间步数。 在随机采样中，每个样本是原始序列上任意截取的一段序列，相邻的两个随机小批量在原始序列上的位置不一定相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter_random</span>(<span class="hljs-params">corpus_indices, batch_size, num_steps, device=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-comment"># 减1是因为对于长度为n的序列，X最多只有包含其中的前n - 1个字符</span><br>    num_examples = (<span class="hljs-built_in">len</span>(corpus_indices) - <span class="hljs-number">1</span>) // num_steps  <span class="hljs-comment"># 下取整，得到不重叠情况下的样本个数</span><br>    example_indices = [i * num_steps <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_examples)]  <span class="hljs-comment"># 每个样本的第一个字符在corpus_indices中的下标</span><br>    random.shuffle(example_indices)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_data</span>(<span class="hljs-params">i</span>):<br>        <span class="hljs-comment"># 返回从i开始的长为num_steps的序列</span><br>        <span class="hljs-keyword">return</span> corpus_indices[i: i + num_steps]<br>    <span class="hljs-keyword">if</span> device <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_examples, batch_size):<br>        <span class="hljs-comment"># 每次选出batch_size个随机样本</span><br>        batch_indices = example_indices[i: i + batch_size]  <span class="hljs-comment"># 当前batch的各个样本的首字符的下标</span><br>        X = [_data(j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> batch_indices]<br>        Y = [_data(j + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> batch_indices]<br>        <span class="hljs-keyword">yield</span> torch.tensor(X, device=device), torch.tensor(Y, device=device)<br></code></pre></td></tr></table></figure><p>测试一下这个函数，我们输入从0到29的连续整数作为一个人工序列，设批量大小和时间步数分别为2和6，打印随机采样每次读取的小批量样本的输入<code>X</code>和标签<code>Y</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_seq = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>))<br><span class="hljs-keyword">for</span> X, Y <span class="hljs-keyword">in</span> data_iter_random(my_seq, batch_size=<span class="hljs-number">2</span>, num_steps=<span class="hljs-number">6</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;X: &#x27;</span>, X, <span class="hljs-string">&#x27;\nY:&#x27;</span>, Y, <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">X:  tensor([[ 6,  7,  8,  9, 10, 11],        [12, 13, 14, 15, 16, 17]]) Y: tensor([[ 7,  8,  9, 10, 11, 12],        [13, 14, 15, 16, 17, 18]]) X:  tensor([[ 0,  1,  2,  3,  4,  5],        [18, 19, 20, 21, 22, 23]]) Y: tensor([[ 1,  2,  3,  4,  5,  6],        [19, 20, 21, 22, 23, 24]]) </code></pre><h3 id="相邻采样">相邻采样</h3><p>在相邻采样中，相邻的两个随机小批量在原始序列上的位置相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter_consecutive</span>(<span class="hljs-params">corpus_indices, batch_size, num_steps, device=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> device <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br>    corpus_len = <span class="hljs-built_in">len</span>(corpus_indices) // batch_size * batch_size  <span class="hljs-comment"># 保留下来的序列的长度</span><br>    corpus_indices = corpus_indices[: corpus_len]  <span class="hljs-comment"># 仅保留前corpus_len个字符</span><br>    indices = torch.tensor(corpus_indices, device=device)<br>    indices = indices.view(batch_size, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># resize成(batch_size, )</span><br>    batch_num = (indices.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) // num_steps<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(batch_num):<br>        i = i * num_steps<br>        X = indices[:, i: i + num_steps]<br>        Y = indices[:, i + <span class="hljs-number">1</span>: i + num_steps + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">yield</span> X, Y<br></code></pre></td></tr></table></figure><p>同样的设置下，打印相邻采样每次读取的小批量样本的输入<code>X</code>和标签<code>Y</code>。相邻的两个随机小批量在原始序列上的位置相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> X, Y <span class="hljs-keyword">in</span> data_iter_consecutive(my_seq, batch_size=<span class="hljs-number">2</span>, num_steps=<span class="hljs-number">6</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;X: &#x27;</span>, X, <span class="hljs-string">&#x27;\nY:&#x27;</span>, Y, <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">X:  tensor([[ 0,  1,  2,  3,  4,  5],        [15, 16, 17, 18, 19, 20]]) Y: tensor([[ 1,  2,  3,  4,  5,  6],        [16, 17, 18, 19, 20, 21]]) X:  tensor([[ 6,  7,  8,  9, 10, 11],        [21, 22, 23, 24, 25, 26]]) Y: tensor([[ 7,  8,  9, 10, 11, 12],        [22, 23, 24, 25, 26, 27]]) </code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>DL</category>
      
      <category>PyTorch</category>
      
      <category>NLP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
