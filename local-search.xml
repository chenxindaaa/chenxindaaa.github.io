<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2023/05/02/Docker/"/>
    <url>/2023/05/02/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker教程">Docker教程</h1><h2 id="一docker三要素">一、Docker三要素：</h2><ol type="1"><li>image <span class="math inline">\(\rightarrow\)</span> class</li><li>container <span class="math inline">\(\rightarrow\)</span> instance</li><li>repository <span class="math inline">\(\rightarrow\)</span> 存放image的场所，官方registry称为Docker Hub</li></ol><h2 id="二安装">二、安装</h2><p><a href="https://docs.docker.com/engine/">步骤</a></p><p><code>Note：Set up the repository</code></p><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云镜像加速</a></p><h2 id="三docker常用命令">三、Docker常用命令</h2><h3 id="帮助启动类命令">3.1 帮助启动类命令</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl start docker  <span class="hljs-comment"># 启动docker</span><br><span class="hljs-params">system</span>ctl stop docker  <span class="hljs-comment"># 停止docker</span><br><span class="hljs-params">system</span>ctl restart docker  <span class="hljs-comment"># 重启docker</span><br><span class="hljs-params">system</span>ctl status docker  <span class="hljs-comment"># 查看docker状态</span><br><span class="hljs-params">system</span>ctl enable docker  <span class="hljs-comment"># 开机启动</span><br>docker info  <span class="hljs-comment"># 查看docker概要信息</span><br>docker --help  <span class="hljs-comment"># 查看docker总体帮助文档</span><br>docker 具体命令 --help  <span class="hljs-comment"># 查看docker命令帮助文档</span><br></code></pre></td></tr></table></figure><h3 id="镜像命令">3.2 镜像命令</h3><ul><li>docker images [OPTIONS]：列出本地主机上的镜像<ul><li>各个选项说明: REPOSITORY：表示镜像的仓库源 TAG：镜像的标签版本号 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</li><li>OPTIONS说明：<ul><li>-a :列出本地所有的镜像（含历史映像层）</li><li>-q :只显示镜像ID。</li></ul></li></ul></li><li>docker search [OPTIONS] 镜像名字：搜索镜像<ul><li>OPTIONS说明：<ul><li>--limit : 只列出N个镜像，默认25个 e.g. docker search --limit 5 redis</li></ul></li></ul></li><li>docker pull 某个XXX镜像名字：下载镜像<ul><li>docker pull 镜像名字:[TAG] 没有TAG就是最新版等价于docker pull 镜像名字:latest</li></ul></li><li>docker system df：查看镜像/容器/数据卷所占的空间</li><li>docker rmi 某个XXX镜像名字ID：删除镜像<ul><li>删除单个 docker rmi -f 镜像ID</li><li>删除多个 docker rmi -f 镜像名1:TAG 镜像名2:TAG</li><li>删除全部 docker rmi -f $(docker images -qa) ### 3.3 容器命令</li></ul></li><li>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]：新建+启动容器<ul><li>OPTIONS说明：有些是一个减号，有些是两个减号<ul><li>--name="容器新名字" 为容器指定一个名称；</li><li>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</li><li>启动交互式容器(前台有伪终端，等待交互)<ul><li>-i：以交互模式运行容器，通常与 -t 同时使用；(interactive)</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；(terminal)</li><li>e.g. docker run -it ubuntu /bin/bash： 使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令 /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。要退出终端，直接输入 exit:</li></ul></li><li>-P: 随机端口映射，大写P</li><li>-p: 指定端口映射，小写p</li></ul></li></ul></li><li>docker ps [OPTIONS]：·列出当前所有正在运行的容器<ul><li>OPTIONS说明<ul><li>-a：列出当前所有正在运行的容器+历史上运行过的</li><li>-l：显示最近创建的容器。</li><li>-n：显示最近n个创建的容器。</li><li>-q：静默模式，只显示容器编号。</li></ul></li></ul></li><li>退出容器 关系 指向 进入正在运行的容器并以命令行交互 ·两种退出方式 ·exit ·run进去容器，exit退出，容器停止 ·ctrl+p+q ·run进去容器，ctrl+p+q退出，容器不停止 ·启动已停止运行的容器 ·docker start 容器ID或者容器名</li><li>重启容器 ·docker restart 容器ID或者容器名 ·停止容器 ·docker stop 容器ID或者容器名 ·强制停止容器 ·docker kill 容器ID或容器名 ·删除已停止的容器 ·docker rm 容器ID ·一次性删除多个容器实例 ·docker rm -f $(docker ps -a -q) ·docker ps -a -q | xargs docker rm</li></ul><h2 id="reference">Reference:</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1gr4y1U7CY?p=1&amp;vd_source=bd05c11d5f9bf6d6b4849b57473d2194">尚硅谷Docker实战教程</a> <a href="https://space.bilibili.com/393424102">JJacobb</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMake</title>
    <link href="/2022/12/01/CMake/"/>
    <url>/2022/12/01/CMake/</url>
    
    <content type="html"><![CDATA[<h1 id="最小配置示例">最小配置示例</h1><h2 id="cmakelists.txt">CMakelists.txt</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cmake<span class="hljs-constructor">_minimum_required(VERSION 3.0)</span>  # cmake最低版本<br>project(sample CXX)  # 项目名称<br>add<span class="hljs-constructor">_library(<span class="hljs-params">sample</span> <span class="hljs-params">sample</span>.<span class="hljs-params">cpp</span>)</span>  # 添加库<br>add<span class="hljs-constructor">_executable(<span class="hljs-params">sample_exe</span> <span class="hljs-params">sample_exe</span>.<span class="hljs-params">cpp</span>)</span>  # 添加可执行程序<br></code></pre></td></tr></table></figure><h2 id="相关函数">相关函数</h2><ul><li>project：定义工程名称，并可指定工程支持的语言<ul><li>project(projectname [CXX] [C] [Java][C CXX])</li><li>项目对应的变量：<ul><li>PROJECT_NAME：项目名称</li><li>PROJECT_SOURCE_DIR：项目源码根目录</li><li>PROJECT_VERSION：项目版本</li><li>PROJECT_BINARY_DIR：项目生成的临时二进制目录，用于存放配置/编译中间文件。</li></ul></li></ul></li><li>add_library：生成库文件<ul><li>add_library(libname [SHARED|STATIC|MODULE][EXCLUDE_FROM_ALL] source)<ul><li>libname： 库名称</li><li>source：源文件，可以使用列表变量，也可以直接添加源文件名称，还可以使用函数 target_source 添加源文件</li><li>SHARED：声明该库仅被作为动态库生成</li><li>STATIC 声明该库仅被作为静态库生成</li></ul></li></ul></li><li>add_executable：生成可执行文件<ul><li>add_executable(exename source)</li></ul></li></ul><h2 id="生成项目">生成项目</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">cmake -G <span class="hljs-string">&quot;Unix Makefiles&quot;</span> ..<br>make<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cmake.exe -S .<span class="hljs-regexp">/sample -B ./</span>sample/binary -G <span class="hljs-string">&quot;Visual Studio 16 2019&quot;</span> -A x64<br>cmake.exe --build .<span class="hljs-regexp">/sample/</span>binary<br></code></pre></td></tr></table></figure><h3 id="命令行参数">命令行参数</h3><ul><li>-S 顶级CMakeLists.txt（包含project声明）所在路径。</li><li>-B 存放临时编译的二进制文件（.obj、.ilk等）和编译器对应的配置文件路径。</li><li>-G 编译器名称</li><li>-A 架构名称</li><li>-D 使用该变量以向cmake传入各种参数，包括选项及覆盖cmake提供的各种默认变量值。</li><li>--toolchain cmake toolchain文件路径。</li><li>--install-prefix 安装的二进制存放路径。</li><li>--trace / --trace-expand 调试时使用，用于打印已执行的cmake代码及行号。否则仅输出函数message中的内容。</li><li>--build 使用cmake直接调用编译器编译项目。</li><li>--config 选择需要编译的项目配置类型。</li><li>--install 安装已编译好的二进制文件至 CMAKE_INSTALL_PREFIX 中。</li></ul><h1 id="依赖管理">依赖管理</h1><h2 id="查找依赖">查找依赖</h2><ul><li><p><a href="https://link.zhihu.com/?target=https://cmake.org/cmake/help/latest/command/find_package.html#id7">find_package</a>：使用预先设置的配置文件来查找依赖项 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs inform7">find_package(PACKAGE_NAME_CASE_SENSITIVE<br>             <span class="hljs-comment">[version]</span> <span class="hljs-comment">[EXACT]</span> <span class="hljs-comment">[QUIET]</span><br>             <span class="hljs-comment">[REQUIRED]</span> <span class="hljs-comment">[<span class="hljs-comment">[COMPONENTS]</span> <span class="hljs-comment">[components...]</span>]</span><br>             <span class="hljs-comment">[OPTIONAL_COMPONENTS components...]</span><br>             <span class="hljs-comment">[CONFIG|NO_MODULE]</span><br>             <span class="hljs-comment">[NO_POLICY_SCOPE]</span><br>             <span class="hljs-comment">[NAMES name1 <span class="hljs-comment">[name2 ...]</span>]</span><br>             <span class="hljs-comment">[CONFIGS config1 <span class="hljs-comment">[config2 ...]</span>]</span><br>             <span class="hljs-comment">[HINTS path1 <span class="hljs-comment">[path2 ... ]</span>]</span><br>             <span class="hljs-comment">[PATHS path1 <span class="hljs-comment">[path2 ... ]</span>]</span><br>             <span class="hljs-comment">[PATH_SUFFIXES suffix1 <span class="hljs-comment">[suffix2 ...]</span>]</span><br>             <span class="hljs-comment">[NO_DEFAULT_PATH]</span><br>             <span class="hljs-comment">[NO_PACKAGE_ROOT_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_ENVIRONMENT_PATH]</span><br>             <span class="hljs-comment">[NO_SYSTEM_ENVIRONMENT_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_PACKAGE_REGISTRY]</span><br>             <span class="hljs-comment">[NO_CMAKE_BUILDS_PATH]</span> # Deprecated; does nothing.<br>             <span class="hljs-comment">[NO_CMAKE_SYSTEM_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]</span><br>             <span class="hljs-comment">[CMAKE_FIND_ROOT_PATH_BOTH |</span><br><span class="hljs-comment">              ONLY_CMAKE_FIND_ROOT_PATH |</span><br><span class="hljs-comment">              NO_CMAKE_FIND_ROOT_PATH)</span><br></code></pre></td></tr></table></figure></p><p>常用参数：</p><ul><li>PACKAGE_NAME_CASE_SENSITIVE 查找的库的名称，大小写敏感，与之对应的是调用了包含此名称的配置文件。</li><li>version 依赖的版本号。如果依赖的配置同时提供了版本文件，则会使用该值对比配置中的版本而确定是否可以使用。</li><li>EXACT 版本号必须严格对应配置中的版本号。</li><li>QUIET 关闭了查找信息（不包含查找失败/错误信息）的输出。</li><li>REQUIRED 如果库没找到就报错。</li><li>CONFIG 该关键字声明了需要使用 依赖项通过自己的cmake代码 使用cmake 自动生成的 配置文件，入口配置文件名称一般为 <LOW_CASE_PACKAGE_NAME>-config.cmake 或 <ALL_CASE_PACKAGE_NAME>Config.cmake 。</li></ul></li><li><p>find_library：原始的cmake查找依赖方式，直接查找依赖项库文件。 <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog">find_library (<br>          &lt;<span class="hljs-symbol">LIBRARY_NAME</span>&gt;<br>          name | <span class="hljs-symbol">NAMES</span> name1 [name2 ...] [<span class="hljs-symbol">NAMES_PER_DIR</span>]<br>          [<span class="hljs-symbol">HINTS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>          [<span class="hljs-symbol">PATHS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>          [<span class="hljs-symbol">PATH_SUFFIXES</span> suffix1 [suffix2 ...]]<br>          [<span class="hljs-symbol">DOC</span> <span class="hljs-string">&quot;cache documentation string&quot;</span>]<br>          [<span class="hljs-symbol">NO_CACHE</span>]<br>          [<span class="hljs-symbol">REQUIRED</span>]<br>          [<span class="hljs-symbol">NO_DEFAULT_PATH</span>]<br>          [<span class="hljs-symbol">NO_PACKAGE_ROOT_PATH</span>]<br>          [<span class="hljs-symbol">NO_CMAKE_PATH</span>]<br>          [<span class="hljs-symbol">NO_CMAKE_ENVIRONMENT_PATH</span>]<br>          [<span class="hljs-symbol">NO_SYSTEM_ENVIRONMENT_PATH</span>]<br>          [<span class="hljs-symbol">NO_CMAKE_SYSTEM_PATH</span>]<br>          [<span class="hljs-symbol">CMAKE_FIND_ROOT_PATH_BOTH</span> |<br>           <span class="hljs-symbol">ONLY_CMAKE_FIND_ROOT_PATH</span> |<br>           <span class="hljs-symbol">NO_CMAKE_FIND_ROOT_PATH</span>]<br>         )<br></code></pre></td></tr></table></figure></p><ul><li>LIBRARY_NAME：由于直接查找库文件而不是查找配置文件，此名称仅作为结果中宏的前缀使用。</li><li>NAMES：此项声明了库文件的名称。值得注意的是，在UNIX-style系统中，自动添加“lib”作为库名称的前缀。</li><li>NAMES_PER_DIR：一个名称遍历查找一次，再用另一个名称遍历查找一次。而不是根据路径使用多个名称遍历。</li><li>查找完成后：<ul><li>如果查找到，则会设置 LIBRARY_NAME 为查找到的库文件的名称（包含全路径）。</li><li>如果没有查找到，则会将 LIBRARY_NAME 设置为 <LIBRARY_NAME>-NOTFOUND 。</li></ul><p>所以这里和 find_package 又有不同，我们应当使用以下代码判断是否查找到:</p><p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">PACKAGE_NAME</span> <span class="hljs-variable">MATCHES</span> <span class="hljs-string">&quot;-NOTFOUND&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-title">message</span>(<span class="hljs-variable">FATAL_ERROR</span> <span class="hljs-string">&quot;$&#123;PACKAGE_NAME&#125; not found!&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-title">endif</span>()</span><br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>find_path：这个函数一般是查找头文件或其他的 非库文件 且 非可执行程序。其函数原型为： <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog">find_path (<br>         &lt;<span class="hljs-symbol">FILE_NAME</span>&gt;<br>         name | <span class="hljs-symbol">NAMES</span> name1 [name2 ...]<br>         [<span class="hljs-symbol">HINTS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>         [<span class="hljs-symbol">PATHS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>         [<span class="hljs-symbol">PATH_SUFFIXES</span> suffix1 [suffix2 ...]]<br>         [<span class="hljs-symbol">DOC</span> <span class="hljs-string">&quot;cache documentation string&quot;</span>]<br>         [<span class="hljs-symbol">NO_CACHE</span>]<br>         [<span class="hljs-symbol">REQUIRED</span>]<br>         [<span class="hljs-symbol">NO_DEFAULT_PATH</span>]<br>         [<span class="hljs-symbol">NO_PACKAGE_ROOT_PATH</span>]<br>         [<span class="hljs-symbol">NO_CMAKE_PATH</span>]<br>         [<span class="hljs-symbol">NO_CMAKE_ENVIRONMENT_PATH</span>]<br>         [<span class="hljs-symbol">NO_SYSTEM_ENVIRONMENT_PATH</span>]<br>         [<span class="hljs-symbol">NO_CMAKE_SYSTEM_PATH</span>]<br>         [<span class="hljs-symbol">CMAKE_FIND_ROOT_PATH_BOTH</span> |<br>          <span class="hljs-symbol">ONLY_CMAKE_FIND_ROOT_PATH</span> |<br>          <span class="hljs-symbol">NO_CMAKE_FIND_ROOT_PATH</span>]<br>        )<br></code></pre></td></tr></table></figure> 一般情况下，由于需要cmake表达式来让cmake判断使用哪个配置的库，我们通常这么写：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">find_path</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;_INCLUDE_DIR NAMES header.h PATH_SUFFIXES include/...)</span></span><br><br><span class="hljs-function"><span class="hljs-title">find_library</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;_LIBRARY_RELEASE NAMES name1 name2)</span></span><br><span class="hljs-function"><span class="hljs-title">find_library</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;_LIBRARY_DEBUG NAMES name1d name2d)</span></span><br><span class="hljs-function"><span class="hljs-title">select_library_configurations</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;)</span></span><br>...<br>target_*(target_name $&#123;&lt;PACKAGE_NAME&gt;&#125;)<br></code></pre></td></tr></table></figure></li><li><p>find_program：这个函数专门用于查找可执行程序</p></li></ul><h2 id="使用依赖">使用依赖</h2><p>经过了上面的狂轰乱炸，我们终于可以使用依赖项了。我们可以将查找到的依赖项用于多个函数中，例如添加头文件路径，添加链接库，添加编译选项等。</p><p>对于不同的查找方式，配置文件或cmake提供了不同的使用方式：</p><ul><li><p>宏 例如 <PACKAGE_NAME>_INCLUDE_DIRS 和 <PACKAGE_NAME>_LIBRARIES 这种方式。</p><p>对于头文件来讲，直接加到include_directories中就好了。而对于库来讲，则复杂点：</p><p>由于不能混合使用debug库及release库，cmake必须明确知道在不同配置下使用哪个库。所以宏中一般使用到了cmake表达式来处理这种情况，比如： <span class="math inline">\(&lt;\)</span><CONFIG:DEBUG>:library.lib&gt; <span class="math inline">\(&lt;\)</span>{NOT:$<CONFIG:DEBUG>&gt;:libraryd.lib&gt; 所以我们在写配置时，尽量将debug和release库均查找后使用 select_library_configurations 来生成表达式以便不同配置下使用。</p></li><li><p>target target 就简单的多了，因为它是一个object，cmake函数可以轻松提取 target 包含的需要使用的属性来使用。 当然，target 包含非namespace与namespace两种形式，不过使用上没区别。 ## 内部依赖</p></li><li><p>add_dependencies： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_dependencies(&lt;<span class="hljs-params">target</span>&gt; [&lt;<span class="hljs-params">target</span>-<span class="hljs-params">dependency</span>&gt;]<span class="hljs-operator">...</span>)</span><br></code></pre></td></tr></table></figure> 向前者添加依赖项（后者），可以添加多个。在编译或某些配置时，优先处理后者。</p></li></ul><h1 id="编译相关函数">编译相关函数</h1><h2 id="关键字">关键字</h2><ul><li><p>target target在cmake中是一个很重要的概念，可以理解为一个实例化对象， 一般是由add_executable()，add_library() 或 add_custom_target() 命令之一创建，它包含了例如以下内容：</p><ul><li>相关的源文件列表</li><li>相关的编译选项</li><li>相关的依赖库</li><li>相关的头文件路径列表</li><li>相关的库文件路径列表</li><li>相关的其他属性</li></ul></li><li>PUBLC PRIVATE INTERFACE 例如 target_link_libraries(A [PUBLIC/PRIVATE/INTERFACE] B)<ul><li>PUBLIC 依赖项B仅链接到目标A，若有C链接了目标A，C不链接依赖项B。</li><li>PRIVATE 依赖项B并不链接到目标A，若有C链接了目标A，C会链接依赖项B。</li><li>INTERFACE 依赖项B链接到目标A，若有C链接了目标A，C也会链接依赖项B。 &gt; <a href="https://www.jianshu.com/p/07761ff7838e">CMake 中的 PUBLIC，PRIVATE，INTERFACE</a></li></ul></li></ul><h2 id="相关函数-1">相关函数</h2><ul><li><p>target_compile_options：向目标添加编译选项 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_compile_options(&lt;<span class="hljs-keyword">target</span>&gt; [BEFORE]<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_compile_options(<span class="hljs-params">sample</span> PUBLIC <span class="hljs-operator">/</span><span class="hljs-params">arch</span>=<span class="hljs-params">avx2</span> <span class="hljs-operator">/</span>Wall)</span><br></code></pre></td></tr></table></figure></p></li><li><p>target_compile_definitions：向目标添加预设宏声明及定义</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_compile_definitions(&lt;<span class="hljs-keyword">target</span>&gt;<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">target_compile_definitions</span><span class="hljs-params">(sample PRIVATE BUILD_DLL PUBLIC <span class="hljs-string">&quot;-DPI=3.14159&quot;</span>)</span></span><br></code></pre></td></tr></table></figure></li><li><p>target_include_directories：声明了编译目标时查找使用头文件的路径。</p><p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_include_directories(&lt;<span class="hljs-keyword">target</span>&gt; [SYSTEM] [AFTER|BEFORE]<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure></p>例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_include_directories(<span class="hljs-params">sample</span> PUBLIC <span class="hljs-params">public</span><span class="hljs-operator">/</span><span class="hljs-params">include</span><span class="hljs-operator">/</span><span class="hljs-params">sample</span> PRIVATE <span class="hljs-params">sample</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>target_link_libraries：声明了链接时需要参与的依赖库名称或target，其名称可包含完整路径。</p><p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_link_libraries(&lt;<span class="hljs-keyword">target</span>&gt;<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">sample</span> PUBLIC CURL::<span class="hljs-params">curl</span> <span class="hljs-params">glib</span> <span class="hljs-params">m</span>)</span><br></code></pre></td></tr></table></figure> 注意：由于一个target中包含多个属性，一般情况下包含了头文件路径。所以使用target作为参数传入此函数时，无需调用 target_include_directories 再次声明添加头文件路径。</p></li><li><p>target_link_libraries：声明了链接时查找依赖库的路径。 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_link_libraries(&lt;<span class="hljs-keyword">target</span>&gt; [BEFORE]<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">sample</span> PUBLIC <span class="hljs-params">third_party</span><span class="hljs-operator">/</span><span class="hljs-params">libs</span><span class="hljs-operator">/</span><span class="hljs-params">x86</span><span class="hljs-operator">/</span><span class="hljs-params">rel</span>)</span><br></code></pre></td></tr></table></figure></p></li></ul><h2 id="target族函数注意事项">target族函数注意事项</h2><p>当需要使用cmake export关键字导出声明的target并附带其中的 PUBLIC 属性时，我们必须 将PUBLIC / PRIVATE / INTERFACE 关键字向这类 target 族函数补齐。且如果一个 target 族函数声明了这三个关键字其中之一，该 target 所属的其他 target 族函数均应当声明关键字。且对于包含路径的值，我们需要声明此值的使用范围：</p><p>编译/链接时使用。必须使用绝对路径。 导出以向下游提供。必须使用相对路径。 所以，我们通常情况下使用以下方式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">target_include_directories(sample <span class="hljs-variable constant_">PRIVATE</span> <span class="hljs-variable">$&lt;</span><span class="hljs-variable constant_">BUILD_INTERFACE</span><span class="hljs-symbol">:</span><span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">CMAKE_SOURCE_DIR</span>&#125;/header/<span class="hljs-keyword">include</span>&gt; <span class="hljs-variable constant_">PUBLIC</span> <span class="hljs-variable">$&lt;</span><span class="hljs-variable constant_">INSTALL_INTERFACE</span><span class="hljs-symbol">:include&gt;</span>)<br></code></pre></td></tr></table></figure><h1 id="reference">Reference</h1><p><a href="https://www.zhihu.com/column/c_1490802622991306752">CMake教程系列</a></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C++</category>
      
      <category>CMake</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Academic Writing</title>
    <link href="/2022/11/28/Effective%20Academic%20Writing/"/>
    <url>/2022/11/28/Effective%20Academic%20Writing/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="884eb34aa131356643002d0cd5f5394ddc245abd3d301c7f73327a88f55c0138">4630436162ade97ba2718b7d0c4b3b6376f3306e7b9798bdbcb35e81f16aa19b0645320c632847b028c3598cd6616474b46847a04718e53a8112e5f830a8601402ac7c967a18b3f2c246eb0842b3f1834dcd342e58490f5f43bb9235f219e267c2057d968dc7f9f0c13f4da67311d41d6307b40c73edf852f5130449a36972a60c4f3027ea91ae6eb486c7e688ec83d5217ee00edaacb992b47c85caca964b868c2a11ebe6995a3a9dc6e9eb096384f2bc7e3a896140b5196286ea0b5488fc7b82565e00dde5f228946a2bc1646740a85c83d258bcc9c9e1336a05e162b61f643a23c6918fe92d7b29f688ac06e493f91ab4593fe200b362628211b6e846b800c9c248fe44c53ff2667764aab91272eee93ce7b5095d64fca552631a8011710303bf6c16305ccf6fc83e7a5ff6b87a3e88daa2ca433105897a84f7784d9d7a1b295007504ba39fa4bc3a91a16c14b55cb2a057f88d8b416577972886b38af0b647033bc4e820138c7f8e97078ef12dd082c497da4ecbc07f15aae90f07969306c6e2ef2a46020f4350ab537820fbdc6fe370536ff12094d18ed90b2b56b89bc44ef82e716a1fab0aa5fa996b922c32cf3de91bed20d7f957d58bdbcb83889c89fdad2dac4c6fa69f894d9ca6731aef0993bdaca2aa3571235ba900e2aec284c7dfa47f1001e728c6119a7c511cfb18e15ae0c5eb4ea796b59b4cedd7d1d8dce50f827bbeb89877010bf9fd6228545161b273ce998ae8439c0232480fc54a8b83fc13955c892b122bcbc0979e4134eb5979d73e949bd3296db0b0603fcf7cb3aba716edf2d59ddcab5097613582a255e1d276de91fd368bbee7fc36e744f81b44faa9f9d01b4778ec80aa12b36733f392d0e8a285ca4b815261ff8eb5e52f7a1c2c5bb636aed8046008424b281fed923e0ed8767e0b747022bd9e84f37a98382c22c2e71a27bf48cbd983e4f11cd647a8ef8551cb2420275c644215ce3047884884708b0dea219e06e6b5686e63263423532963d145cc7681e075a275045f2d431a7f0c14a6c89b11c09834f2add1f8b357f093a3d65b9586276b2d1a0f978dcaa075ebfc73149c2fcb7dd42c0d98084db4124f63215ab5322e3f35a7b87acbcaa51d600b4952cf77d8b153b272ed51690be4a1fc2c05c2555455e4b48043a99f65b2a473827a7f8c9391b6cd9bc065ac47456e19adf238bc1523a88845b1bb8d0bcba6c5920703e666c84baf56175185e5394f5416a3a61524f6f6eeaffa0a10d3ec4130ed5bcb2f4ecd0035dc55368e56be470976013ffd2021647b72f0f03a11216815b104582c39ea319dea2e0e122eaebef6ad2e7eb64da008e9f46a3135ffd1f8afcc9370c67a4a7b36b19e0c41134a5d9eb436893c3befe20ee158c7599ef09f5be1fe2c813e46fd098d5b3d58010981bfb65724925568b03241a6700112f5309a2fb697ca6feae78763eb6ce007f58584bc427cf36e40fb73b52d368d42e750907a45e2c278d0706fdc3d58a3b80957fb1db474fb6bcb792b8eefe8937ed647b41505dbfa76faf4ebc7659a25c8a8933a6325519279482f7cb912afc0f54aac82131055ba630f78dbd03523379b516351698e6bf4fc9caa8ff981c2f3b546f4f205191f65074c34bcfd56cd2cb156c082cf2ddf7b531d433d743e98f01e239a00688c89b2badbacaf643c282cd1edffd79b416cfa72f76935893a1cd737eb14afcbe3b77820920526d6a561a80e9882e5abd5aaec8446d33a82aaeb1f136ff13ccb2ebceb986f205c02f72d6d72bf9ac567e9dbd3cbf88b5288fb10503630d78154078616f21eca79a735b0180930aa718f1ac16fd05bceca0b57e328ca484b437190663cac2c1e150537f4702c2bd4fbad4956b466ae864e9668cf74af991e24b6e6ab8d56cbb28fa33d59f5e0335e166b2be064c69ba17695d15ce6add2f0421fd821f91a4c0e8bd7060d31d3486dbe4c44ad3dc3c0a0249398a735522bb44faa8c39ae87ec82c710d84585d59e5b45818e14c80b09a384220000a941ffb87c25545f14fd8f960194c1cca76977213d859ce816355c45a955a0cd590a9284f534c48ad88e0d1879fafcd48a4f8ae432eaec7855030c17e8815483d41df9070775b4644d1ef162001ada1c03d3b624040a9ff382803fbd14d2070813a38c5080bc8f2c077d51532c9a45aacc508f24d29edf97659e01c33c9e1eef91d97fcad8e73b9461cccfccefb9308451791e33a0b001e2d6a60fc070589b856cf0327b83c246d371afd2be783c9a3cf826bdffc5c4c5a3b1cbc1dc8ee051068f26f4a633e4530418534295dc339896d5000d14d66141455fb260e5c0c9ef4960a1e0fa8f14b1dcdcab0a948ebf5c319b4e7c77bf11903b897ca59edd0d7307c3afc3dd22678b2627c4d2e1d236d601c1a2ea927540c994317ce04377843fa3a10201a32dee352e7327db229a7161ec3d2fc4111175ce355290af2db716ed1c5a5ee07ec91e8d6da8bfd8c8dc4743e48929f9fa6bf1ac482116cd04402c42f02e4af8c980a33b8b2cc7f80dde4276257a0ec29e349f959af3fe4c068fa84bfd60b54a509db9f00b9d6d212475613f7cebb0688a03bd73b92a47c4838f4f1031f7a476da37cd6c684c0066022edb690ca7cafcd6e7e5ef7d77be1370411ff74cbad329f0effd1a4adb4e687a21c4bc315830f9c56e9d930f02cac1a0cf448cce4fd8e0c7b86b3c374314f9840dd34c4d2579590fa9e978996d4995237dbbd33221c255d71ab94cd01a9768a40105273cd38c9da308e7b39b95146ec53d8a07a2fed15a7aa83dbad116ecf3f4ce8509f6aafe0646d06708f3077985bffab2c470eea3eab98848fe1cb1ffe83484d7697da9c3d7b5fb534be5bafd059f5ef6efafbcc0641429cf8dab809e188b0d6f266cdf4e69240c4666e9b9ae46b1ecce232dfe8f11a6e152556efdbe02cc1933652412c9b3b504371b2a83969dcd69ade13fdee569233f03e8843d24b2ccf97e2f17c8974ef45abfb0b6af08c89705204d7b4c4cea26a2dc3879c64cac84540cf114a428c9e35f7672d9c8d3d1d925da86277975089c7ddba7ceabba2625a1868f9cd19a9d4babdc1eb28828e6a0e1d00aff02014d519f9a88fff7cf6c753f9c70098aab988672eb2db2e64bafb977d16514046e50dd055aef45b32a79ec4b640706a0834a4c4cdfa5aacc91ab49478e890e2a44c2bdb5ed6242fa9f06e6061afef5aed1eccd2f12d6a846f1c833df7c7059bd271b1936352f98b57a7ef13dffe97b3fc808279a26f9e71e171ada71162aaeb8648d20db6fcbd04d57db2e7fa8c3aa4d60710ddc0fbdb5f6c6268c007659a1c2d001565d8da7ae0bedb9949a55032e639eb0c90007d5036fde75835150ab5d73f7f2fbb8967941e11e01df648728d86ddff782a5264062832823849ab84de4c5a2c11784e33a3f884c40a1262b89eed302689e4b31c0933850a68f443bab26b2e5d9c21d3f7df3080f6ef59a680befe584bb9ccb92065f8817ae6665f82b57a6ab927c5fe99dfed3086479ffac6ef7d6094885426458cf1baba9ff58c429d0f541e5d8ee781d424a9651446ed95f477b19f5045e002e6229383489d505d554f59b2c34c50d1c1c959134d0fb65a620494a903640dc8a68360faa94daad34698e8b6742cefc79a5edbb4488a5c57b2de18aa2805d974b01eeae4a89fdd3a2eb90463148a8627dfa1f80adfec7d49a22d9d49ca40b51eddb4412b8242d1d2a9ec3e08b4b5f23b087750fc6a57e2463056578c440fd9a464f6c93b532540b8fc457a1438d3b0b0dfb12c7b374076238aa74554a8b0a768f65c3fa9f631d965198d3ef92e6338f5e3a85da00ecaf7ca079ab1114e19784923bdb5ce364820c04d02f27f7921b977f8e4ec78f3526fe5cdaa839be7f99f1bf425e6c5f1ab5c49c19d59332fbc31c1250effbbb9440f58860fb04fabcbfa10b496744434c25be3b30112069aa70cb89d47162897194f483aea7274248ee3562b78c258ec940c42832fd883fb180657c6c25c5b260953681254c2c69acb99b973ed0642f50bd8d546ac3662822227bae7d0b23683b23ac006bee519ad90e1f8fb955512602b5e63d426e1fdd0b25f8b5dc1bcf6ad69a2562542f6b6a8fa2c3f52e5adf334149c933b31d330cfa80930f96610c08469cf933bbd514c5e60d8625b0c067f17ae3cb0df5323989a3093e8e03d688d0e39cbf4912a5c15afda6bffc4600ec087d45f412bb0baf110a1316d8d112174612565dc6958409c199e9dbabd106fd15e3dc682be7506fd0a17904ecf29fed4fbb707afefc9238147180ab8babd06cd109bf9052ddb1a41b4546602794ab3e716ebbec68764abf0efc6772644bb707ed19b6a8f3e6ae55689bca17b2f3ade7aa1b621f7815a574753fcf6cebf36c7faad4d35adc02067c5542bd1fc5fa204f8b4e05b5db4b24a039addac7334bca3672185e4347a1edd597e041c22101370b69d8a009d1c2807557d2e8eddacb203fb1b65d57b65ec76812aac495955d815b828a19a8ea28eb688faa3174e353469dcd6a798ba251ac8bcb859d0a3186d894c37a458bd5900b64032619e6b90ca6fc50d1c02871e93f1fd2ef04867e94729336093e957565833e2378acdde413d3809f80dd8926722e40802071a075d821193854f8a6897e1b755fd3c2df4c48c835d661b8cef3951fd2f9332ee372c7a73f9b5169637f27323de587c244ccbb74496d7858fa6615a2ccf8ffd1f275af2c2676b5a690a45f11713dc359b265b5becc77e5bd81bbc882497bd87ea0ae4036e7a839b63109ed36070b3f288d22a7ee92cc3abda2a590c0748c829dff9c7aafbf67141c79473073b49125dfbe0a49b61784b32bef59e29bd4a981c6e0005abc21a5707fd1ec1985ec05a32c4609ec9aca814c9a33e0a1f998040286b4791dbd19e14ffba621d3beed50c2e52e489d5fa59331a32a980a3e5d170e8399e5b1587a184d7581d40563d2a2a78483bcde61aa70d9124b4666f967dce66308d1650e83779bc2ca30a40fcb08460626309bb8579f7294774ee3cd724c8d1627c3c8bd61b633db93913c78bd2ae7f4c4e127d5059426b99f436e5fbfe0aaea91429a3e719729bdcde0de370a79319468490f0f0faa5cc3d48ebe29e45270b9510eb1aea434d21395eba8d7087f7ba130b9ee3b90168da40ff2f2007c57319c2c89d51766391d4d4ea6b382d8b1e7de01c6f9dbc722da2677a5092c01130803f914cb588f9edae85bae01828d474ad178f7db211dd09bb69a1b2a14985abd6442874ebf661b6a9af3f45d1526e46b6c5015e6404f6937583ceb268928d57a07a9590a5840ca01d1bc47388dbf65cae8c5633384a61f747b3e372ddcba14a3881896b7d9bb60a4a606d86f015d66c3f7271adf1d39b908412155b13f0fadab002cf994ac3ec3840ccf1533d4367aa2e2ecfd9feb94d648e19758ab733b4151006df010b093bb80f412c33d85568af416865921455d18f8a326fb7eb0d8ead24a6a7780acd65e304d1002cbc783e4b54ff3a4cd62cd4e6e55297b98d7762636b6ce430f82e8c67af0fb2f241e4636108c13b8396c3da53304d1415266cab311d799aff31833562ddfb08e970d4caea0428a41bb6f0167dbe7918260b1c5af5046e1bf7f1d75f98379918b08b58d9ed026f16f6dde5a9fe5513c9d6e213eb1cef2b7ce3a59c40d24799c8bf51fd9b7083dffd5184bb49457ce7c4e0fe0a60a404da7b834e563b725efa0bfd93dba180d446bbf83ec88676b88dc98683f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my blog, enter password to read.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Academic Writing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dive into DL: Language Model</title>
    <link href="/2020/02/14/Dive%20into%20DL-Language%20Model/"/>
    <url>/2020/02/14/Dive%20into%20DL-Language%20Model/</url>
    
    <content type="html"><![CDATA[<h1 id="语言模型">语言模型</h1><p>一段自然语言文本可以看作是一个离散时间序列，给定一个长度为<span class="math inline">\(T\)</span>的词的序列<span class="math inline">\(w_1, w_2, \ldots, w_T\)</span>，语言模型的目标就是评估该序列是否合理，即计算该序列的概率：</p><p><span class="math display">\[P(w_1, w_2, \ldots, w_T).\]</span></p><p>本节我们介绍基于统计的语言模型，主要是<span class="math inline">\(n\)</span>元语法（<span class="math inline">\(n\)</span>-gram）。在后续内容中，我们将会介绍基于神经网络的语言模型。</p><h2 id="语言模型-1">语言模型</h2><p>假设序列<span class="math inline">\(w_1, w_2, \ldots, w_T\)</span>中的每个词是依次生成的，我们有</p><p>$$</p><p><span class="math display">\[\begin{align*}P(w_1, w_2, \ldots, w_T)&amp;= \prod_{t=1}^T P(w_t \mid w_1, \ldots, w_{t-1})\\&amp;= P(w_1)P(w_2 \mid w_1) \cdots P(w_T \mid w_1w_2\cdots w_{T-1})\end{align*}\]</span></p><p>$$</p><p>例如，一段含有4个词的文本序列的概率</p><p><span class="math display">\[P(w_1, w_2, w_3, w_4) =  P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_1, w_2) P(w_4 \mid w_1, w_2, w_3).\]</span></p><p>语言模型的参数就是词的概率以及给定前几个词情况下的条件概率。设训练数据集为一个大型文本语料库，如维基百科的所有条目，词的概率可以通过该词在训练数据集中的相对词频来计算，例如，<span class="math inline">\(w_1\)</span>的概率可以计算为：</p><p>$$</p><p>P(w_1) = </p><p>$$</p><p>其中<span class="math inline">\(n(w_1)\)</span>为语料库中以<span class="math inline">\(w_1\)</span>作为第一个词的文本的数量，<span class="math inline">\(n\)</span>为语料库中文本的总数量。</p><p>类似的，给定<span class="math inline">\(w_1\)</span>情况下，<span class="math inline">\(w_2\)</span>的条件概率可以计算为：</p><p>$$</p><p>P(w_2 w_1) = </p><p>$$</p><p>其中<span class="math inline">\(n(w_1, w_2)\)</span>为语料库中以<span class="math inline">\(w_1\)</span>作为第一个词，<span class="math inline">\(w_2\)</span>作为第二个词的文本的数量。</p><h2 id="n元语法">n元语法</h2><p>序列长度增加，计算和存储多个词共同出现的概率的复杂度会呈指数级增加。<span class="math inline">\(n\)</span>元语法通过马尔可夫假设简化模型，马尔科夫假设是指一个词的出现只与前面<span class="math inline">\(n\)</span>个词相关，即<span class="math inline">\(n\)</span>阶马尔可夫链（Markov chain of order <span class="math inline">\(n\)</span>），如果<span class="math inline">\(n=1\)</span>，那么有<span class="math inline">\(P(w_3 \mid w_1, w_2) = P(w_3 \mid w_2)\)</span>。基于<span class="math inline">\(n-1\)</span>阶马尔可夫链，我们可以将语言模型改写为</p><p><span class="math display">\[P(w_1, w_2, \ldots, w_T) = \prod_{t=1}^T P(w_t \mid w_{t-(n-1)}, \ldots, w_{t-1}) .\]</span></p><p>以上也叫<span class="math inline">\(n\)</span>元语法（<span class="math inline">\(n\)</span>-grams），它是基于<span class="math inline">\(n - 1\)</span>阶马尔可夫链的概率语言模型。例如，当<span class="math inline">\(n=2\)</span>时，含有4个词的文本序列的概率就可以改写为：</p><p>$$</p><p><span class="math display">\[\begin{align*}P(w_1, w_2, w_3, w_4)&amp;= P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_1, w_2) P(w_4 \mid w_1, w_2, w_3)\\&amp;= P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_2) P(w_4 \mid w_3)\end{align*}\]</span></p><p>$$</p><p>当<span class="math inline">\(n\)</span>分别为1、2和3时，我们将其分别称作一元语法（unigram）、二元语法（bigram）和三元语法（trigram）。例如，长度为4的序列<span class="math inline">\(w_1, w_2, w_3, w_4\)</span>在一元语法、二元语法和三元语法中的概率分别为</p><p>$$</p><p>\begin{aligned} P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2) P(w_3) P(w_4) ,\ P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2 w_1) P(w_3 w_2) P(w_4 w_3) ,\ P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2 w_1) P(w_3 w_1, w_2) P(w_4 w_2, w_3) . \end{aligned}</p><p>$$</p><p>当<span class="math inline">\(n\)</span>较小时，<span class="math inline">\(n\)</span>元语法往往并不准确。例如，在一元语法中，由三个词组成的句子“你走先”和“你先走”的概率是一样的。然而，当<span class="math inline">\(n\)</span>较大时，<span class="math inline">\(n\)</span>元语法需要计算并存储大量的词频和多词相邻频率。</p><p>思考：<span class="math inline">\(n\)</span>元语法可能有哪些缺陷？</p><ol type="1"><li>参数空间过大</li><li>数据稀疏</li></ol><h1 id="语言模型数据集">语言模型数据集</h1><h2 id="读取数据集">读取数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/kesci/input/jaychou_lyrics4703/jaychou_lyrics.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    corpus_chars = f.read()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(corpus_chars))<br><span class="hljs-built_in">print</span>(corpus_chars[: <span class="hljs-number">40</span>])<br>corpus_chars = corpus_chars.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>)<br>corpus_chars = corpus_chars[: <span class="hljs-number">10000</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">63282想要有直升机想要和你飞到宇宙去想要和你融化在一起融化在宇宙里我每天每天每</code></pre><h2 id="建立字符索引">建立字符索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">idx_to_char = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(corpus_chars)) <span class="hljs-comment"># 去重，得到索引到字符的映射</span><br>char_to_idx = &#123;char: i <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(idx_to_char)&#125; <span class="hljs-comment"># 字符到索引的映射</span><br>vocab_size = <span class="hljs-built_in">len</span>(char_to_idx)<br><span class="hljs-built_in">print</span>(vocab_size)<br><br>corpus_indices = [char_to_idx[char] <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> corpus_chars]  <span class="hljs-comment"># 将每个字符转化为索引，得到一个索引的序列</span><br>sample = corpus_indices[: <span class="hljs-number">20</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;chars:&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>.join([idx_to_char[idx] <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> sample]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;indices:&#x27;</span>, sample)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1027chars: 想要有直升机 想要和你飞到宇宙去 想要和indices: [1022, 648, 1025, 366, 208, 792, 199, 1022, 648, 641, 607, 625, 26, 155, 130, 5, 199, 1022, 648, 641]</code></pre><p>定义函数<code>load_data_jay_lyrics</code>，在后续章节中直接调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data_jay_lyrics</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/kesci/input/jaychou_lyrics4703/jaychou_lyrics.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        corpus_chars = f.read()<br>    corpus_chars = corpus_chars.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>)<br>    corpus_chars = corpus_chars[<span class="hljs-number">0</span>:<span class="hljs-number">10000</span>]<br>    idx_to_char = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(corpus_chars))<br>    char_to_idx = <span class="hljs-built_in">dict</span>([(char, i) <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(idx_to_char)])<br>    vocab_size = <span class="hljs-built_in">len</span>(char_to_idx)<br>    corpus_indices = [char_to_idx[char] <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> corpus_chars]<br>    <span class="hljs-keyword">return</span> corpus_indices, char_to_idx, idx_to_char, vocab_size<br></code></pre></td></tr></table></figure><h2 id="时序数据的采样">时序数据的采样</h2><p>在训练中我们需要每次随机读取小批量样本和标签。与之前章节的实验数据不同的是，时序数据的一个样本通常包含连续的字符。假设时间步数为5，样本序列为5个字符，即“想”“要”“有”“直”“升”。该样本的标签序列为这些字符分别在训练集中的下一个字符，即“要”“有”“直”“升”“机”，即<span class="math inline">\(X\)</span>=“想要有直升”，<span class="math inline">\(Y\)</span>=“要有直升机”。</p><p>现在我们考虑序列“想要有直升机，想要和你飞到宇宙去”，如果时间步数为5，有以下可能的样本和标签： * <span class="math inline">\(X\)</span>：“想要有直升”，<span class="math inline">\(Y\)</span>：“要有直升机” * <span class="math inline">\(X\)</span>：“要有直升机”，<span class="math inline">\(Y\)</span>：“有直升机，” * <span class="math inline">\(X\)</span>：“有直升机，”，<span class="math inline">\(Y\)</span>：“直升机，想” * ... * <span class="math inline">\(X\)</span>：“要和你飞到”，<span class="math inline">\(Y\)</span>：“和你飞到宇” * <span class="math inline">\(X\)</span>：“和你飞到宇”，<span class="math inline">\(Y\)</span>：“你飞到宇宙” * <span class="math inline">\(X\)</span>：“你飞到宇宙”，<span class="math inline">\(Y\)</span>：“飞到宇宙去”</p><p>可以看到，如果序列的长度为<span class="math inline">\(T\)</span>，时间步数为<span class="math inline">\(n\)</span>，那么一共有<span class="math inline">\(T-n\)</span>个合法的样本，但是这些样本有大量的重合，我们通常采用更加高效的采样方式。我们有两种方式对时序数据进行采样，分别是随机采样和相邻采样。</p><h3 id="随机采样">随机采样</h3><p>下面的代码每次从数据里随机采样一个小批量。其中批量大小<code>batch_size</code>是每个小批量的样本数，<code>num_steps</code>是每个样本所包含的时间步数。 在随机采样中，每个样本是原始序列上任意截取的一段序列，相邻的两个随机小批量在原始序列上的位置不一定相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter_random</span>(<span class="hljs-params">corpus_indices, batch_size, num_steps, device=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-comment"># 减1是因为对于长度为n的序列，X最多只有包含其中的前n - 1个字符</span><br>    num_examples = (<span class="hljs-built_in">len</span>(corpus_indices) - <span class="hljs-number">1</span>) // num_steps  <span class="hljs-comment"># 下取整，得到不重叠情况下的样本个数</span><br>    example_indices = [i * num_steps <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_examples)]  <span class="hljs-comment"># 每个样本的第一个字符在corpus_indices中的下标</span><br>    random.shuffle(example_indices)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_data</span>(<span class="hljs-params">i</span>):<br>        <span class="hljs-comment"># 返回从i开始的长为num_steps的序列</span><br>        <span class="hljs-keyword">return</span> corpus_indices[i: i + num_steps]<br>    <span class="hljs-keyword">if</span> device <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_examples, batch_size):<br>        <span class="hljs-comment"># 每次选出batch_size个随机样本</span><br>        batch_indices = example_indices[i: i + batch_size]  <span class="hljs-comment"># 当前batch的各个样本的首字符的下标</span><br>        X = [_data(j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> batch_indices]<br>        Y = [_data(j + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> batch_indices]<br>        <span class="hljs-keyword">yield</span> torch.tensor(X, device=device), torch.tensor(Y, device=device)<br></code></pre></td></tr></table></figure><p>测试一下这个函数，我们输入从0到29的连续整数作为一个人工序列，设批量大小和时间步数分别为2和6，打印随机采样每次读取的小批量样本的输入<code>X</code>和标签<code>Y</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_seq = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>))<br><span class="hljs-keyword">for</span> X, Y <span class="hljs-keyword">in</span> data_iter_random(my_seq, batch_size=<span class="hljs-number">2</span>, num_steps=<span class="hljs-number">6</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;X: &#x27;</span>, X, <span class="hljs-string">&#x27;\nY:&#x27;</span>, Y, <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">X:  tensor([[ 6,  7,  8,  9, 10, 11],        [12, 13, 14, 15, 16, 17]]) Y: tensor([[ 7,  8,  9, 10, 11, 12],        [13, 14, 15, 16, 17, 18]]) X:  tensor([[ 0,  1,  2,  3,  4,  5],        [18, 19, 20, 21, 22, 23]]) Y: tensor([[ 1,  2,  3,  4,  5,  6],        [19, 20, 21, 22, 23, 24]]) </code></pre><h3 id="相邻采样">相邻采样</h3><p>在相邻采样中，相邻的两个随机小批量在原始序列上的位置相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter_consecutive</span>(<span class="hljs-params">corpus_indices, batch_size, num_steps, device=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> device <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br>    corpus_len = <span class="hljs-built_in">len</span>(corpus_indices) // batch_size * batch_size  <span class="hljs-comment"># 保留下来的序列的长度</span><br>    corpus_indices = corpus_indices[: corpus_len]  <span class="hljs-comment"># 仅保留前corpus_len个字符</span><br>    indices = torch.tensor(corpus_indices, device=device)<br>    indices = indices.view(batch_size, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># resize成(batch_size, )</span><br>    batch_num = (indices.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) // num_steps<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(batch_num):<br>        i = i * num_steps<br>        X = indices[:, i: i + num_steps]<br>        Y = indices[:, i + <span class="hljs-number">1</span>: i + num_steps + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">yield</span> X, Y<br></code></pre></td></tr></table></figure><p>同样的设置下，打印相邻采样每次读取的小批量样本的输入<code>X</code>和标签<code>Y</code>。相邻的两个随机小批量在原始序列上的位置相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> X, Y <span class="hljs-keyword">in</span> data_iter_consecutive(my_seq, batch_size=<span class="hljs-number">2</span>, num_steps=<span class="hljs-number">6</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;X: &#x27;</span>, X, <span class="hljs-string">&#x27;\nY:&#x27;</span>, Y, <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">X:  tensor([[ 0,  1,  2,  3,  4,  5],        [15, 16, 17, 18, 19, 20]]) Y: tensor([[ 1,  2,  3,  4,  5,  6],        [16, 17, 18, 19, 20, 21]]) X:  tensor([[ 6,  7,  8,  9, 10, 11],        [21, 22, 23, 24, 25, 26]]) Y: tensor([[ 7,  8,  9, 10, 11, 12],        [22, 23, 24, 25, 26, 27]]) </code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>DL</category>
      
      <category>PyTorch</category>
      
      <category>NLP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dive into DL: Multilayer Perceptron</title>
    <link href="/2020/02/14/Dive%20into%20DL-Multilayer%20Perceptron/"/>
    <url>/2020/02/14/Dive%20into%20DL-Multilayer%20Perceptron/</url>
    
    <content type="html"><![CDATA[<h2 id="多层感知机">多层感知机</h2><ol type="1"><li>多层感知机的基本知识</li><li>使用多层感知机图像分类的从零开始的实现</li><li>使用pytorch的简洁实现</li></ol><h2 id="多层感知机的基本知识">多层感知机的基本知识</h2><p>深度学习主要关注多层模型。在这里，我们将以多层感知机（multilayer perceptron，MLP）为例，介绍多层神经网络的概念。</p><h3 id="隐藏层">隐藏层</h3><p>下图展示了一个多层感知机的神经网络图，它含有一个隐藏层，该层中有5个隐藏单元。</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ua2VzY2kuY29tL3VwbG9hZC9pbWFnZS9xNWhvNjg0am1oLnBuZw?x-oss-process=image/format,png" alt="Image Name" /><figcaption>Image Name</figcaption></figure><h3 id="表达公式">表达公式</h3><p>具体来说，给定一个小批量样本<span class="math inline">\(\boldsymbol{X} \in \mathbb{R}^{n \times d}\)</span>，其批量大小为<span class="math inline">\(n\)</span>，输入个数为<span class="math inline">\(d\)</span>。假设多层感知机只有一个隐藏层，其中隐藏单元个数为<span class="math inline">\(h\)</span>。记隐藏层的输出（也称为隐藏层变量或隐藏变量）为<span class="math inline">\(\boldsymbol{H}\)</span>，有<span class="math inline">\(\boldsymbol{H} \in \mathbb{R}^{n \times h}\)</span>。因为隐藏层和输出层均是全连接层，可以设隐藏层的权重参数和偏差参数分别为<span class="math inline">\(\boldsymbol{W}_h \in \mathbb{R}^{d \times h}\)</span>和 <span class="math inline">\(\boldsymbol{b}_h \in \mathbb{R}^{1 \times h}\)</span>，输出层的权重和偏差参数分别为<span class="math inline">\(\boldsymbol{W}_o \in \mathbb{R}^{h \times q}\)</span>和<span class="math inline">\(\boldsymbol{b}_o \in \mathbb{R}^{1 \times q}\)</span>。</p><p>我们先来看一种含单隐藏层的多层感知机的设计。其输出<span class="math inline">\(\boldsymbol{O} \in \mathbb{R}^{n \times q}\)</span>的计算为</p><p><span class="math display">\[ \begin{aligned} \boldsymbol{H} &amp;= \boldsymbol{X} \boldsymbol{W}_h + \boldsymbol{b}_h,\\ \boldsymbol{O} &amp;= \boldsymbol{H} \boldsymbol{W}_o + \boldsymbol{b}_o, \end{aligned}\]</span></p><p>也就是将隐藏层的输出直接作为输出层的输入。如果将以上两个式子联立起来，可以得到</p><p><span class="math display">\[ \boldsymbol{O} = (\boldsymbol{X} \boldsymbol{W}_h + \boldsymbol{b}_h)\boldsymbol{W}_o + \boldsymbol{b}_o = \boldsymbol{X} \boldsymbol{W}_h\boldsymbol{W}_o + \boldsymbol{b}_h \boldsymbol{W}_o + \boldsymbol{b}_o. \]</span></p><p>从联立后的式子可以看出，虽然神经网络引入了隐藏层，却依然等价于一个单层神经网络：其中输出层权重参数为<span class="math inline">\(\boldsymbol{W}_h\boldsymbol{W}_o\)</span>，偏差参数为<span class="math inline">\(\boldsymbol{b}_h \boldsymbol{W}_o + \boldsymbol{b}_o\)</span>。不难发现，即便再添加更多的隐藏层，以上设计依然只能与仅含输出层的单层神经网络等价。</p><h3 id="激活函数">激活函数</h3><p>上述问题的根源在于全连接层只是对数据做仿射变换（affine transformation），而多个仿射变换的叠加仍然是一个仿射变换。解决问题的一个方法是引入非线性变换，例如对隐藏变量使用按元素运算的非线性函数进行变换，然后再作为下一个全连接层的输入。这个非线性函数被称为激活函数（activation function）。</p><p>下面我们介绍几个常用的激活函数：</p><h4 id="relu函数">ReLU函数</h4><p>ReLU（rectified linear unit）函数提供了一个很简单的非线性变换。给定元素<span class="math inline">\(x\)</span>，该函数定义为</p><p><span class="math display">\[\text{ReLU}(x) = \max(x, 0).\]</span></p><p>可以看出，ReLU函数只保留正数元素，并将负数元素清零。为了直观地观察这一非线性变换，我们先定义一个绘图函数xyplot。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&quot;/home/kesci/input&quot;</span>)<br><span class="hljs-keyword">import</span> d2lzh1981 <span class="hljs-keyword">as</span> d2l<br><span class="hljs-built_in">print</span>(torch.__version__)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.3.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">xyplot</span>(<span class="hljs-params">x_vals, y_vals, name</span>):<br>    <span class="hljs-comment"># d2l.set_figsize(figsize=(5, 2.5))</span><br>    plt.plot(x_vals.detach().numpy(), y_vals.detach().numpy())<br>    plt.xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    plt.ylabel(name + <span class="hljs-string">&#x27;(x)&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.arange(-<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span>, <span class="hljs-number">0.1</span>, requires_grad=<span class="hljs-literal">True</span>)<br>y = x.relu()<br>xyplot(x, y, <span class="hljs-string">&#x27;relu&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.kesci.com/rt_upload/070825B6A382411DA5BD7D14E67E8D54/q5hv7cdtna.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y.<span class="hljs-built_in">sum</span>().backward()<br>xyplot(x, x.grad, <span class="hljs-string">&#x27;grad of relu&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.kesci.com/rt_upload/BFB05150DBD1474D9A9ECCB9CDF1DD39/q5hv7c3pxb.png"></p><h4 id="sigmoid函数">Sigmoid函数</h4><p>sigmoid函数可以将元素的值变换到0和1之间：</p><p><span class="math display">\[\text{sigmoid}(x) = \frac{1}{1 + \exp(-x)}.\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y = x.sigmoid()<br>xyplot(x, y, <span class="hljs-string">&#x27;sigmoid&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.kesci.com/rt_upload/68FCB4E8142144458F13128B370D1C91/q5hv7dor11.png"></p><p>依据链式法则，sigmoid函数的导数</p><p><span class="math display">\[\text{sigmoid}&#39;(x) = \text{sigmoid}(x)\left(1-\text{sigmoid}(x)\right).\]</span></p><p>下面绘制了sigmoid函数的导数。当输入为0时，sigmoid函数的导数达到最大值0.25；当输入越偏离0时，sigmoid函数的导数越接近0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x.grad.zero_()<br>y.<span class="hljs-built_in">sum</span>().backward()<br>xyplot(x, x.grad, <span class="hljs-string">&#x27;grad of sigmoid&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.kesci.com/rt_upload/878C7B8823304F72860965E119A21412/q5hv7dpse9.png"></p><h4 id="tanh函数">tanh函数</h4><p>tanh（双曲正切）函数可以将元素的值变换到-1和1之间：</p><p><span class="math display">\[\text{tanh}(x) = \frac{1 - \exp(-2x)}{1 + \exp(-2x)}.\]</span></p><p>我们接着绘制tanh函数。当输入接近0时，tanh函数接近线性变换。虽然该函数的形状和sigmoid函数的形状很像，但tanh函数在坐标系的原点上对称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y = x.tanh()<br>xyplot(x, y, <span class="hljs-string">&#x27;tanh&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.kesci.com/rt_upload/92D16076309F42169482834C0B6ABB24/q5hv7dfeso.png"></p><p>依据链式法则，tanh函数的导数</p><p><span class="math display">\[\text{tanh}&#39;(x) = 1 - \text{tanh}^2(x).\]</span></p><p>下面绘制了tanh函数的导数。当输入为0时，tanh函数的导数达到最大值1；当输入越偏离0时，tanh函数的导数越接近0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x.grad.zero_()<br>y.<span class="hljs-built_in">sum</span>().backward()<br>xyplot(x, x.grad, <span class="hljs-string">&#x27;grad of tanh&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.kesci.com/rt_upload/CB16F4B33E664E14BCE8E52D8B37C47F/q5hv7ejc8y.png"></p><h3 id="关于激活函数的选择">关于激活函数的选择</h3><p>ReLu函数是一个通用的激活函数，目前在大多数情况下使用。但是，ReLU函数只能在隐藏层中使用。</p><p>用于分类器时，sigmoid函数及其组合通常效果更好。由于梯度消失问题，有时要避免使用sigmoid和tanh函数。</p><p>在神经网络层数较多的时候，最好使用ReLu函数，ReLu函数比较简单计算量少，而sigmoid和tanh函数计算量大很多。</p><p>在选择激活函数的时候可以先选用ReLu函数如果效果不理想可以尝试其他激活函数。</p><h3 id="多层感知机-1">多层感知机</h3><p>多层感知机就是含有至少一个隐藏层的由全连接层组成的神经网络，且每个隐藏层的输出通过激活函数进行变换。多层感知机的层数和各隐藏层中隐藏单元个数都是超参数。以单隐藏层为例并沿用本节之前定义的符号，多层感知机按以下方式计算输出：</p><p><span class="math display">\[ \begin{aligned} \boldsymbol{H} &amp;= \phi(\boldsymbol{X} \boldsymbol{W}_h + \boldsymbol{b}_h),\\ \boldsymbol{O} &amp;= \boldsymbol{H} \boldsymbol{W}_o + \boldsymbol{b}_o, \end{aligned} \]</span></p><p>其中<span class="math inline">\(\phi\)</span>表示激活函数。</p><h2 id="多层感知机从零开始的实现">多层感知机从零开始的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&quot;..&quot;</span>) <br><span class="hljs-keyword">import</span> d2lzh_pytorch <span class="hljs-keyword">as</span> d2l<br><span class="hljs-built_in">print</span>(torch.__version__)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.4.0+cpu</code></pre><h3 id="获取训练集">获取训练集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">256</span><br>train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size,root=<span class="hljs-string">&#x27;./input/FashionMNIST2065&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="定义模型参数">定义模型参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">num_inputs, num_outputs, num_hiddens = <span class="hljs-number">784</span>, <span class="hljs-number">10</span>, <span class="hljs-number">256</span><br><br>W1 = torch.tensor(np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, (num_inputs, num_hiddens)), dtype=torch.<span class="hljs-built_in">float</span>)<br>b1 = torch.zeros(num_hiddens, dtype=torch.<span class="hljs-built_in">float</span>)<br>W2 = torch.tensor(np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, (num_hiddens, num_outputs)), dtype=torch.<span class="hljs-built_in">float</span>)<br>b2 = torch.zeros(num_outputs, dtype=torch.<span class="hljs-built_in">float</span>)<br><br>params = [W1, b1, W2, b2]<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>    param.requires_grad_(requires_grad=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="定义激活函数">定义激活函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">relu</span>(<span class="hljs-params">X</span>):<br>    <span class="hljs-keyword">return</span> torch.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">input</span>=X, other=torch.tensor(<span class="hljs-number">0.0</span>))<br></code></pre></td></tr></table></figure><h3 id="定义网络">定义网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">net</span>(<span class="hljs-params">X</span>):<br>    X = X.view((-<span class="hljs-number">1</span>, num_inputs))<br>    H = relu(torch.matmul(X, W1) + b1)<br>    <span class="hljs-keyword">return</span> torch.matmul(H, W2) + b2<br></code></pre></td></tr></table></figure><h3 id="定义损失函数">定义损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">loss = torch.nn.CrossEntropyLoss()<br></code></pre></td></tr></table></figure><h3 id="训练">训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs, lr = <span class="hljs-number">5</span>, <span class="hljs-number">100.0</span><br><span class="hljs-comment"># def train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size,</span><br><span class="hljs-comment">#               params=None, lr=None, optimizer=None):</span><br><span class="hljs-comment">#     for epoch in range(num_epochs):</span><br><span class="hljs-comment">#         train_l_sum, train_acc_sum, n = 0.0, 0.0, 0</span><br><span class="hljs-comment">#         for X, y in train_iter:</span><br><span class="hljs-comment">#             y_hat = net(X)</span><br><span class="hljs-comment">#             l = loss(y_hat, y).sum()</span><br><span class="hljs-comment">#             </span><br><span class="hljs-comment">#             # 梯度清零</span><br><span class="hljs-comment">#             if optimizer is not None:</span><br><span class="hljs-comment">#                 optimizer.zero_grad()</span><br><span class="hljs-comment">#             elif params is not None and params[0].grad is not None:</span><br><span class="hljs-comment">#                 for param in params:</span><br><span class="hljs-comment">#                     param.grad.data.zero_()</span><br><span class="hljs-comment">#            </span><br><span class="hljs-comment">#             l.backward()</span><br><span class="hljs-comment">#             if optimizer is None:</span><br><span class="hljs-comment">#                 d2l.sgd(params, lr, batch_size)</span><br><span class="hljs-comment">#             else:</span><br><span class="hljs-comment">#                 optimizer.step()  # “softmax回归的简洁实现”一节将用到</span><br><span class="hljs-comment">#             </span><br><span class="hljs-comment">#             </span><br><span class="hljs-comment">#             train_l_sum += l.item()</span><br><span class="hljs-comment">#             train_acc_sum += (y_hat.argmax(dim=1) == y).sum().item()</span><br><span class="hljs-comment">#             n += y.shape[0]</span><br><span class="hljs-comment">#         test_acc = evaluate_accuracy(test_iter, net)</span><br><span class="hljs-comment">#         print(&#x27;epoch %d, loss %.4f, train acc %.3f, test acc %.3f&#x27;</span><br><span class="hljs-comment">#               % (epoch + 1, train_l_sum / n, train_acc_sum / n, test_acc))</span><br><br>d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size, params, lr)<br></code></pre></td></tr></table></figure><pre><code class="hljs">epoch 1, loss 0.0030, train acc 0.713, test acc 0.774epoch 2, loss 0.0019, train acc 0.823, test acc 0.800epoch 3, loss 0.0017, train acc 0.845, test acc 0.838epoch 4, loss 0.0015, train acc 0.856, test acc 0.850epoch 5, loss 0.0014, train acc 0.865, test acc 0.849</code></pre><h2 id="多层感知机pytorch实现">多层感知机pytorch实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> init<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&quot;..&quot;</span>) <br><span class="hljs-keyword">import</span> d2lzh_pytorch <span class="hljs-keyword">as</span> d2l<br><br><span class="hljs-built_in">print</span>(torch.__version__)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.4.0+cpu</code></pre><h3 id="初始化模型和各个参数">初始化模型和各个参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">num_inputs, num_outputs, num_hiddens = <span class="hljs-number">784</span>, <span class="hljs-number">10</span>, <span class="hljs-number">256</span><br>    <br>net = nn.Sequential(<br>        d2l.FlattenLayer(),<br>        nn.Linear(num_inputs, num_hiddens),<br>        nn.ReLU(),<br>        nn.Linear(num_hiddens, num_outputs), <br>        )<br>    <br><span class="hljs-keyword">for</span> params <span class="hljs-keyword">in</span> net.parameters():<br>    init.normal_(params, mean=<span class="hljs-number">0</span>, std=<span class="hljs-number">0.01</span>)<br></code></pre></td></tr></table></figure><h3 id="训练-1">训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">256</span><br>train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size,root=<span class="hljs-string">&#x27;/home/kesci/input/FashionMNIST2065&#x27;</span>)<br>loss = torch.nn.CrossEntropyLoss()<br><br>optimizer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.5</span>)<br><br>num_epochs = <span class="hljs-number">5</span><br>d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, optimizer)<br></code></pre></td></tr></table></figure><pre><code class="hljs">epoch 1, loss 0.0032, train acc 0.696, test acc 0.683epoch 2, loss 0.0019, train acc 0.818, test acc 0.707epoch 3, loss 0.0017, train acc 0.841, test acc 0.817epoch 4, loss 0.0015, train acc 0.854, test acc 0.843epoch 5, loss 0.0015, train acc 0.864, test acc 0.855</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>DL</category>
      
      <category>PyTorch</category>
      
      <category>CV</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dive into DL: Recurrent Neural Network</title>
    <link href="/2020/02/14/Dive%20into%20DL-Recurrent%20Neural%20Network/"/>
    <url>/2020/02/14/Dive%20into%20DL-Recurrent%20Neural%20Network/</url>
    
    <content type="html"><![CDATA[<h1 id="循环神经网络">循环神经网络</h1><p>本节介绍循环神经网络，下图展示了如何基于循环神经网络实现语言模型。我们的目的是基于当前的输入与过去的输入序列，预测序列的下一个字符。循环神经网络引入一个隐藏变量<span class="math inline">\(H\)</span>，用<span class="math inline">\(H_{t}\)</span>表示<span class="math inline">\(H\)</span>在时间步<span class="math inline">\(t\)</span>的值。<span class="math inline">\(H_{t}\)</span>的计算基于<span class="math inline">\(X_{t}\)</span>和<span class="math inline">\(H_{t-1}\)</span>，可以认为<span class="math inline">\(H_{t}\)</span>记录了到当前字符为止的序列信息，利用<span class="math inline">\(H_{t}\)</span>对序列的下一个字符进行预测。 <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ua2VzY2kuY29tL3VwbG9hZC9pbWFnZS9xNWprbTB2NDRpLnBuZw?x-oss-process=image/format,png" alt="Image Name" /></p><h2 id="循环神经网络的构造">循环神经网络的构造</h2><p>我们先看循环神经网络的具体构造。假设<span class="math inline">\(\boldsymbol{X}_t \in \mathbb{R}^{n \times d}\)</span>是时间步<span class="math inline">\(t\)</span>的小批量输入，<span class="math inline">\(\boldsymbol{H}_t \in \mathbb{R}^{n \times h}\)</span>是该时间步的隐藏变量，则：</p><p><span class="math display">\[\boldsymbol{H}_t = \phi(\boldsymbol{X}_t \boldsymbol{W}_{xh} + \boldsymbol{H}_{t-1} \boldsymbol{W}_{hh}  + \boldsymbol{b}_h).\]</span></p><p>其中，<span class="math inline">\(\boldsymbol{W}_{xh} \in \mathbb{R}^{d \times h}\)</span>，<span class="math inline">\(\boldsymbol{W}_{hh} \in \mathbb{R}^{h \times h}\)</span>，<span class="math inline">\(\boldsymbol{b}_{h} \in \mathbb{R}^{1 \times h}\)</span>，<span class="math inline">\(\phi\)</span>函数是非线性激活函数。由于引入了<span class="math inline">\(\boldsymbol{H}_{t-1} \boldsymbol{W}_{hh}\)</span>，<span class="math inline">\(H_{t}\)</span>能够捕捉截至当前时间步的序列的历史信息，就像是神经网络当前时间步的状态或记忆一样。由于<span class="math inline">\(H_{t}\)</span>的计算基于<span class="math inline">\(H_{t-1}\)</span>，上式的计算是循环的，使用循环计算的网络即循环神经网络（recurrent neural network）。</p><p>在时间步<span class="math inline">\(t\)</span>，输出层的输出为：</p><p><span class="math display">\[\boldsymbol{O}_t = \boldsymbol{H}_t \boldsymbol{W}_{hq} + \boldsymbol{b}_q.\]</span></p><p>其中<span class="math inline">\(\boldsymbol{W}_{hq} \in \mathbb{R}^{h \times q}\)</span>，<span class="math inline">\(\boldsymbol{b}_q \in \mathbb{R}^{1 \times q}\)</span>。</p><h2 id="从零开始实现循环神经网络">从零开始实现循环神经网络</h2><p>我们先尝试从零开始实现一个基于字符级循环神经网络的语言模型，这里我们使用周杰伦的歌词作为语料，首先我们读入数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&quot;/home/kesci/input&quot;</span>)<br><span class="hljs-keyword">import</span> d2l_jay9460 <span class="hljs-keyword">as</span> d2l<br>(corpus_indices, char_to_idx, idx_to_char, vocab_size) = d2l.load_data_jay_lyrics()<br>device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="one-hot向量">one-hot向量</h3><p>我们需要将字符表示成向量，这里采用one-hot向量。假设词典大小是<span class="math inline">\(N\)</span>，每次字符对应一个从<span class="math inline">\(0\)</span>到<span class="math inline">\(N-1\)</span>的唯一的索引，则该字符的向量是一个长度为<span class="math inline">\(N\)</span>的向量，若字符的索引是<span class="math inline">\(i\)</span>，则该向量的第<span class="math inline">\(i\)</span>个位置为<span class="math inline">\(1\)</span>，其他位置为<span class="math inline">\(0\)</span>。下面分别展示了索引为0和2的one-hot向量，向量长度等于词典大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">one_hot</span>(<span class="hljs-params">x, n_class, dtype=torch.float32</span>):<br>    result = torch.zeros(x.shape[<span class="hljs-number">0</span>], n_class, dtype=dtype, device=x.device)  <span class="hljs-comment"># shape: (n, n_class)</span><br>    result.scatter_(<span class="hljs-number">1</span>, x.long().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-number">1</span>)  <span class="hljs-comment"># result[i, x[i, 0]] = 1</span><br>    <span class="hljs-keyword">return</span> result<br>    <br>x = torch.tensor([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>])<br>x_one_hot = one_hot(x, vocab_size)<br><span class="hljs-built_in">print</span>(x_one_hot)<br><span class="hljs-built_in">print</span>(x_one_hot.shape)<br><span class="hljs-built_in">print</span>(x_one_hot.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">tensor([[1., 0., 0.,  ..., 0., 0., 0.],        [0., 0., 1.,  ..., 0., 0., 0.]])torch.Size([2, 1027])tensor([1., 1.])</code></pre><p>我们每次采样的小批量的形状是（批量大小, 时间步数）。下面的函数将这样的小批量变换成数个形状为（批量大小, 词典大小）的矩阵，矩阵个数等于时间步数。也就是说，时间步<span class="math inline">\(t\)</span>的输入为<span class="math inline">\(\boldsymbol{X}_t \in \mathbb{R}^{n \times d}\)</span>，其中<span class="math inline">\(n\)</span>为批量大小，<span class="math inline">\(d\)</span>为词向量大小，即one-hot向量长度（词典大小）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">to_onehot</span>(<span class="hljs-params">X, n_class</span>):<br>    <span class="hljs-keyword">return</span> [one_hot(X[:, i], n_class) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">1</span>])]<br><br>X = torch.arange(<span class="hljs-number">10</span>).view(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br>inputs = to_onehot(X, vocab_size)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(inputs), inputs[<span class="hljs-number">0</span>].shape)<br></code></pre></td></tr></table></figure><pre><code class="hljs">5 torch.Size([2, 1027])</code></pre><h3 id="初始化模型参数">初始化模型参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">num_inputs, num_hiddens, num_outputs = vocab_size, <span class="hljs-number">256</span>, vocab_size<br><span class="hljs-comment"># num_inputs: d</span><br><span class="hljs-comment"># num_hiddens: h, 隐藏单元的个数是超参数</span><br><span class="hljs-comment"># num_outputs: q</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_params</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_one</span>(<span class="hljs-params">shape</span>):<br>        param = torch.zeros(shape, device=device, dtype=torch.float32)<br>        nn.init.normal_(param, <span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<br>        <span class="hljs-keyword">return</span> torch.nn.Parameter(param)<br><br>    <span class="hljs-comment"># 隐藏层参数</span><br>    W_xh = _one((num_inputs, num_hiddens))<br>    W_hh = _one((num_hiddens, num_hiddens))<br>    b_h = torch.nn.Parameter(torch.zeros(num_hiddens, device=device))<br>    <span class="hljs-comment"># 输出层参数</span><br>    W_hq = _one((num_hiddens, num_outputs))<br>    b_q = torch.nn.Parameter(torch.zeros(num_outputs, device=device))<br>    <span class="hljs-keyword">return</span> (W_xh, W_hh, b_h, W_hq, b_q)<br></code></pre></td></tr></table></figure><h3 id="定义模型">定义模型</h3><p>函数<code>rnn</code>用循环的方式依次完成循环神经网络每个时间步的计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rnn</span>(<span class="hljs-params">inputs, state, params</span>):<br>    <span class="hljs-comment"># inputs和outputs皆为num_steps个形状为(batch_size, vocab_size)的矩阵</span><br>    W_xh, W_hh, b_h, W_hq, b_q = params<br>    H, = state<br>    <span class="hljs-built_in">print</span>(H)<br>    outputs = []<br>    <span class="hljs-keyword">for</span> X <span class="hljs-keyword">in</span> inputs:<br>        H = torch.tanh(torch.matmul(X, W_xh) + torch.matmul(H, W_hh) + b_h)<br>        Y = torch.matmul(H, W_hq) + b_q<br>        outputs.append(Y)<br>    <span class="hljs-keyword">return</span> outputs, (H,)<br></code></pre></td></tr></table></figure><p>函数init_rnn_state初始化隐藏变量，这里的返回值是一个元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_rnn_state</span>(<span class="hljs-params">batch_size, num_hiddens, device</span>):<br>    <span class="hljs-keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device), )<br></code></pre></td></tr></table></figure><p>做个简单的测试来观察输出结果的个数（时间步数），以及第一个时间步的输出层输出的形状和隐藏状态的形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(X.shape)<br><span class="hljs-built_in">print</span>(num_hiddens)<br><span class="hljs-built_in">print</span>(vocab_size)<br>state = init_rnn_state(X.shape[<span class="hljs-number">0</span>], num_hiddens, device)<br>inputs = to_onehot(X.to(device), vocab_size)<br>params = get_params()<br>outputs, state_new = rnn(inputs, state, params)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(inputs), inputs[<span class="hljs-number">0</span>].shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(outputs), outputs[<span class="hljs-number">0</span>].shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(state), state[<span class="hljs-number">0</span>].shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(state_new), state_new[<span class="hljs-number">0</span>].shape)<br>h,  = state<br>h<br></code></pre></td></tr></table></figure><pre><code class="hljs">torch.Size([2, 5])25610275 torch.Size([2, 1027])5 torch.Size([2, 1027])1 torch.Size([2, 256])1 torch.Size([2, 256])tensor([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])</code></pre><h3 id="裁剪梯度">裁剪梯度</h3><p>循环神经网络中较容易出现梯度衰减或梯度爆炸，这会导致网络几乎无法训练。裁剪梯度（clip gradient）是一种应对梯度爆炸的方法。假设我们把所有模型参数的梯度拼接成一个向量 <span class="math inline">\(\boldsymbol{g}\)</span>，并设裁剪的阈值是<span class="math inline">\(\theta\)</span>。裁剪后的梯度</p><p><span class="math display">\[ \min\left(\frac{\theta}{\|\boldsymbol{g}\|}, 1\right)\boldsymbol{g}\]</span></p><p>的<span class="math inline">\(L_2\)</span>范数不超过<span class="math inline">\(\theta\)</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">grad_clipping</span>(<span class="hljs-params">params, theta, device</span>):<br>    norm = torch.tensor([<span class="hljs-number">0.0</span>], device=device)<br>    <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>        norm += (param.grad.data ** <span class="hljs-number">2</span>).<span class="hljs-built_in">sum</span>()<br>    norm = norm.sqrt().item()<br>    <span class="hljs-keyword">if</span> norm &gt; theta:<br>        <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>            param.grad.data *= (theta / norm)<br></code></pre></td></tr></table></figure><h3 id="定义预测函数">定义预测函数</h3><p>以下函数基于前缀<code>prefix</code>（含有数个字符的字符串）来预测接下来的<code>num_chars</code>个字符。这个函数稍显复杂，其中我们将循环神经单元<code>rnn</code>设置成了函数参数，这样在后面小节介绍其他循环神经网络时能重复使用这个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_rnn</span>(<span class="hljs-params">prefix, num_chars, rnn, params, init_rnn_state,</span><br><span class="hljs-params">                num_hiddens, vocab_size, device, idx_to_char, char_to_idx</span>):<br>    state = init_rnn_state(<span class="hljs-number">1</span>, num_hiddens, device)<br>    output = [char_to_idx[prefix[<span class="hljs-number">0</span>]]]   <span class="hljs-comment"># output记录prefix加上预测的num_chars个字符</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_chars + <span class="hljs-built_in">len</span>(prefix) - <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 将上一时间步的输出作为当前时间步的输入</span><br>        X = to_onehot(torch.tensor([[output[-<span class="hljs-number">1</span>]]], device=device), vocab_size)<br>        <span class="hljs-comment"># 计算输出和更新隐藏状态</span><br>        (Y, state) = rnn(X, state, params)<br>        <span class="hljs-comment"># 下一个时间步的输入是prefix里的字符或者当前的最佳预测字符</span><br>        <span class="hljs-keyword">if</span> t &lt; <span class="hljs-built_in">len</span>(prefix) - <span class="hljs-number">1</span>:<br>            output.append(char_to_idx[prefix[t + <span class="hljs-number">1</span>]])<br>        <span class="hljs-keyword">else</span>:<br>            output.append(Y[<span class="hljs-number">0</span>].argmax(dim=<span class="hljs-number">1</span>).item())<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join([idx_to_char[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> output])<br></code></pre></td></tr></table></figure><p>我们先测试一下<code>predict_rnn</code>函数。我们将根据前缀“分开”创作长度为10个字符（不考虑前缀长度）的一段歌词。因为模型参数为随机值，所以预测结果也是随机的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">predict_rnn(<span class="hljs-string">&#x27;分开&#x27;</span>, <span class="hljs-number">10</span>, rnn, params, init_rnn_state, num_hiddens, vocab_size,<br>            device, idx_to_char, char_to_idx)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;分开那太风怪每捏岩弥漫护&#39;</code></pre><h3 id="困惑度">困惑度</h3><p>我们通常使用困惑度（perplexity）来评价语言模型的好坏。回忆一下<a href="../chapter_deep-learning-basics/softmax-regression.ipynb">“softmax回归”</a>一节中交叉熵损失函数的定义。困惑度是对交叉熵损失函数做指数运算后得到的值。特别地，</p><ul><li>最佳情况下，模型总是把标签类别的概率预测为1，此时困惑度为1；</li><li>最坏情况下，模型总是把标签类别的概率预测为0，此时困惑度为正无穷；</li><li>基线情况下，模型总是预测所有类别的概率都相同，此时困惑度为类别个数。</li></ul><p>显然，任何一个有效模型的困惑度必须小于类别个数。在本例中，困惑度必须小于词典大小<code>vocab_size</code>。</p><h3 id="定义模型训练函数">定义模型训练函数</h3><p>跟之前章节的模型训练函数相比，这里的模型训练函数有以下几点不同：</p><ol type="1"><li>使用困惑度评价模型。</li><li>在迭代模型参数前裁剪梯度。</li><li>对时序数据采用不同采样方法将导致隐藏状态初始化的不同。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_and_predict_rnn</span>(<span class="hljs-params">rnn, get_params, init_rnn_state, num_hiddens,</span><br><span class="hljs-params">                          vocab_size, device, corpus_indices, idx_to_char,</span><br><span class="hljs-params">                          char_to_idx, is_random_iter, num_epochs, num_steps,</span><br><span class="hljs-params">                          lr, clipping_theta, batch_size, pred_period,</span><br><span class="hljs-params">                          pred_len, prefixes</span>):<br>    <span class="hljs-keyword">if</span> is_random_iter:<br>        data_iter_fn = d2l.data_iter_random<br>    <span class="hljs-keyword">else</span>:<br>        data_iter_fn = d2l.data_iter_consecutive<br>    params = get_params()<br>    loss = nn.CrossEntropyLoss()<br><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_random_iter:  <span class="hljs-comment"># 如使用相邻采样，在epoch开始时初始化隐藏状态</span><br>            state = init_rnn_state(batch_size, num_hiddens, device)<br>        l_sum, n, start = <span class="hljs-number">0.0</span>, <span class="hljs-number">0</span>, time.time()<br>        data_iter = data_iter_fn(corpus_indices, batch_size, num_steps, device)<br>        <span class="hljs-keyword">for</span> X, Y <span class="hljs-keyword">in</span> data_iter:<br>            <span class="hljs-keyword">if</span> is_random_iter:  <span class="hljs-comment"># 如使用随机采样，在每个小批量更新前初始化隐藏状态</span><br>                state = init_rnn_state(batch_size, num_hiddens, device)<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 否则需要使用detach函数从计算图分离隐藏状态</span><br>                <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> state:<br>                    s.detach_()<br>            <span class="hljs-comment"># inputs是num_steps个形状为(batch_size, vocab_size)的矩阵</span><br>            inputs = to_onehot(X, vocab_size)<br>            <span class="hljs-comment"># outputs有num_steps个形状为(batch_size, vocab_size)的矩阵</span><br>            (outputs, state) = rnn(inputs, state, params)<br>            <span class="hljs-comment"># 拼接之后形状为(num_steps * batch_size, vocab_size)</span><br>            outputs = torch.cat(outputs, dim=<span class="hljs-number">0</span>)<br>            <span class="hljs-comment"># Y的形状是(batch_size, num_steps)，转置后再变成形状为</span><br>            <span class="hljs-comment"># (num_steps * batch_size,)的向量，这样跟输出的行一一对应</span><br>            y = torch.flatten(Y.T)<br>            <span class="hljs-comment"># 使用交叉熵损失计算平均分类误差</span><br>            l = loss(outputs, y.long())<br>            <br>            <span class="hljs-comment"># 梯度清0</span><br>            <span class="hljs-keyword">if</span> params[<span class="hljs-number">0</span>].grad <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>                    param.grad.data.zero_()<br>            l.backward()<br>            grad_clipping(params, clipping_theta, device)  <span class="hljs-comment"># 裁剪梯度</span><br>            d2l.sgd(params, lr, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 因为误差已经取过均值，梯度不用再做平均</span><br>            l_sum += l.item() * y.shape[<span class="hljs-number">0</span>]<br>            n += y.shape[<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">if</span> (epoch + <span class="hljs-number">1</span>) % pred_period == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;epoch %d, perplexity %f, time %.2f sec&#x27;</span> % (<br>                epoch + <span class="hljs-number">1</span>, math.exp(l_sum / n), time.time() - start))<br>            <span class="hljs-keyword">for</span> prefix <span class="hljs-keyword">in</span> prefixes:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; -&#x27;</span>, predict_rnn(prefix, pred_len, rnn, params, init_rnn_state,<br>                    num_hiddens, vocab_size, device, idx_to_char, char_to_idx))<br></code></pre></td></tr></table></figure><h3 id="训练模型并创作歌词">训练模型并创作歌词</h3><p>现在我们可以训练模型了。首先，设置模型超参数。我们将根据前缀“分开”和“不分开”分别创作长度为50个字符（不考虑前缀长度）的一段歌词。我们每过50个迭代周期便根据当前训练的模型创作一段歌词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs, num_steps, batch_size, lr, clipping_theta = <span class="hljs-number">250</span>, <span class="hljs-number">35</span>, <span class="hljs-number">32</span>, <span class="hljs-number">1e2</span>, <span class="hljs-number">1e-2</span><br>pred_period, pred_len, prefixes = <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, [<span class="hljs-string">&#x27;分开&#x27;</span>, <span class="hljs-string">&#x27;不分开&#x27;</span>]<br></code></pre></td></tr></table></figure><p>下面采用随机采样训练模型并创作歌词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_and_predict_rnn(rnn, get_params, init_rnn_state, num_hiddens,<br>                      vocab_size, device, corpus_indices, idx_to_char,<br>                      char_to_idx, <span class="hljs-literal">True</span>, num_epochs, num_steps, lr,<br>                      clipping_theta, batch_size, pred_period, pred_len,<br>                      prefixes)<br></code></pre></td></tr></table></figure><pre><code class="hljs">epoch 50, perplexity 65.808092, time 0.78 sec - 分开 我想要这样 我不要再想 我不要再想 我不要再想 我不要再想 我不要再想 我不要再想 我不要再想 我 - 不分开 别颗去 一颗两 三颗四 一颗四 三颗四 一颗四 一颗四 一颗四 一颗四 一颗四 一颗四 一颗四 一epoch 100, perplexity 9.794889, time 0.72 sec - 分开 一直在美留 谁在它停 在小村外的溪边 默默等  什么 旧你在依旧 我有儿有些瘦 世色我遇见你是一场 - 不分开吗 我不能再想 我不 我不 我不 我不 我不 我不 我不 我不 我不 我不 我不 我不 我不 我不 epoch 150, perplexity 2.772557, time 0.80 sec - 分开 有直在不妥 有话它停留 蜥蝪横怕落 不爽就 旧怪堂 是属于依 心故之 的片段 有一些风霜 老唱盘  - 不分开吗 然后将过不 我慢 失些  如  静里回的太快 想通 却又再考倒我 说散 你想很久了吧?的我 从等epoch 200, perplexity 1.601744, time 0.73 sec - 分开 那只都它满在我面妈 捏成你的形状啸而过 或愿说在后能 让梭时忆对着轻轻 我想就这样牵着你的手不放开 - 不分开期 然后将过去 慢慢温习 让我爱上你 那场悲剧 是你完美演出的一场戏 宁愿心碎哭泣 再狠狠忘记 不是epoch 250, perplexity 1.323342, time 0.78 sec - 分开 出愿段的哭咒的天蛦丘好落 拜托当血穿永杨一定的诗篇 我给你的爱写在西元前 深埋在美索不达米亚平原  - 不分开扫把的胖女巫 用拉丁文念咒语啦啦呜 她养的黑猫笑起来像哭 啦啦啦呜 我来了我 在我感外的溪边河口默默</code></pre><p>接下来采用相邻采样训练模型并创作歌词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_and_predict_rnn(rnn, get_params, init_rnn_state, num_hiddens,<br>                      vocab_size, device, corpus_indices, idx_to_char,<br>                      char_to_idx, <span class="hljs-literal">False</span>, num_epochs, num_steps, lr,<br>                      clipping_theta, batch_size, pred_period, pred_len,<br>                      prefixes)<br></code></pre></td></tr></table></figure><pre><code class="hljs">epoch 50, perplexity 60.294393, time 0.74 sec - 分开 我想要你想 我不要再想 我不要再想 我不要再想 我不要再想 我不要再想 我不要再想 我不要再想 我 - 不分开 我想要你 你有了 别不我的可爱女人 坏坏的让我疯狂的可爱女人 坏坏的让我疯狂的可爱女人 坏坏的让我epoch 100, perplexity 7.141162, time 0.72 sec - 分开 我已要再爱 我不要再想 我不 我不 我不要再想 我不 我不 我不要 爱情我的见快就像龙卷风 离能开 - 不分开柳 你天黄一个棍 后知哈兮 快使用双截棍 哼哼哈兮 快使用双截棍 哼哼哈兮 快使用双截棍 哼哼哈兮 epoch 150, perplexity 2.090277, time 0.73 sec - 分开 我已要这是你在著 不想我都做得到 但那个人已经不是我 没有你在 我却多难熬  没有你在我有多难熬多 - 不分开觉 你已经离 我想再好 这样心中 我一定带我 我的完空 不你是风 一一彩纵 在人心中 我一定带我妈走epoch 200, perplexity 1.305391, time 0.77 sec - 分开 我已要这样牵看你的手 它一定实现它一定像现 载著你 彷彿载著阳光 不管到你留都是晴天 蝴蝶自在飞力 - 不分开觉 你已经离开我 不知不觉 我跟了这节奏 后知后觉 又过了一个秋 后知后觉 我该好好生活 我该好好生epoch 250, perplexity 1.230800, time 0.79 sec - 分开 我不要 是你看的太快了悲慢 担心今手身会大早 其么我也睡不着  昨晚梦里你来找 我才  原来我只想 - 不分开觉 你在经离开我 不知不觉 你知了有节奏 后知后觉 后知了一个秋 后知后觉 我该好好生活 我该好好生</code></pre><h2 id="循环神经网络的简介实现">循环神经网络的简介实现</h2><h3 id="定义模型-1">定义模型</h3><p>我们使用Pytorch中的<code>nn.RNN</code>来构造循环神经网络。在本节中，我们主要关注<code>nn.RNN</code>的以下几个构造函数参数：</p><ul><li><code>input_size</code> - The number of expected features in the input x</li><li><code>hidden_size</code> – The number of features in the hidden state h</li><li><code>nonlinearity</code> – The non-linearity to use. Can be either 'tanh' or 'relu'. Default: 'tanh'</li><li><code>batch_first</code> – If True, then the input and output tensors are provided as (batch_size, num_steps, input_size). Default: False</li></ul><p>这里的<code>batch_first</code>决定了输入的形状，我们使用默认的参数<code>False</code>，对应的输入形状是 (num_steps, batch_size, input_size)。</p><p><code>forward</code>函数的参数为：</p><ul><li><code>input</code> of shape (num_steps, batch_size, input_size): tensor containing the features of the input sequence.</li><li><code>h_0</code> of shape (num_layers * num_directions, batch_size, hidden_size): tensor containing the initial hidden state for each element in the batch. Defaults to zero if not provided. If the RNN is bidirectional, num_directions should be 2, else it should be 1.</li></ul><p><code>forward</code>函数的返回值是：</p><ul><li><code>output</code> of shape (num_steps, batch_size, num_directions * hidden_size): tensor containing the output features (h_t) from the last layer of the RNN, for each t.</li><li><code>h_n</code> of shape (num_layers * num_directions, batch_size, hidden_size): tensor containing the hidden state for t = num_steps.</li></ul><p>现在我们构造一个<code>nn.RNN</code>实例，并用一个简单的例子来看一下输出的形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">rnn_layer = nn.RNN(input_size=vocab_size, hidden_size=num_hiddens)<br>num_steps, batch_size = <span class="hljs-number">35</span>, <span class="hljs-number">2</span><br>X = torch.rand(num_steps, batch_size, vocab_size)<br>state = <span class="hljs-literal">None</span><br>Y, state_new = rnn_layer(X, state)<br><span class="hljs-built_in">print</span>(Y.shape, state_new.shape)<br></code></pre></td></tr></table></figure><pre><code class="hljs">torch.Size([35, 2, 256]) torch.Size([1, 2, 256])</code></pre><p>我们定义一个完整的基于循环神经网络的语言模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RNNModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, rnn_layer, vocab_size</span>):<br>        <span class="hljs-built_in">super</span>(RNNModel, self).__init__()<br>        self.rnn = rnn_layer<br>        self.hidden_size = rnn_layer.hidden_size * (<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> rnn_layer.bidirectional <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>) <br>        self.vocab_size = vocab_size<br>        self.dense = nn.Linear(self.hidden_size, vocab_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, inputs, state</span>):<br>        <span class="hljs-comment"># inputs.shape: (batch_size, num_steps)</span><br>        X = to_onehot(inputs, vocab_size)<br>        X = torch.stack(X)  <span class="hljs-comment"># X.shape: (num_steps, batch_size, vocab_size)</span><br>        hiddens, state = self.rnn(X, state)<br>        hiddens = hiddens.view(-<span class="hljs-number">1</span>, hiddens.shape[-<span class="hljs-number">1</span>])  <span class="hljs-comment"># hiddens.shape: (num_steps * batch_size, hidden_size)</span><br>        output = self.dense(hiddens)<br>        <span class="hljs-keyword">return</span> output, state<br></code></pre></td></tr></table></figure><p>类似的，我们需要实现一个预测函数，与前面的区别在于前向计算和初始化隐藏状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_rnn_pytorch</span>(<span class="hljs-params">prefix, num_chars, model, vocab_size, device, idx_to_char,</span><br><span class="hljs-params">                      char_to_idx</span>):<br>    state = <span class="hljs-literal">None</span><br>    output = [char_to_idx[prefix[<span class="hljs-number">0</span>]]]  <span class="hljs-comment"># output记录prefix加上预测的num_chars个字符</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_chars + <span class="hljs-built_in">len</span>(prefix) - <span class="hljs-number">1</span>):<br>        X = torch.tensor([output[-<span class="hljs-number">1</span>]], device=device).view(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        (Y, state) = model(X, state)  <span class="hljs-comment"># 前向计算不需要传入模型参数</span><br>        <span class="hljs-keyword">if</span> t &lt; <span class="hljs-built_in">len</span>(prefix) - <span class="hljs-number">1</span>:<br>            output.append(char_to_idx[prefix[t + <span class="hljs-number">1</span>]])<br>        <span class="hljs-keyword">else</span>:<br>            output.append(Y.argmax(dim=<span class="hljs-number">1</span>).item())<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join([idx_to_char[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> output])<br></code></pre></td></tr></table></figure><p>使用权重为随机值的模型来预测一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model = RNNModel(rnn_layer, vocab_size).to(device)<br>predict_rnn_pytorch(<span class="hljs-string">&#x27;分开&#x27;</span>, <span class="hljs-number">10</span>, model, vocab_size, device, idx_to_char, char_to_idx)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;分开胸呵以轮轮轮轮轮轮轮&#39;</code></pre><p>接下来实现训练函数，这里只使用了相邻采样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_and_predict_rnn_pytorch</span>(<span class="hljs-params">model, num_hiddens, vocab_size, device,</span><br><span class="hljs-params">                                corpus_indices, idx_to_char, char_to_idx,</span><br><span class="hljs-params">                                num_epochs, num_steps, lr, clipping_theta,</span><br><span class="hljs-params">                                batch_size, pred_period, pred_len, prefixes</span>):<br>    loss = nn.CrossEntropyLoss()<br>    optimizer = torch.optim.Adam(model.parameters(), lr=lr)<br>    model.to(device)<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>        l_sum, n, start = <span class="hljs-number">0.0</span>, <span class="hljs-number">0</span>, time.time()<br>        data_iter = d2l.data_iter_consecutive(corpus_indices, batch_size, num_steps, device) <span class="hljs-comment"># 相邻采样</span><br>        state = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">for</span> X, Y <span class="hljs-keyword">in</span> data_iter:<br>            <span class="hljs-keyword">if</span> state <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-comment"># 使用detach函数从计算图分离隐藏状态</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span> (state, <span class="hljs-built_in">tuple</span>): <span class="hljs-comment"># LSTM, state:(h, c)  </span><br>                    state[<span class="hljs-number">0</span>].detach_()<br>                    state[<span class="hljs-number">1</span>].detach_()<br>                <span class="hljs-keyword">else</span>: <br>                    state.detach_()<br>            (output, state) = model(X, state) <span class="hljs-comment"># output.shape: (num_steps * batch_size, vocab_size)</span><br>            y = torch.flatten(Y.T)<br>            l = loss(output, y.long())<br>            <br>            optimizer.zero_grad()<br>            l.backward()<br>            grad_clipping(model.parameters(), clipping_theta, device)<br>            optimizer.step()<br>            l_sum += l.item() * y.shape[<span class="hljs-number">0</span>]<br>            n += y.shape[<span class="hljs-number">0</span>]<br>        <br><br>        <span class="hljs-keyword">if</span> (epoch + <span class="hljs-number">1</span>) % pred_period == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;epoch %d, perplexity %f, time %.2f sec&#x27;</span> % (<br>                epoch + <span class="hljs-number">1</span>, math.exp(l_sum / n), time.time() - start))<br>            <span class="hljs-keyword">for</span> prefix <span class="hljs-keyword">in</span> prefixes:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; -&#x27;</span>, predict_rnn_pytorch(<br>                    prefix, pred_len, model, vocab_size, device, idx_to_char,<br>                    char_to_idx))<br></code></pre></td></tr></table></figure><p>训练模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs, batch_size, lr, clipping_theta = <span class="hljs-number">250</span>, <span class="hljs-number">32</span>, <span class="hljs-number">1e-3</span>, <span class="hljs-number">1e-2</span><br>pred_period, pred_len, prefixes = <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, [<span class="hljs-string">&#x27;分开&#x27;</span>, <span class="hljs-string">&#x27;不分开&#x27;</span>]<br>train_and_predict_rnn_pytorch(model, num_hiddens, vocab_size, device,<br>                            corpus_indices, idx_to_char, char_to_idx,<br>                            num_epochs, num_steps, lr, clipping_theta,<br>                            batch_size, pred_period, pred_len, prefixes)<br></code></pre></td></tr></table></figure><pre><code class="hljs">epoch 50, perplexity 9.405654, time 0.52 sec - 分开始一起 三步四步望著天 看星星 一颗两颗三颗四颗 连成线背著背默默许下心愿  一枝杨柳 你的那我 在 - 不分开 爱情你的手 一人的老斑鸠 腿短毛不多 快使用双截棍 哼哼哈兮 快使用双截棍 哼哼哈兮 快使用双截棍epoch 100, perplexity 1.255020, time 0.54 sec - 分开 我人了的屋我 一定令它心仪的母斑鸠 爱像一阵风 吹完美主  这样 还人的太快就是学怕眼口让我碰恨这 - 不分开不想我多的脑袋有问题 随便说说 其实我早已经猜透看透不想多说 只是我怕眼泪撑不住 不懂 你的黑色幽默epoch 150, perplexity 1.064527, time 0.53 sec - 分开 我轻外的溪边 默默在一心抽离 有话不知不觉 一场悲剧 我对不起 藤蔓植物的爬满了伯爵的坟墓 古堡里 - 不分开不想不多的脑 有教堂有你笑 我有多烦恼  没有你烦 有有样 别怪走 快后悔没说你 我不多难熬 我想就epoch 200, perplexity 1.033074, time 0.53 sec - 分开 我轻外的溪边 默默在一心向昏 的愿  古无着我只能 一个黑远 这想太久 这样我 不要再是你打我妈妈 - 不分开你只会我一起睡著 样 娘子却只想你和汉堡 我想要你的微笑每天都能看到  我知道这里很美但家乡的你更美epoch 250, perplexity 1.047890, time 0.68 sec - 分开 我轻多的漫 却已在你人演  想要再直你 我想要这样牵着你的手不放开 爱可不可以简简单单没有伤害 你 - 不分开不想不多的假  已无能为力再提起 决定中断熟悉 然后在这里 不限日期 然后将过去 慢慢温习 让我爱上</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>DL</category>
      
      <category>PyTorch</category>
      
      <category>NLP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dive into DL: Softmax Classification</title>
    <link href="/2020/02/14/Dive%20into%20DL-Softmax%20Classification/"/>
    <url>/2020/02/14/Dive%20into%20DL-Softmax%20Classification/</url>
    
    <content type="html"><![CDATA[<h1 id="softmax和分类模型">softmax和分类模型</h1><p>内容包含： 1. softmax回归的基本概念 2. 如何获取Fashion-MNIST数据集和读取数据 3. softmax回归模型的从零开始实现，实现一个对Fashion-MNIST训练集中的图像数据进行分类的模型 4. 使用pytorch重新实现softmax回归模型</p><h2 id="softmax的基本概念">softmax的基本概念</h2><ul><li><p>分类问题<br />一个简单的图像分类问题，输入图像的高和宽均为2像素，色彩为灰度。<br />图像中的4像素分别记为<span class="math inline">\(x_1, x_2, x_3, x_4\)</span>。<br />假设真实标签为狗、猫或者鸡，这些标签对应的离散值为<span class="math inline">\(y_1, y_2, y_3\)</span>。<br />我们通常使用离散的数值来表示类别，例如<span class="math inline">\(y_1=1, y_2=2, y_3=3\)</span>。</p></li><li><p>权重矢量<br /><span class="math display">\[ \begin{aligned} o_1 &amp;= x_1 w_{11} + x_2 w_{21} + x_3 w_{31} + x_4 w_{41} + b_1 \end{aligned} \]</span></p></li></ul><p><span class="math display">\[ \begin{aligned} o_2 &amp;= x_1 w_{12} + x_2 w_{22} + x_3 w_{32} + x_4 w_{42} + b_2 \end{aligned} \]</span></p><p><span class="math display">\[ \begin{aligned} o_3 &amp;= x_1 w_{13} + x_2 w_{23} + x_3 w_{33} + x_4 w_{43} + b_3 \end{aligned} \]</span></p><ul><li>神经网络图<br />下图用神经网络图描绘了上面的计算。softmax回归同线性回归一样，也是一个单层神经网络。由于每个输出<span class="math inline">\(o_1, o_2, o_3\)</span>的计算都要依赖于所有的输入<span class="math inline">\(x_1, x_2, x_3, x_4\)</span>，softmax回归的输出层也是一个全连接层。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ua2VzY2kuY29tL3VwbG9hZC9pbWFnZS9xNWhteW1lem9nLnBuZw?x-oss-process=image/format,png" /></p><p><span class="math display">\[\begin{aligned}softmax回归是一个单层神经网络\end{aligned}\]</span></p><p>既然分类问题需要得到离散的预测输出，一个简单的办法是将输出值<span class="math inline">\(o_i\)</span>当作预测类别是<span class="math inline">\(i\)</span>的置信度，并将值最大的输出所对应的类作为预测输出，即输出 <span class="math inline">\(\underset{i}{\arg\max} o_i\)</span>。例如，如果<span class="math inline">\(o_1,o_2,o_3\)</span>分别为<span class="math inline">\(0.1,10,0.1\)</span>，由于<span class="math inline">\(o_2\)</span>最大，那么预测类别为2，其代表猫。</p><ul><li>输出问题<br />直接使用输出层的输出有两个问题：<ol type="1"><li>一方面，由于输出层的输出值的范围不确定，我们难以直观上判断这些值的意义。例如，刚才举的例子中的输出值10表示“很置信”图像类别为猫，因为该输出值是其他两类的输出值的100倍。但如果<span class="math inline">\(o_1=o_3=10^3\)</span>，那么输出值10却又表示图像类别为猫的概率很低。</li><li>另一方面，由于真实标签是离散值，这些离散值与不确定范围的输出值之间的误差难以衡量。</li></ol></li></ul><p>softmax运算符（softmax operator）解决了以上两个问题。它通过下式将输出值变换成值为正且和为1的概率分布：</p><p><span class="math display">\[ \hat{y}_1, \hat{y}_2, \hat{y}_3 = \text{softmax}(o_1, o_2, o_3) \]</span></p><p>其中</p><p><span class="math display">\[ \hat{y}1 = \frac{ \exp(o_1)}{\sum_{i=1}^3 \exp(o_i)},\quad \hat{y}2 = \frac{ \exp(o_2)}{\sum_{i=1}^3 \exp(o_i)},\quad \hat{y}3 = \frac{ \exp(o_3)}{\sum_{i=1}^3 \exp(o_i)}. \]</span></p><p>容易看出<span class="math inline">\(\hat{y}_1 + \hat{y}_2 + \hat{y}_3 = 1\)</span>且<span class="math inline">\(0 \leq \hat{y}_1, \hat{y}_2, \hat{y}_3 \leq 1\)</span>，因此<span class="math inline">\(\hat{y}_1, \hat{y}_2, \hat{y}_3\)</span>是一个合法的概率分布。这时候，如果<span class="math inline">\(\hat{y}_2=0.8\)</span>，不管<span class="math inline">\(\hat{y}_1\)</span>和<span class="math inline">\(\hat{y}_3\)</span>的值是多少，我们都知道图像类别为猫的概率是80%。此外，我们注意到</p><p><span class="math display">\[ \underset{i}{\arg\max} o_i = \underset{i}{\arg\max} \hat{y}_i \]</span></p><p>因此softmax运算不改变预测类别输出。</p><ul><li>计算效率<ul><li>单样本矢量计算表达式<br />为了提高计算效率，我们可以将单样本分类通过矢量计算来表达。在上面的图像分类问题中，假设softmax回归的权重和偏差参数分别为</li></ul></li></ul><p><span class="math display">\[ \boldsymbol{W} = \begin{bmatrix} w_{11} &amp; w_{12} &amp; w_{13} \\ w_{21} &amp; w_{22} &amp; w_{23} \\ w_{31} &amp; w_{32} &amp; w_{33} \\ w_{41} &amp; w_{42} &amp; w_{43} \end{bmatrix},\quad \boldsymbol{b} = \begin{bmatrix} b_1 &amp; b_2 &amp; b_3 \end{bmatrix}, \]</span></p><p>设高和宽分别为2个像素的图像样本<span class="math inline">\(i\)</span>的特征为</p><p><span class="math display">\[\boldsymbol{x}^{(i)} = \begin{bmatrix}x_1^{(i)} &amp; x_2^{(i)} &amp; x_3^{(i)} &amp; x_4^{(i)}\end{bmatrix},\]</span></p><p>输出层的输出为</p><p><span class="math display">\[\boldsymbol{o}^{(i)} = \begin{bmatrix}o_1^{(i)} &amp; o_2^{(i)} &amp; o_3^{(i)}\end{bmatrix},\]</span></p><p>预测为狗、猫或鸡的概率分布为</p><p><span class="math display">\[\boldsymbol{\hat{y}}^{(i)} = \begin{bmatrix}\hat{y}_1^{(i)} &amp; \hat{y}_2^{(i)} &amp; \hat{y}_3^{(i)}\end{bmatrix}.\]</span></p><p>softmax回归对样本<span class="math inline">\(i\)</span>分类的矢量计算表达式为</p><p><span class="math display">\[ \begin{aligned} \boldsymbol{o}^{(i)} &amp;= \boldsymbol{x}^{(i)} \boldsymbol{W} + \boldsymbol{b},\\ \boldsymbol{\hat{y}}^{(i)} &amp;= \text{softmax}(\boldsymbol{o}^{(i)}). \end{aligned} \]</span></p><ul><li>小批量矢量计算表达式<br />为了进一步提升计算效率，我们通常对小批量数据做矢量计算。广义上讲，给定一个小批量样本，其批量大小为<span class="math inline">\(n\)</span>，输入个数（特征数）为<span class="math inline">\(d\)</span>，输出个数（类别数）为<span class="math inline">\(q\)</span>。设批量特征为<span class="math inline">\(\boldsymbol{X} \in \mathbb{R}^{n \times d}\)</span>。假设softmax回归的权重和偏差参数分别为<span class="math inline">\(\boldsymbol{W} \in \mathbb{R}^{d \times q}\)</span>和<span class="math inline">\(\boldsymbol{b} \in \mathbb{R}^{1 \times q}\)</span>。softmax回归的矢量计算表达式为</li></ul><p><span class="math display">\[ \begin{aligned} \boldsymbol{O} &amp;= \boldsymbol{X} \boldsymbol{W} + \boldsymbol{b},\\ \boldsymbol{\hat{Y}} &amp;= \text{softmax}(\boldsymbol{O}), \end{aligned} \]</span></p><p>其中的加法运算使用了广播机制，<span class="math inline">\(\boldsymbol{O}, \boldsymbol{\hat{Y}} \in \mathbb{R}^{n \times q}\)</span>且这两个矩阵的第<span class="math inline">\(i\)</span>行分别为样本<span class="math inline">\(i\)</span>的输出<span class="math inline">\(\boldsymbol{o}^{(i)}\)</span>和概率分布<span class="math inline">\(\boldsymbol{\hat{y}}^{(i)}\)</span>。</p><h2 id="交叉熵损失函数">交叉熵损失函数</h2><p>对于样本<span class="math inline">\(i\)</span>，我们构造向量<span class="math inline">\(\boldsymbol{y}^{(i)}\in \mathbb{R}^{q}\)</span> ，使其第<span class="math inline">\(y^{(i)}\)</span>（样本<span class="math inline">\(i\)</span>类别的离散数值）个元素为1，其余为0。这样我们的训练目标可以设为使预测概率分布<span class="math inline">\(\boldsymbol{\hat y}^{(i)}\)</span>尽可能接近真实的标签概率分布<span class="math inline">\(\boldsymbol{y}^{(i)}\)</span>。</p><ul><li>平方损失估计</li></ul><p><span class="math display">\[\begin{aligned}Loss = |\boldsymbol{\hat y}^{(i)}-\boldsymbol{y}^{(i)}|^2/2\end{aligned}\]</span></p><p>然而，想要预测分类结果正确，我们其实并不需要预测概率完全等于标签概率。例如，在图像分类的例子里，如果<span class="math inline">\(y^{(i)}=3\)</span>，那么我们只需要<span class="math inline">\(\hat{y}^{(i)}_3\)</span>比其他两个预测值<span class="math inline">\(\hat{y}^{(i)}_1\)</span>和<span class="math inline">\(\hat{y}^{(i)}_2\)</span>大就行了。即使<span class="math inline">\(\hat{y}^{(i)}_3\)</span>值为0.6，不管其他两个预测值为多少，类别预测均正确。而平方损失则过于严格，例如<span class="math inline">\(\hat y^{(i)}_1=\hat y^{(i)}_2=0.2\)</span>比<span class="math inline">\(\hat y^{(i)}_1=0, \hat y^{(i)}_2=0.4\)</span>的损失要小很多，虽然两者都有同样正确的分类预测结果。</p><p>改善上述问题的一个方法是使用更适合衡量两个概率分布差异的测量函数。其中，交叉熵（cross entropy）是一个常用的衡量方法：</p><p><span class="math display">\[H\left(\boldsymbol y^{(i)}, \boldsymbol {\hat y}^{(i)}\right ) = -\sum_{j=1}^q y_j^{(i)} \log \hat y_j^{(i)},\]</span></p><p>其中带下标的<span class="math inline">\(y_j^{(i)}\)</span>是向量<span class="math inline">\(\boldsymbol y^{(i)}\)</span>中非0即1的元素，需要注意将它与样本<span class="math inline">\(i\)</span>类别的离散数值，即不带下标的<span class="math inline">\(y^{(i)}\)</span>区分。在上式中，我们知道向量<span class="math inline">\(\boldsymbol y^{(i)}\)</span>中只有第<span class="math inline">\(y^{(i)}\)</span>个元素<span class="math inline">\(y^{(i)}{y^{(i)}}\)</span>为1，其余全为0，于是<span class="math inline">\(H(\boldsymbol y^{(i)}, \boldsymbol {\hat y}^{(i)}) = -\log \hat y_{y^{(i)}}^{(i)}\)</span>。也就是说，交叉熵只关心对正确类别的预测概率，因为只要其值足够大，就可以确保分类结果正确。当然，遇到一个样本有多个标签时，例如图像里含有不止一个物体时，我们并不能做这一步简化。但即便对于这种情况，交叉熵同样只关心对图像中出现的物体类别的预测概率。</p><p>假设训练数据集的样本数为<span class="math inline">\(n\)</span>，交叉熵损失函数定义为 <span class="math display">\[\ell(\boldsymbol{\Theta}) = \frac{1}{n} \sum_{i=1}^n H\left(\boldsymbol y^{(i)}, \boldsymbol {\hat y}^{(i)}\right ),\]</span></p><p>其中<span class="math inline">\(\boldsymbol{\Theta}\)</span>代表模型参数。同样地，如果每个样本只有一个标签，那么交叉熵损失可以简写成<span class="math inline">\(\ell(\boldsymbol{\Theta}) = -(1/n) \sum_{i=1}^n \log \hat y_{y^{(i)}}^{(i)}\)</span>。从另一个角度来看，我们知道最小化<span class="math inline">\(\ell(\boldsymbol{\Theta})\)</span>等价于最大化<span class="math inline">\(\exp(-n\ell(\boldsymbol{\Theta}))=\prod_{i=1}^n \hat y_{y^{(i)}}^{(i)}\)</span>，即最小化交叉熵损失函数等价于最大化训练数据集所有标签类别的联合预测概率。</p><h2 id="模型训练和预测">模型训练和预测</h2><p>在训练好softmax回归模型后，给定任一样本特征，就可以预测每个输出类别的概率。通常，我们把预测概率最大的类别作为输出类别。如果它与真实类别（标签）一致，说明这次预测是正确的。在3.6节的实验中，我们将使用准确率（accuracy）来评价模型的表现。它等于正确预测数量与总预测数量之比。</p><h1 id="获取fashion-mnist训练集和读取数据">获取Fashion-MNIST训练集和读取数据</h1><p>在介绍softmax回归的实现前我们先引入一个多类图像分类数据集。它将在后面的章节中被多次使用，以方便我们观察比较算法之间在模型精度和计算效率上的区别。图像分类数据集中最常用的是手写数字识别数据集MNIST[1]。但大部分模型在MNIST上的分类精度都超过了95%。为了更直观地观察算法之间的差异，我们将使用一个图像内容更加复杂的数据集Fashion-MNIST[2]。</p><p>我这里我们会使用torchvision包，它是服务于PyTorch深度学习框架的，主要用来构建计算机视觉模型。torchvision主要由以下几部分构成： 1. torchvision.datasets: 一些加载数据的函数及常用的数据集接口； 2. torchvision.models: 包含常用的模型结构（含预训练模型），例如AlexNet、VGG、ResNet等； 3. torchvision.transforms: 常用的图片变换，例如裁剪、旋转等； 4. torchvision.utils: 其他的一些有用的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># import needed package</span><br>%matplotlib inline<br><span class="hljs-keyword">from</span> IPython <span class="hljs-keyword">import</span> display<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&quot;..&quot;</span>) <br><span class="hljs-keyword">import</span> d2lzh_pytorch <span class="hljs-keyword">as</span> d2l<br><br><span class="hljs-built_in">print</span>(torch.__version__)<br><span class="hljs-built_in">print</span>(torchvision.__version__)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.4.0+cpu0.5.0+cpu</code></pre><h2 id="get-dataset">get dataset</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">mnist_train = torchvision.datasets.FashionMNIST(root=<span class="hljs-string">&#x27;./input/FashionMNIST2065&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br>mnist_test = torchvision.datasets.FashionMNIST(root=<span class="hljs-string">&#x27;./input/FashionMNIST2065&#x27;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br></code></pre></td></tr></table></figure><p>class torchvision.datasets.FashionMNIST(root, train=True, transform=None, target_transform=None, download=False) - root（string）– 数据集的根目录，其中存放processed/training.pt和processed/test.pt文件。 - train（bool, 可选）– 如果设置为True，从training.pt创建数据集，否则从test.pt创建。 - download（bool, 可选）– 如果设置为True，从互联网下载数据并放到root文件夹下。如果root目录下已经存在数据，不会再次下载。 - transform（可被调用 , 可选）– 一种函数或变换，输入PIL图片，返回变换之后的数据。如：transforms.RandomCrop。 - target_transform（可被调用 , 可选）– 一种函数或变换，输入目标，进行变换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># show result </span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(mnist_train))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(mnist_train), <span class="hljs-built_in">len</span>(mnist_test))<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;torchvision.datasets.mnist.FashionMNIST&#39;&gt;60000 10000</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 我们可以通过下标来访问任意一个样本</span><br>feature, label = mnist_train[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(feature.shape, label)  <span class="hljs-comment"># Channel x Height x Width</span><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">torch.Size([1, 28, 28]) 9</code></pre><p>如果不做变换输入的数据是图像，我们可以看一下图片的类型参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">mnist_PIL = torchvision.datasets.FashionMNIST(root=<span class="hljs-string">&#x27;/home/kesci/input/FashionMNIST2065&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>)<br>PIL_feature, label = mnist_PIL[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(PIL_feature)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;PIL.Image.Image image mode=L size=28x28 at 0x2C0A7BB9488&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 本函数已保存在d2lzh包中方便以后使用</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_fashion_mnist_labels</span>(<span class="hljs-params">labels</span>):<br>    text_labels = [<span class="hljs-string">&#x27;t-shirt&#x27;</span>, <span class="hljs-string">&#x27;trouser&#x27;</span>, <span class="hljs-string">&#x27;pullover&#x27;</span>, <span class="hljs-string">&#x27;dress&#x27;</span>, <span class="hljs-string">&#x27;coat&#x27;</span>,<br>                   <span class="hljs-string">&#x27;sandal&#x27;</span>, <span class="hljs-string">&#x27;shirt&#x27;</span>, <span class="hljs-string">&#x27;sneaker&#x27;</span>, <span class="hljs-string">&#x27;bag&#x27;</span>, <span class="hljs-string">&#x27;ankle boot&#x27;</span>]<br>    <span class="hljs-keyword">return</span> [text_labels[<span class="hljs-built_in">int</span>(i)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> labels]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_fashion_mnist</span>(<span class="hljs-params">images, labels</span>):<br>    d2l.use_svg_display()<br>    <span class="hljs-comment"># 这里的_表示我们忽略（不使用）的变量</span><br>    _, figs = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(images), figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">12</span>))<br>    <span class="hljs-keyword">for</span> f, img, lbl <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(figs, images, labels):<br>        f.imshow(img.view((<span class="hljs-number">28</span>, <span class="hljs-number">28</span>)).numpy())<br>        f.set_title(lbl)<br>        f.axes.get_xaxis().set_visible(<span class="hljs-literal">False</span>)<br>        f.axes.get_yaxis().set_visible(<span class="hljs-literal">False</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X, y = [], []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    X.append(mnist_train[i][<span class="hljs-number">0</span>]) <span class="hljs-comment"># 将第i个feature加到X中</span><br>    y.append(mnist_train[i][<span class="hljs-number">1</span>]) <span class="hljs-comment"># 将第i个label加到y中</span><br>show_fashion_mnist(X, get_fashion_mnist_labels(y))<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200214205226660.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取数据</span><br>batch_size = <span class="hljs-number">256</span><br>num_workers = <span class="hljs-number">4</span><br>train_iter = torch.utils.data.DataLoader(mnist_train, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>, num_workers=num_workers)<br>test_iter = torch.utils.data.DataLoader(mnist_test, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>, num_workers=num_workers)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">start = time.time()<br><span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> train_iter:<br>    <span class="hljs-keyword">continue</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%.2f sec&#x27;</span> % (time.time() - start))<br></code></pre></td></tr></table></figure><pre><code class="hljs">4.64 sec</code></pre><h1 id="softmax从零开始的实现">softmax从零开始的实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&quot;..&quot;</span>) <br><span class="hljs-keyword">import</span> d2lzh_pytorch <span class="hljs-keyword">as</span> d2l<br><br><span class="hljs-built_in">print</span>(torch.__version__)<br><span class="hljs-built_in">print</span>(torchvision.__version__)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.4.0+cpu0.5.0+cpu</code></pre><h2 id="获取训练集数据和测试集数据">获取训练集数据和测试集数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">256</span><br>train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, root=<span class="hljs-string">&#x27;/home/kesci/input/FashionMNIST2065&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="模型参数初始化">模型参数初始化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">num_inputs = <span class="hljs-number">784</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">28</span>*<span class="hljs-number">28</span>)<br>num_outputs = <span class="hljs-number">10</span><br><br>W = torch.tensor(np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, (num_inputs, num_outputs)), dtype=torch.<span class="hljs-built_in">float</span>)<br>b = torch.zeros(num_outputs, dtype=torch.<span class="hljs-built_in">float</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">784</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">W.requires_grad_(requires_grad=<span class="hljs-literal">True</span>)<br>b.requires_grad_(requires_grad=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], requires_grad=True)</code></pre><h2 id="对多维tensor按维度操作">对多维Tensor按维度操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(X.<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">0</span>, keepdim=<span class="hljs-literal">True</span>))  <span class="hljs-comment"># dim为0，按照相同的列求和，并在结果中保留列特征</span><br><span class="hljs-built_in">print</span>(X.<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>))  <span class="hljs-comment"># dim为1，按照相同的行求和，并在结果中保留行特征</span><br><span class="hljs-built_in">print</span>(X.<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">0</span>, keepdim=<span class="hljs-literal">False</span>)) <span class="hljs-comment"># dim为0，按照相同的列求和，不在结果中保留列特征</span><br><span class="hljs-built_in">print</span>(X.<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">False</span>)) <span class="hljs-comment"># dim为1，按照相同的行求和，不在结果中保留行特征</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">tensor([[5, 7, 9]])tensor([[ 6],        [15]])tensor([5, 7, 9])tensor([ 6, 15])</code></pre><h2 id="定义softmax操作">定义softmax操作</h2><p><span class="math display">\[ \hat{y}_j = \frac{ \exp(o_j)}{\sum_{i=1}^3 \exp(o_i)} \]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax</span>(<span class="hljs-params">X</span>):<br>    X_exp = X.exp()<br>    partition = X_exp.<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># print(&quot;X size is &quot;, X_exp.size())</span><br>    <span class="hljs-comment"># print(&quot;partition size is &quot;, partition, partition.size())</span><br>    <span class="hljs-keyword">return</span> X_exp / partition  <span class="hljs-comment"># 这里应用了广播机制</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">X = torch.rand((<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))<br>X_prob = softmax(X)<br><span class="hljs-built_in">print</span>(X_prob, <span class="hljs-string">&#x27;\n&#x27;</span>, X_prob.<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">tensor([[0.1880, 0.1848, 0.2668, 0.2236, 0.1368],        [0.2251, 0.1077, 0.1563, 0.2466, 0.2644]])  tensor([1.0000, 1.0000])</code></pre><h2 id="softmax回归模型">softmax回归模型</h2><p><span class="math display">\[ \begin{aligned} \boldsymbol{o}^{(i)} &amp;= \boldsymbol{x}^{(i)} \boldsymbol{W} + \boldsymbol{b},\\ \boldsymbol{\hat{y}}^{(i)} &amp;= \text{softmax}(\boldsymbol{o}^{(i)}). \end{aligned} \]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">net</span>(<span class="hljs-params">X</span>):<br>    <span class="hljs-keyword">return</span> softmax(torch.mm(X.view((-<span class="hljs-number">1</span>, num_inputs)), W) + b)<br></code></pre></td></tr></table></figure><h2 id="定义损失函数">定义损失函数</h2><p><span class="math display">\[H\left(\boldsymbol y^{(i)}, \boldsymbol {\hat y}^{(i)}\right ) = -\sum_{j=1}^q y_j^{(i)} \log \hat y_j^{(i)},\]</span></p><p><span class="math display">\[\ell(\boldsymbol{\Theta}) = \frac{1}{n} \sum_{i=1}^n H\left(\boldsymbol y^{(i)}, \boldsymbol {\hat y}^{(i)}\right ),\]</span></p><p><span class="math display">\[\ell(\boldsymbol{\Theta}) = -(1/n) \sum_{i=1}^n \log \hat y_{y^{(i)}}^{(i)}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">y_hat = torch.tensor([[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.6</span>], [<span class="hljs-number">0.3</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.5</span>]])<br>y = torch.LongTensor([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>])<br>y_hat.gather(<span class="hljs-number">1</span>, y.view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">tensor([[0.1000],        [0.5000]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_entropy</span>(<span class="hljs-params">y_hat, y</span>):<br>    <span class="hljs-keyword">return</span> - torch.log(y_hat.gather(<span class="hljs-number">1</span>, y.view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><h2 id="定义准确率">定义准确率</h2><p>我们模型训练完了进行模型预测的时候，会用到我们这里定义的准确率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy</span>(<span class="hljs-params">y_hat, y</span>):<br>    <span class="hljs-keyword">return</span> (y_hat.argmax(dim=<span class="hljs-number">1</span>) == y).<span class="hljs-built_in">float</span>().mean().item()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(accuracy(y_hat, y))<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.5</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 本函数已保存在d2lzh_pytorch包中方便以后使用。该函数将被逐步改进：它的完整实现将在“图像增广”一节中描述</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_accuracy</span>(<span class="hljs-params">data_iter, net</span>):<br>    acc_sum, n = <span class="hljs-number">0.0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>        acc_sum += (net(X).argmax(dim=<span class="hljs-number">1</span>) == y).<span class="hljs-built_in">float</span>().<span class="hljs-built_in">sum</span>().item()<br>        n += y.shape[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> acc_sum / n<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(evaluate_accuracy(test_iter, net))<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.0407</code></pre><h2 id="训练模型">训练模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs, lr = <span class="hljs-number">5</span>, <span class="hljs-number">0.1</span><br><br><span class="hljs-comment"># 本函数已保存在d2lzh_pytorch包中方便以后使用</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_ch3</span>(<span class="hljs-params">net, train_iter, test_iter, loss, num_epochs, batch_size,</span><br><span class="hljs-params">              params=<span class="hljs-literal">None</span>, lr=<span class="hljs-literal">None</span>, optimizer=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>        train_l_sum, train_acc_sum, n = <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> train_iter:<br>            y_hat = net(X)<br>            l = loss(y_hat, y).<span class="hljs-built_in">sum</span>()<br>            <br>            <span class="hljs-comment"># 梯度清零</span><br>            <span class="hljs-keyword">if</span> optimizer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                optimizer.zero_grad()<br>            <span class="hljs-keyword">elif</span> params <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> params[<span class="hljs-number">0</span>].grad <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>                    param.grad.data.zero_()<br>            <br>            l.backward()<br>            <span class="hljs-keyword">if</span> optimizer <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                d2l.sgd(params, lr, batch_size)<br>            <span class="hljs-keyword">else</span>:<br>                optimizer.step() <br>            <br>            <br>            train_l_sum += l.item()<br>            train_acc_sum += (y_hat.argmax(dim=<span class="hljs-number">1</span>) == y).<span class="hljs-built_in">sum</span>().item()<br>            n += y.shape[<span class="hljs-number">0</span>]<br>        test_acc = evaluate_accuracy(test_iter, net)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;epoch %d, loss %.4f, train acc %.3f, test acc %.3f&#x27;</span><br>              % (epoch + <span class="hljs-number">1</span>, train_l_sum / n, train_acc_sum / n, test_acc))<br><br>train_ch3(net, train_iter, test_iter, cross_entropy, num_epochs, batch_size, [W, b], lr)<br></code></pre></td></tr></table></figure><pre><code class="hljs">epoch 1, loss 0.7852, train acc 0.749, test acc 0.787epoch 2, loss 0.5708, train acc 0.812, test acc 0.813epoch 3, loss 0.5249, train acc 0.826, test acc 0.821epoch 4, loss 0.5014, train acc 0.833, test acc 0.819epoch 5, loss 0.4868, train acc 0.836, test acc 0.828</code></pre><h2 id="模型预测">模型预测</h2><p>现在我们的模型训练完了，可以进行一下预测，我们的这个模型训练的到底准确不准确。 现在就可以演示如何对图像进行分类了。给定一系列图像（第三行图像输出），我们比较一下它们的真实标签（第一行文本输出）和模型预测结果（第二行文本输出）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">X, y = <span class="hljs-built_in">iter</span>(test_iter).<span class="hljs-built_in">next</span>()<br><br>true_labels = d2l.get_fashion_mnist_labels(y.numpy())<br>pred_labels = d2l.get_fashion_mnist_labels(net(X).argmax(dim=<span class="hljs-number">1</span>).numpy())<br>titles = [true + <span class="hljs-string">&#x27;\n&#x27;</span> + pred <span class="hljs-keyword">for</span> true, pred <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(true_labels, pred_labels)]<br><br>d2l.show_fashion_mnist(X[<span class="hljs-number">0</span>:<span class="hljs-number">9</span>], titles[<span class="hljs-number">0</span>:<span class="hljs-number">9</span>])<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200214205251788.png" /></p><h1 id="softmax的简洁实现">softmax的简洁实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载各种包或者模块</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> init<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&quot;..&quot;</span>) <br><span class="hljs-keyword">import</span> d2lzh_pytorch <span class="hljs-keyword">as</span> d2l<br><br><span class="hljs-built_in">print</span>(torch.__version__)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.4.0+cpu</code></pre><h2 id="初始化参数和获取数据">初始化参数和获取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">256</span><br>train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, root=<span class="hljs-string">&#x27;/home/kesci/input/FashionMNIST2065&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="定义网络模型">定义网络模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">num_inputs = <span class="hljs-number">784</span><br>num_outputs = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearNet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_inputs, num_outputs</span>):<br>        <span class="hljs-built_in">super</span>(LinearNet, self).__init__()<br>        self.linear = nn.Linear(num_inputs, num_outputs)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>): <span class="hljs-comment"># x 的形状: (batch, 1, 28, 28)</span><br>        y = self.linear(x.view(x.shape[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">return</span> y<br>    <br><span class="hljs-comment"># net = LinearNet(num_inputs, num_outputs)</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlattenLayer</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(FlattenLayer, self).__init__()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>): <span class="hljs-comment"># x 的形状: (batch, *, *, ...)</span><br>        <span class="hljs-keyword">return</span> x.view(x.shape[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<br>net = nn.Sequential(<br>        <span class="hljs-comment"># FlattenLayer(),</span><br>        <span class="hljs-comment"># LinearNet(num_inputs, num_outputs) </span><br>        OrderedDict([<br>           (<span class="hljs-string">&#x27;flatten&#x27;</span>, FlattenLayer()),<br>           (<span class="hljs-string">&#x27;linear&#x27;</span>, nn.Linear(num_inputs, num_outputs))]) <span class="hljs-comment"># 或者写成我们自己定义的 LinearNet(num_inputs, num_outputs) 也可以</span><br>        )<br></code></pre></td></tr></table></figure><h2 id="初始化模型参数">初始化模型参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">init.normal_(net.linear.weight, mean=<span class="hljs-number">0</span>, std=<span class="hljs-number">0.01</span>)<br>init.constant_(net.linear.bias, val=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Parameter containing:tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], requires_grad=True)</code></pre><h2 id="定义损失函数-1">定义损失函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">loss = nn.CrossEntropyLoss() <span class="hljs-comment"># 下面是他的函数原型</span><br><span class="hljs-comment"># class torch.nn.CrossEntropyLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction=&#x27;mean&#x27;)</span><br></code></pre></td></tr></table></figure><h2 id="定义优化函数">定义优化函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.1</span>) <span class="hljs-comment"># 下面是函数原型</span><br><span class="hljs-comment"># class torch.optim.SGD(params, lr=, momentum=0, dampening=0, weight_decay=0, nesterov=False)</span><br></code></pre></td></tr></table></figure><h2 id="训练">训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs = <span class="hljs-number">5</span><br>d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, optimizer)<br></code></pre></td></tr></table></figure><pre><code class="hljs">epoch 1, loss 0.0031, train acc 0.748, test acc 0.793epoch 2, loss 0.0022, train acc 0.813, test acc 0.809epoch 3, loss 0.0021, train acc 0.825, test acc 0.821epoch 4, loss 0.0020, train acc 0.833, test acc 0.822epoch 5, loss 0.0019, train acc 0.838, test acc 0.824</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>DL</category>
      
      <category>PyTorch</category>
      
      <category>CV</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dive into DL: Linear Regression</title>
    <link href="/2020/02/14/Dive%20into%20DL-Linear%20Regression/"/>
    <url>/2020/02/14/Dive%20into%20DL-Linear%20Regression/</url>
    
    <content type="html"><![CDATA[<h2 id="线性回归">线性回归</h2><p>主要内容包括：</p><ol type="1"><li><p>线性回归的基本要素</p></li><li><p>线性回归模型从零开始的实现</p></li><li><p>线性回归模型使用pytorch的简洁实现</p></li></ol><p>第一次打卡链接： <a href="https://www.chenxindaaa.com/article/PytorchTotrial1_SoftmaxClassify/">SoftmaxClassify</a></p><p><a href="https://www.chenxindaaa.com/article/PytorchTotrial1_MultilayerPerceptron/">MultilayerPerceptron</a></p><p><a href="https://www.chenxindaaa.com/article/PytorchTotrial2_TextPrepare/">TextPrepare</a></p><p><a href="https://www.chenxindaaa.com/article/PytorchTotrial2_LanguageModel/">LanguageModel</a></p><p><a href="https://www.chenxindaaa.com/article/PytorchTotrial2_RecurrentNeuralNetwork/">RecurrentNeuralNetwork</a></p><h2 id="线性回归的基本要素">线性回归的基本要素</h2><h3 id="模型">模型</h3><p>为了简单起见，这里我们假设价格只取决于房屋状况的两个因素，即面积（平方米）和房龄（年）。接下来我们希望探索价格与这两个因素的具体关系。线性回归假设输出与各个输入之间是线性关系:</p><p><span class="math display">\[price=w_{area}⋅area+w_{age}⋅age+b\]</span></p><h3 id="数据集">数据集</h3><p>我们通常收集一系列的真实数据，例如多栋房屋的真实售出价格和它们对应的面积和房龄。我们希望在这个数据上面寻找模型参数来使模型的预测价格与真实价格的误差最小。在机器学习术语里，该数据集被称为训练数据集（training data set）或训练集（training set），一栋房屋被称为一个样本（sample），其真实售出价格叫作标签（label），用来预测标签的两个因素叫作特征（feature）。特征用来表征样本的特点。</p><h3 id="损失函数">损失函数</h3><p><strong>1、<span class="math inline">\(MAE / L1 + MSE / L2\)</span></strong></p><p>在模型训练中，我们需要衡量价格预测值与真实值之间的误差。通常我们会选取一个非负数作为误差，且数值越小表示误差越小。一个常用的选择是平方函数。 它在评估索引为 <span class="math inline">\(i\)</span> 的样本误差的表达式为</p><p><span class="math display">\[l^{(i)}(w,b)=\frac{1}{2}(\hat y^{(i)}−y^{(i)})^2,\]</span></p><p><span class="math display">\[L(w,b)=\frac{1}{n}\sum ^n _{i=1}l^{(i)}(w,b)=\frac{1}{n}\sum^n_{i=1}\frac{1}{2}(w^⊤x^{(i)}+b−y^{(i)})^2.\]</span></p><p>上面的损失函数属于<span class="math inline">\(MSE/L_2\)</span>损失,令残差<span class="math inline">\(r=f(X)-y\)</span>则<span class="math inline">\(MAE/L_1\)</span>损失为：</p><p><span class="math display">\[L_1(r)=|r|\]</span></p><p><strong><span class="math inline">\(MSE（L_2损失）\)</span>与<span class="math inline">\(MAE（L_1损失）\)</span>的分析：</strong></p><p>简单来说，<em>MSE计算简便，但MAE对异常点有更好的鲁棒性</em>。训练一个机器学习模型时，目标就是找到损失函数达到极小值的点。当预测值等于真实值时，这两种函数都能达到最小。</p><ul><li><p>分析：MSE对误差取了平方（令<span class="math inline">\(r\)</span>=真实值-预测值），因此若<span class="math inline">\(r\)</span>&gt;1，则MSE会进一步增大误差。如果数据中存在异常点，那么e值就会很大，而e²则会远大于|e|。因此，相对于使用MAE计算损失，使用MSE的模型会赋予异常点更大的权重。用RMSE（即MSE的平方根，同MAE在同一量级中）计算损失的模型会以牺牲了其他样本的误差为代价，朝着减小异常点误差的方向更新。然而这就会降低模型的整体性能。直观上可以这样理解：如果我们最小化MSE来对所有的样本点只给出一个预测值，那么这个值一定是所有目标值的平均值。但如果是最小化MAE，那么这个值，则会是所有样本点目标值的中位数。对异常值而言，中位数比均值更加鲁棒，因此MAE对于异常值也比MSE更稳定。</p></li><li><p>如何选择损失函数：如果训练数据被异常点所污染（比如，在训练数据中存在大量错误的反例和正例标记，但是在测试集中没有这个问题）或者异常点代表在商业中很重要的异常情况，并且需要被检测出来，则应选用MSE损失函数。相反，如果只把异常值当作受损数据，则应选用MAE损失函数。 MAE存在一个严重的问题（特别是对于神经网络）：更新的梯度始终相同，也就是说，即使对于很小的损失值，梯度也很大。这样不利于模型的学习。为了解决这个缺陷，可以使用变化的学习率，在损失接近最小值时降低学习率。 MSE在这种情况下的表现就很好，即便使用固定的学习率也可以有效收敛。MSE损失的梯度随损失增大而增大，而损失趋于0时则会减小。这使得在训练结束时，使用MSE模型的结果会更精确。</p></li><li><p>总结：处理异常点时，L1损失函数更稳定，但它的导数不连续，因此求解效率较低。L2损失函数对异常点更敏感，但通过令其导数为0，可以得到更稳定的封闭解。 二者兼有的问题是：在某些情况下，上述两种损失函数都不能满足需求。例如，若数据中90%的样本对应的目标值为150，剩下10%在0到30之间。那么使用MAE作为损失函数的模型可能会忽视10%的异常点，而对所有样本的预测值都为150。这是因为模型会按中位数来预测。而使用MSE的模型则会给出很多介于0到30的预测值，因为模型会向异常点偏移。上述两种结果在许多商业场景中都是不可取的。最简单的办法是对目标变量进行变换。而另一种办法则是换一个损失函数。</p></li></ul><p><strong>2、Huber Loss</strong></p><p><span class="math display">\[L_\delta (y, f(x))=\begin{cases}\frac{1}{2}(y-f(x))^2  &amp; for|y-f(x)|\leq \delta \\[2ex]\delta|y-f(x)|-\frac{1}{2}\delta ^ 2 &amp; otherwise\end{cases}\]</span></p><p>Huber损失，平滑的平均绝对误差。Huber损失对数据中的异常点没有平方误差损失那么敏感。它在0也可微分。<em>本质上，Huber损失是绝对误差，只是在误差很小时，就变为平方误差</em>。误差降到多小时变为平方误差由超参数δ（delta）来控制。当Huber损失在 [0-<span class="math inline">\(\delta\)</span>，0+<span class="math inline">\(\delta\)</span>] 之间时，等价为MSE，而在 [<span class="math inline">\(-\infty\)</span>，<span class="math inline">\(\delta\)</span>] 和 [<span class="math inline">\(\delta\)</span>，<span class="math inline">\(+\infty\)</span>] 时为MAE。</p><p>这里超参数delta的选择非常重要，因为这决定了对异常点的定义。当残差大于delta，应当采用L1（对较大的异常值不那么敏感）来最小化，而残差小于超参数，则用L2来最小化。</p><p><strong>如何选择损失函数</strong>：使用MAE训练神经网络最大的一个问题就是不变的大梯度，这可能导致在使用梯度下降快要结束时，错过了最小点。而对于MSE，梯度会随着损失的减小而减小，使结果更加精确。在这种情况下，Huber损失就非常有用。它会由于梯度的减小而落在最小值附近。比起MSE，它对异常点更加鲁棒。因此，Huber损失结合了MSE和MAE的优点。但是，Huber损失的问题是可能需要不断调整超参数delta。</p><p><strong>3、Log-Cosh Loss</strong></p><p><span class="math display">\[L(y,y^p)=\sum ^n _{i=1}log(cosh(y_i^p)-y_i)\]</span></p><p>Log-cosh损失是另一种应用于回归问题中的，且比L2更平滑的的损失函数。它的计算方式是预测误差的双曲余弦的对数。</p><p><strong>优点</strong>：对于较小的<span class="math inline">\(x\)</span>，<span class="math inline">\(log(cosh(x))\)</span>近似等于<span class="math inline">\((x^2)/2\)</span>，对于较大的<span class="math inline">\(x\)</span>，近似等于<span class="math inline">\(abs(x)-log(2)\)</span>。这意味着<span class="math inline">\(‘logcosh’\)</span>基本类似于均方误差，但不易受到异常点的影响。它具有Huber损失所有的优点，但不同于Huber损失的是，Log-cosh二阶处处可微。</p><p><strong>如何选择损失函数</strong>：许多机器学习模型如XGBoost，就是采用牛顿法来寻找最优点。而牛顿法就需要求解二阶导数（Hessian）。因此对于诸如XGBoost这类机器学习框架，损失函数的二阶可微是很有必要的。但Log-cosh损失也并非完美，其仍存在某些问题。比如误差很大的话，一阶梯度和Hessian会变成定值，这就导致XGBoost出现缺少分裂点的情况。</p><p><strong>4、Quantile Loss</strong></p><p><span class="math display">\[L_\gamma(u,y^p)=\sum_{i:y_i&lt;y_i^p}(1-\gamma)|y_i-y_i^p|+\sum_{i:y_i\geq y_i^p}\gamma|y_i-y_i^p|\]</span></p><p>许多商业问题的决策通常希望了解预测中的不确定性，<strong>更关注区间预测而不仅是点预测</strong>时，分位数损失函数就很有用。</p><p>使用最小二乘回归进行区间预测，基于的假设是残差<span class="math inline">\(（y-\hat{y}）\)</span>是独立变量，且方差保持不变。一旦违背了这条假设，那么线性回归模型就不成立。这时，就可以使用分位数损失和分位数回归，<strong>因为即便对于具有变化方差或非正态分布的残差，基于分位数损失的回归也能给出合理的预测区间。</strong></p><p><strong>理解分位数损失函数</strong>：如何选取合适的分位值取决于我们对正误差和反误差的重视程度。损失函数通过分位值（γ）对高估和低估给予不同的惩罚。例如，当分位数损失函数γ=0.25时，对高估的惩罚更大，使得预测值略低于中值。</p><h3 id="优化函数---随机梯度下降">优化函数 - 随机梯度下降</h3><p>当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫作解析解（analytical solution）。本节使用的线性回归和平方误差刚好属于这个范畴。然而，大多数深度学习模型并没有解析解，只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。这类解叫作数值解（numerical solution）。</p><p>在求数值解的优化算法中，小批量随机梯度下降（mini-batch stochastic gradient descent）在深度学习中被广泛使用。它的算法很简单：先选取一组模型参数的初始值，如随机选取；接下来对参数进行多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样一个由固定数目训练数据样本所组成的小批量（mini-batch） B ，然后求小批量中数据样本的平均损失有关模型参数的导数（梯度），最后用此结果与预先设定的一个正数的乘积作为模型参数在本次迭代的减小量。</p><p><span class="math display">\[(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b)\]</span></p><p>学习率: η 代表在每次优化中，能够学习的步长的大小 批量大小: B 是小批量计算中的批量大小batch size</p><p>总结一下，优化函数的有以下两个步骤：</p><ul><li>(i)初始化模型参数，一般来说使用随机初始化；</li><li>(ii)我们在数据上迭代多次，通过在负梯度方向移动参数来更新每个参数。</li></ul><h2 id="矢量计算">矢量计算</h2><p>在模型训练或预测时，我们常常会同时处理多个数据样本并用到矢量计算。在介绍线性回归的矢量计算表达式之前，让我们先考虑对两个向量相加的两种方法。</p><ol type="1"><li>向量相加的一种方法是，将这两个向量按元素逐一做标量加法。</li><li>向量相加的另一种方法是，将这两个向量直接做矢量加法。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># init variable a, b as 1000 dimension vector</span><br>n = <span class="hljs-number">1000</span><br>a = torch.ones(n)<br>b = torch.ones(n)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># define a timer class to record time</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Record multiple running times.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.times = []<br>        self.start()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># start the timer</span><br>        self.start_time = time.time()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">stop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># stop the timer and record time into a list</span><br>        self.times.append(time.time() - self.start_time)<br>        <span class="hljs-keyword">return</span> self.times[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">avg</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># calculate the average and return</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(self.times)/<span class="hljs-built_in">len</span>(self.times)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># return the sum of recorded time</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(self.times)<br></code></pre></td></tr></table></figure><p>现在我们可以来测试了。首先将两个向量使用for循环按元素逐一做标量加法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">timer = Timer()<br>c = torch.zeros(n)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    c[i] = a[i] + b[i]<br><span class="hljs-string">&#x27;%.5f sec&#x27;</span> % timer.stop()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;0.04067 sec&#39;</code></pre><p>另外是使用torch来将两个向量直接做矢量加法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">timer.start()<br>d = a + b<br><span class="hljs-string">&#x27;%.5f sec&#x27;</span> % timer.stop()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;0.00000 sec&#39;</code></pre><p>结果很明显,后者比前者运算速度更快。因此，我们应该尽可能采用矢量计算，以提升计算效率。</p><h2 id="线性回归模型从零开始的实现">线性回归模型从零开始的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># import packages and modules</span><br>%matplotlib inline<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> IPython <span class="hljs-keyword">import</span> display<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><br><span class="hljs-built_in">print</span>(torch.__version__)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.4.0+cpu</code></pre><h2 id="生成数据集">生成数据集</h2><p>使用线性模型来生成数据集，生成一个1000个样本的数据集，下面是用来生成数据的线性关系： <span class="math display">\[price=w_{area}⋅area+w_{age}⋅age+b\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># set input feature number </span><br>num_inputs = <span class="hljs-number">2</span><br><span class="hljs-comment"># set example number</span><br>num_examples = <span class="hljs-number">1000</span><br><br><span class="hljs-comment"># set true weight and bias in order to generate corresponded label</span><br>true_w = [<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>]<br>true_b = <span class="hljs-number">4.2</span><br><br>features = torch.randn(num_examples, num_inputs,<br>                      dtype=torch.float32)<br>labels = true_w[<span class="hljs-number">0</span>] * features[:, <span class="hljs-number">0</span>] + true_w[<span class="hljs-number">1</span>] * features[:, <span class="hljs-number">1</span>] + true_b<br>labels += torch.tensor(np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, size=labels.size()),<br>                       dtype=torch.float32)<br></code></pre></td></tr></table></figure><p>使用图像来展示生成的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.scatter(features[:, <span class="hljs-number">1</span>].numpy(), labels.numpy(), <span class="hljs-number">1</span>);  <span class="hljs-comment"># plt.scatter(x, y, s=20)</span><br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/20200214205009619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aHyHVLO6-1581684543305)(output_13_0.png)]" /><figcaption>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aHyHVLO6-1581684543305)(output_13_0.png)]</figcaption></figure><h2 id="读取数据集">读取数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter</span>(<span class="hljs-params">batch_size, features, labels</span>):<br>    num_examples = <span class="hljs-built_in">len</span>(features)<br>    indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(num_examples))<br>    random.shuffle(indices)  <span class="hljs-comment"># random read 10 samples</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_examples, batch_size):<br>        j = torch.LongTensor(indices[i: <span class="hljs-built_in">min</span>(i + batch_size, num_examples)]) <span class="hljs-comment"># the last time may be not enough for a whole batch</span><br>        <span class="hljs-keyword">yield</span>  features.index_select(<span class="hljs-number">0</span>, j), labels.index_select(<span class="hljs-number">0</span>, j)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter(batch_size, features, labels):<br>    <span class="hljs-built_in">print</span>(X, <span class="hljs-string">&#x27;\n&#x27;</span>, y)<br>    <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">tensor([[-1.5533, -1.2282],        [ 0.1451,  1.4294],        [-0.3247, -0.6582],        [-0.4311,  1.1138],        [ 0.2255,  0.4859],        [ 0.0138,  1.2828],        [ 1.6966,  1.4811],        [ 0.6216, -1.3915],        [-0.1157,  0.6430],        [ 0.2604,  1.9266]])  tensor([ 5.2722, -0.3629,  5.7908, -0.4465,  2.9890, -0.1313,  2.5523, 10.1736,         1.7958, -1.8457])</code></pre><h2 id="初始化模型参数">初始化模型参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">w = torch.tensor(np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, (num_inputs, <span class="hljs-number">1</span>)), dtype=torch.float32) <span class="hljs-comment"># 正态分布</span><br>b = torch.zeros(<span class="hljs-number">1</span>, dtype=torch.float32)<br><br>w.requires_grad_(requires_grad=<span class="hljs-literal">True</span>)<br>b.requires_grad_(requires_grad=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 需要求梯度</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">torch.Size([2, 1])</code></pre><h2 id="定义模型">定义模型</h2><p>定义用来训练参数的训练模型： <span class="math display">\[price=w_{area}⋅area+w_{age}⋅age+b\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linreg</span>(<span class="hljs-params">X, w, b</span>):<br>    <span class="hljs-keyword">return</span> torch.mm(X, w) + b  <span class="hljs-comment"># mm矩阵乘法</span><br></code></pre></td></tr></table></figure><h2 id="定义损失函数">定义损失函数</h2><p>我们使用的是均方误差损失函数： <span class="math display">\[l^{(i)}(w,b)=\frac{1}{2}(\hat{y}^{(i)}-y^{(i)})^2\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">squared_loss</span>(<span class="hljs-params">y_hat, y</span>): <br>    <span class="hljs-keyword">return</span> (y_hat - y.view(y_hat.size())) ** <span class="hljs-number">2</span> / <span class="hljs-number">2</span>  <span class="hljs-comment"># view把y维度弄成和y帽一样</span><br></code></pre></td></tr></table></figure><h2 id="定义优化函数">定义优化函数</h2><p>在这里优化函数使用的是小批量随机梯度下降： <span class="math display">\[(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sgd</span>(<span class="hljs-params">params, lr, batch_size</span>): <br>    <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>        param.data -= lr * param.grad / batch_size <span class="hljs-comment"># ues .data to operate param without gradient track</span><br></code></pre></td></tr></table></figure><h2 id="训练">训练</h2><p>当数据集、模型、损失函数和优化函数定义完了之后就可来准备进行模型的训练了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># super parameters init</span><br>lr = <span class="hljs-number">0.03</span>  <span class="hljs-comment"># 学习率即步长</span><br>num_epochs = <span class="hljs-number">5</span>  <span class="hljs-comment"># epoch训练5轮</span><br><br>net = linreg  <span class="hljs-comment"># 模型</span><br>loss = squared_loss  <span class="hljs-comment"># 损失函数</span><br><br><span class="hljs-comment"># training</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):  <span class="hljs-comment"># training repeats num_epochs times</span><br>    <span class="hljs-comment"># in each epoch, all the samples in dataset will be used once</span><br>    <br>    <span class="hljs-comment"># X is the feature and y is the label of a batch sample</span><br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter(batch_size, features, labels):<br>        l = loss(net(X, w, b), y).<span class="hljs-built_in">sum</span>()  <br>        <span class="hljs-comment"># calculate the gradient of batch sample loss </span><br>        l.backward()  <br>        <span class="hljs-comment"># using small batch random gradient descent to iter model parameters</span><br>        sgd([w, b], lr, batch_size)  <br>        <span class="hljs-comment"># reset parameter gradient</span><br>        w.grad.data.zero_()<br>        b.grad.data.zero_()<br>    train_l = loss(net(features, w, b), labels)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;epoch %d, loss %f&#x27;</span> % (epoch + <span class="hljs-number">1</span>, train_l.mean().item()))<br></code></pre></td></tr></table></figure><pre><code class="hljs">epoch 1, loss 0.038881epoch 2, loss 0.000143epoch 3, loss 0.000048epoch 4, loss 0.000048epoch 5, loss 0.000048</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">w, true_w, b, true_b<br></code></pre></td></tr></table></figure><pre><code class="hljs">(tensor([[ 1.9993],         [-3.3998]], requires_grad=True), [2, -3.4], tensor([4.2000], requires_grad=True), 4.2)</code></pre><h2 id="线性回归模型使用pytorch的简洁实现">线性回归模型使用pytorch的简洁实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>torch.manual_seed(<span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(torch.__version__)<br>torch.set_default_tensor_type(<span class="hljs-string">&#x27;torch.FloatTensor&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.4.0+cpu</code></pre><h2 id="生成数据集-1">生成数据集</h2><p>在这里生成数据集跟从零开始的实现中是完全一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">num_inputs = <span class="hljs-number">2</span><br>num_examples = <span class="hljs-number">1000</span><br><br>true_w = [<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>]<br>true_b = <span class="hljs-number">4.2</span><br><br>features = torch.tensor(np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (num_examples, num_inputs)), dtype=torch.<span class="hljs-built_in">float</span>)<br>labels = true_w[<span class="hljs-number">0</span>] * features[:, <span class="hljs-number">0</span>] + true_w[<span class="hljs-number">1</span>] * features[:, <span class="hljs-number">1</span>] + true_b<br>labels += torch.tensor(np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, size=labels.size()), dtype=torch.<span class="hljs-built_in">float</span>)<br></code></pre></td></tr></table></figure><h2 id="读取数据集-1">读取数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br><br>batch_size = <span class="hljs-number">10</span><br><br><span class="hljs-comment"># combine featues and labels of dataset</span><br>dataset = Data.TensorDataset(features, labels)<br><br><span class="hljs-comment"># put dataset into DataLoader</span><br>data_iter = Data.DataLoader(<br>    dataset=dataset,            <span class="hljs-comment"># torch TensorDataset format</span><br>    batch_size=batch_size,      <span class="hljs-comment"># mini batch size</span><br>    shuffle=<span class="hljs-literal">True</span>,               <span class="hljs-comment"># whether shuffle the data or not 是否混淆</span><br>    num_workers=<span class="hljs-number">2</span>,              <span class="hljs-comment"># read data in multithreading 两个线程</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>    <span class="hljs-built_in">print</span>(X, <span class="hljs-string">&#x27;\n&#x27;</span>, y)<br>    <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">tensor([[ 0.1144, -0.2228],        [ 0.3022,  0.0972],        [ 0.2309, -0.1299],        [ 0.3725,  0.7687],        [ 0.2221, -0.4771],        [-0.0137,  0.7123],        [-1.2542,  0.5133],        [ 0.8199, -0.1336],        [ 0.9226, -0.3770],        [-0.4336,  0.4475]])  tensor([ 5.1815,  4.4663,  5.0981,  2.3221,  6.2576,  1.7511, -0.0654,  6.3130,         7.3475,  1.8041])</code></pre><h2 id="定义模型-1">定义模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearNet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n_feature</span>):<br>        <span class="hljs-built_in">super</span>(LinearNet, self).__init__()      <span class="hljs-comment"># call father function to init </span><br>        self.linear = nn.Linear(n_feature, <span class="hljs-number">1</span>)  <span class="hljs-comment"># function prototype: `torch.nn.Linear(in_features, out_features, bias=True)`</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        y = self.linear(x)<br>        <span class="hljs-keyword">return</span> y<br>    <br>net = LinearNet(num_inputs)<br><span class="hljs-built_in">print</span>(net)<br></code></pre></td></tr></table></figure><pre><code class="hljs">LinearNet(  (linear): Linear(in_features=2, out_features=1, bias=True))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ways to init a multilayer network</span><br><span class="hljs-comment"># method one</span><br>net = nn.Sequential(<br>    nn.Linear(num_inputs, <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># other layers can be added here</span><br>    ) <br><br><span class="hljs-comment"># method two</span><br>net = nn.Sequential()<br>net.add_module(<span class="hljs-string">&#x27;linear&#x27;</span>, nn.Linear(num_inputs, <span class="hljs-number">1</span>))<br><span class="hljs-comment"># net.add_module ......</span><br><br><span class="hljs-comment"># method three</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<br>net = nn.Sequential(OrderedDict([<br>          (<span class="hljs-string">&#x27;linear&#x27;</span>, nn.Linear(num_inputs, <span class="hljs-number">1</span>))<br>          <span class="hljs-comment"># ......</span><br>        ]))<br><br><span class="hljs-built_in">print</span>(net)<br><span class="hljs-built_in">print</span>(net[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">Sequential(  (linear): Linear(in_features=2, out_features=1, bias=True))Linear(in_features=2, out_features=1, bias=True)</code></pre><h2 id="初始化模型参数-1">初始化模型参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> init<br><br>init.normal_(net[<span class="hljs-number">0</span>].weight, mean=<span class="hljs-number">0.0</span>, std=<span class="hljs-number">0.01</span>)<br>init.constant_(net[<span class="hljs-number">0</span>].bias, val=<span class="hljs-number">0.0</span>)  <span class="hljs-comment"># or you can use `net[0].bias.data.fill_(0)` to modify it directly</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">Parameter containing:tensor([0.], requires_grad=True)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> net.parameters():<br>    <span class="hljs-built_in">print</span>(param)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Parameter containing:tensor([[-0.0142, -0.0161]], requires_grad=True)Parameter containing:tensor([0.], requires_grad=True)</code></pre><h2 id="定义损失函数-1">定义损失函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">loss = nn.MSELoss()    <span class="hljs-comment"># nn built-in squared loss function</span><br>                       <span class="hljs-comment"># function prototype: `torch.nn.MSELoss(size_average=None, reduce=None, reduction=&#x27;mean&#x27;)`</span><br></code></pre></td></tr></table></figure><h2 id="定义优化函数-1">定义优化函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br>optimizer = optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)   <span class="hljs-comment"># built-in random gradient descent function</span><br><span class="hljs-built_in">print</span>(optimizer)  <span class="hljs-comment"># function prototype: `torch.optim.SGD(params, lr=, momentum=0, dampening=0, weight_decay=0, nesterov=False)`</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">SGD (Parameter Group 0    dampening: 0    lr: 0.03    momentum: 0    nesterov: False    weight_decay: 0)</code></pre><h2 id="训练-1">训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs = <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num_epochs + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>        output = net(X)<br>        l = loss(output, y.view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>        optimizer.zero_grad() <span class="hljs-comment"># reset gradient, equal to net.zero_grad()</span><br>        l.backward()<br>        optimizer.step()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;epoch %d, loss: %f&#x27;</span> % (epoch, l.item()))<br></code></pre></td></tr></table></figure><pre><code class="hljs">epoch 1, loss: 0.000369epoch 2, loss: 0.000100epoch 3, loss: 0.000132</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># result comparision</span><br>dense = net[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(true_w, dense.weight.data)<br><span class="hljs-built_in">print</span>(true_b, dense.bias.data)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[2, -3.4] tensor([[ 2.0004, -3.4000]])4.2 tensor([4.1998])</code></pre><h2 id="两种实现方式的比较">两种实现方式的比较</h2><ol type="1"><li>从零开始的实现（推荐用来学习）</li></ol><p>能够更好的理解模型和神经网络底层的原理</p><ol start="2" type="1"><li>使用pytorch的简洁实现</li></ol><p>能够更加快速地完成模型的设计与实现</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>DL</category>
      
      <category>PyTorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dive into DL: Text Prepare</title>
    <link href="/2020/02/14/Dive%20into%20DL-Text%20Prepare/"/>
    <url>/2020/02/14/Dive%20into%20DL-Text%20Prepare/</url>
    
    <content type="html"><![CDATA[<h1 id="文本预处理">文本预处理</h1><p>文本是一类序列数据，一篇文章可以看作是字符或单词的序列，本节将介绍文本数据的常见预处理步骤，预处理通常包括四个步骤：</p><ol type="1"><li>读入文本</li><li>分词</li><li>建立字典，将每个词映射到一个唯一的索引（index）</li><li>将文本从词的序列转换为索引的序列，方便输入模型</li></ol><h2 id="读入文本">读入文本</h2><p>我们用一部英文小说，即H. G. Well的<a href="http://www.gutenberg.org/ebooks/35">Time Machine</a>，作为示例，展示文本预处理的具体过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_time_machine</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./input/timemachine.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        lines = [re.sub(<span class="hljs-string">&#x27;[^a-z]+&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, line.strip().lower()) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f]<br>    <span class="hljs-keyword">return</span> lines<br><br><br>lines = read_time_machine()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;# sentences %d&#x27;</span> % <span class="hljs-built_in">len</span>(lines))<br></code></pre></td></tr></table></figure><pre><code class="hljs"># sentences 3583</code></pre><h2 id="分词">分词</h2><p>我们对每个句子进行分词，也就是将一个句子划分成若干个词（token），转换为一个词的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize</span>(<span class="hljs-params">sentences, token=<span class="hljs-string">&#x27;word&#x27;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Split sentences into word or char tokens&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> token == <span class="hljs-string">&#x27;word&#x27;</span>:<br>        <span class="hljs-keyword">return</span> [sentence.split(<span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> sentences]<br>    <span class="hljs-keyword">elif</span> token == <span class="hljs-string">&#x27;char&#x27;</span>:<br>        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">list</span>(sentence) <span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> sentences]<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ERROR: unkown token type &#x27;</span>+token)<br><br>tokens = tokenize(lines)<br>tokens[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[&#39;the&#39;, &#39;time&#39;, &#39;machine&#39;, &#39;by&#39;, &#39;h&#39;, &#39;g&#39;, &#39;wells&#39;, &#39;&#39;], [&#39;&#39;]]</code></pre><h2 id="建立字典">建立字典</h2><p>为了方便模型处理，我们需要将字符串转换为数字。因此我们需要先构建一个字典（vocabulary），将每个词映射到一个唯一的索引编号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vocab</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, tokens, min_freq=<span class="hljs-number">0</span>, use_special_tokens=<span class="hljs-literal">False</span></span>):<br>        counter = count_corpus(tokens)  <span class="hljs-comment"># : </span><br>        self.token_freqs = <span class="hljs-built_in">list</span>(counter.items())<br>        self.idx_to_token = []<br>        <span class="hljs-keyword">if</span> use_special_tokens:<br>            <span class="hljs-comment"># padding, begin of sentence, end of sentence, unknown</span><br>            self.pad, self.bos, self.eos, self.unk = (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>            self.idx_to_token += [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br>        <span class="hljs-keyword">else</span>:<br>            self.unk = <span class="hljs-number">0</span><br>            self.idx_to_token += [<span class="hljs-string">&#x27;&#x27;</span>]<br>        self.idx_to_token += [token <span class="hljs-keyword">for</span> token, freq <span class="hljs-keyword">in</span> self.token_freqs<br>                        <span class="hljs-keyword">if</span> freq &gt;= min_freq <span class="hljs-keyword">and</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.idx_to_token]<br>        self.token_to_idx = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> idx, token <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.idx_to_token):<br>            self.token_to_idx[token] = idx<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.idx_to_token)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, tokens</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(tokens, (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>)):<br>            <span class="hljs-keyword">return</span> self.token_to_idx.get(tokens, self.unk)<br>        <span class="hljs-keyword">return</span> [self.__getitem__(token) <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> tokens]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_tokens</span>(<span class="hljs-params">self, indices</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(indices, (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>)):<br>            <span class="hljs-keyword">return</span> self.idx_to_token[indices]<br>        <span class="hljs-keyword">return</span> [self.idx_to_token[index] <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> indices]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_corpus</span>(<span class="hljs-params">sentences</span>):<br>    tokens = [tk <span class="hljs-keyword">for</span> st <span class="hljs-keyword">in</span> sentences <span class="hljs-keyword">for</span> tk <span class="hljs-keyword">in</span> st]<br>    <span class="hljs-keyword">return</span> collections.Counter(tokens)  <span class="hljs-comment"># 返回一个字典，记录每个词的出现次数</span><br></code></pre></td></tr></table></figure><p>我们看一个例子，这里我们尝试用Time Machine作为语料构建字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">vocab = Vocab(tokens)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(vocab.token_to_idx.items())[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">[(&#39;&#39;, 0), (&#39;the&#39;, 1), (&#39;time&#39;, 2), (&#39;machine&#39;, 3), (&#39;by&#39;, 4), (&#39;h&#39;, 5), (&#39;g&#39;, 6), (&#39;wells&#39;, 7), (&#39;i&#39;, 8), (&#39;traveller&#39;, 9)]</code></pre><h2 id="将词转为索引">将词转为索引</h2><p>使用字典，我们可以将原文本中的句子从单词序列转换为索引序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>, <span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;words:&#x27;</span>, tokens[i])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;indices:&#x27;</span>, vocab[tokens[i]])<br></code></pre></td></tr></table></figure><pre><code class="hljs">words: [&#39;the&#39;, &#39;time&#39;, &#39;traveller&#39;, &#39;for&#39;, &#39;so&#39;, &#39;it&#39;, &#39;will&#39;, &#39;be&#39;, &#39;convenient&#39;, &#39;to&#39;, &#39;speak&#39;, &#39;of&#39;, &#39;him&#39;, &#39;&#39;]indices: [1, 2, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0]words: [&#39;was&#39;, &#39;expounding&#39;, &#39;a&#39;, &#39;recondite&#39;, &#39;matter&#39;, &#39;to&#39;, &#39;us&#39;, &#39;his&#39;, &#39;grey&#39;, &#39;eyes&#39;, &#39;shone&#39;, &#39;and&#39;]indices: [20, 21, 22, 23, 24, 16, 25, 26, 27, 28, 29, 30]</code></pre><h2 id="用现有工具进行分词">用现有工具进行分词</h2><p>我们前面介绍的分词方式非常简单，它至少有以下几个缺点:</p><ol type="1"><li>标点符号通常可以提供语义信息，但是我们的方法直接将其丢弃了</li><li>类似“shouldn't", "doesn't"这样的词会被错误地处理</li><li>类似"Mr.", "Dr."这样的词会被错误地处理</li></ol><p>我们可以通过引入更复杂的规则来解决这些问题，但是事实上，有一些现有的工具可以很好地进行分词，我们在这里简单介绍其中的两个：<a href="https://spacy.io/">spaCy</a>和<a href="https://www.nltk.org/">NLTK</a>。</p><p>下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&quot;Mr. Chen doesn&#x27;t agree with my suggestion.&quot;</span><br></code></pre></td></tr></table></figure><p>spaCy:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> spacy<br>nlp = spacy.load(<span class="hljs-string">&#x27;en_core_web_sm&#x27;</span>)<br>doc = nlp(text)<br><span class="hljs-built_in">print</span>([token.text <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> doc])<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;Mr.&#39;, &#39;Chen&#39;, &#39;does&#39;, &quot;n&#39;t&quot;, &#39;agree&#39;, &#39;with&#39;, &#39;my&#39;, &#39;suggestion&#39;, &#39;.&#39;]</code></pre><p>NLTK:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nltk.tokenize <span class="hljs-keyword">import</span> word_tokenize<br><span class="hljs-keyword">from</span> nltk <span class="hljs-keyword">import</span> data<br>data.path.append(<span class="hljs-string">&#x27;/home/kesci/input/nltk_data3784/nltk_data&#x27;</span>)<br><span class="hljs-built_in">print</span>(word_tokenize(text))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;Mr.&#39;, &#39;Chen&#39;, &#39;does&#39;, &quot;n&#39;t&quot;, &#39;agree&#39;, &#39;with&#39;, &#39;my&#39;, &#39;suggestion&#39;, &#39;.&#39;]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>DL</category>
      
      <category>PyTorch</category>
      
      <category>NLP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
