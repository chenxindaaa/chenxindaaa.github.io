<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/Programming/Docker/Docker/"/>
    <url>/Programming/Docker/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker教程">Docker教程</h1><h2 id="一docker三要素">一、Docker三要素：</h2><ol type="1"><li>image <span class="math inline">\(\rightarrow\)</span> class</li><li>container <span class="math inline">\(\rightarrow\)</span> instance</li><li>repository <span class="math inline">\(\rightarrow\)</span> 存放image的场所，官方registry称为Docker Hub</li></ol><h2 id="二安装">二、安装</h2><p><a href="https://docs.docker.com/engine/">步骤</a></p><p><code>Note：Set up the repository</code></p><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云镜像加速</a></p><h2 id="三docker常用命令">三、Docker常用命令</h2><h3 id="帮助启动类命令">3.1 帮助启动类命令</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl start docker  <span class="hljs-comment"># 启动docker</span><br><span class="hljs-params">system</span>ctl stop docker  <span class="hljs-comment"># 停止docker</span><br><span class="hljs-params">system</span>ctl restart docker  <span class="hljs-comment"># 重启docker</span><br><span class="hljs-params">system</span>ctl status docker  <span class="hljs-comment"># 查看docker状态</span><br><span class="hljs-params">system</span>ctl enable docker  <span class="hljs-comment"># 开机启动</span><br>docker info  <span class="hljs-comment"># 查看docker概要信息</span><br>docker --help  <span class="hljs-comment"># 查看docker总体帮助文档</span><br>docker 具体命令 --help  <span class="hljs-comment"># 查看docker命令帮助文档</span><br></code></pre></td></tr></table></figure><h3 id="镜像命令">3.2 镜像命令</h3><ul><li>docker images [OPTIONS]：列出本地主机上的镜像<ul><li>各个选项说明: REPOSITORY：表示镜像的仓库源 TAG：镜像的标签版本号 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</li><li>OPTIONS说明：<ul><li>-a :列出本地所有的镜像（含历史映像层）</li><li>-q :只显示镜像ID。</li></ul></li></ul></li><li>docker search [OPTIONS] 镜像名字：搜索镜像<ul><li>OPTIONS说明：<ul><li>--limit : 只列出N个镜像，默认25个 e.g. docker search --limit 5 redis</li></ul></li></ul></li><li>docker pull 某个XXX镜像名字：下载镜像<ul><li>docker pull 镜像名字:[TAG] 没有TAG就是最新版等价于docker pull 镜像名字:latest</li></ul></li><li>docker system df：查看镜像/容器/数据卷所占的空间</li><li>docker rmi 某个XXX镜像名字ID：删除镜像<ul><li>删除单个 docker rmi -f 镜像ID</li><li>删除多个 docker rmi -f 镜像名1:TAG 镜像名2:TAG</li><li>删除全部 docker rmi -f $(docker images -qa) ### 3.3 容器命令</li></ul></li><li>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]：新建+启动容器<ul><li>OPTIONS说明：有些是一个减号，有些是两个减号<ul><li>--name="容器新名字" 为容器指定一个名称；</li><li>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</li><li>启动交互式容器(前台有伪终端，等待交互)<ul><li>-i：以交互模式运行容器，通常与 -t 同时使用；(interactive)</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；(terminal)</li><li>e.g. docker run -it ubuntu /bin/bash： 使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令 /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。要退出终端，直接输入 exit:</li></ul></li><li>-P: 随机端口映射，大写P</li><li>-p: 指定端口映射，小写p</li></ul></li></ul></li><li>docker ps [OPTIONS]：·列出当前所有正在运行的容器<ul><li>OPTIONS说明<ul><li>-a：列出当前所有正在运行的容器+历史上运行过的</li><li>-l：显示最近创建的容器。</li><li>-n：显示最近n个创建的容器。</li><li>-q：静默模式，只显示容器编号。</li></ul></li></ul></li><li>退出容器 关系 指向 进入正在运行的容器并以命令行交互 ·两种退出方式 ·exit ·run进去容器，exit退出，容器停止 ·ctrl+p+q ·run进去容器，ctrl+p+q退出，容器不停止 ·启动已停止运行的容器 ·docker start 容器ID或者容器名</li><li>重启容器 ·docker restart 容器ID或者容器名 ·停止容器 ·docker stop 容器ID或者容器名 ·强制停止容器 ·docker kill 容器ID或容器名 ·删除已停止的容器 ·docker rm 容器ID ·一次性删除多个容器实例 ·docker rm -f $(docker ps -a -q) ·docker ps -a -q | xargs docker rm</li></ul><h2 id="reference">Reference:</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1gr4y1U7CY?p=1&amp;vd_source=bd05c11d5f9bf6d6b4849b57473d2194">尚硅谷Docker实战教程</a> <a href="https://space.bilibili.com/393424102">JJacobb</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMake</title>
    <link href="/Programming/C-C/CMake/CMake/"/>
    <url>/Programming/C-C/CMake/CMake/</url>
    
    <content type="html"><![CDATA[<h1 id="最小配置示例">最小配置示例</h1><h2 id="cmakelists.txt">CMakelists.txt</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cmake<span class="hljs-constructor">_minimum_required(VERSION 3.0)</span>  # cmake最低版本<br>project(sample CXX)  # 项目名称<br>add<span class="hljs-constructor">_library(<span class="hljs-params">sample</span> <span class="hljs-params">sample</span>.<span class="hljs-params">cpp</span>)</span>  # 添加库<br>add<span class="hljs-constructor">_executable(<span class="hljs-params">sample_exe</span> <span class="hljs-params">sample_exe</span>.<span class="hljs-params">cpp</span>)</span>  # 添加可执行程序<br></code></pre></td></tr></table></figure><h2 id="相关函数">相关函数</h2><ul><li>project：定义工程名称，并可指定工程支持的语言<ul><li>project(projectname [CXX] [C] [Java][C CXX])</li><li>项目对应的变量：<ul><li>PROJECT_NAME：项目名称</li><li>PROJECT_SOURCE_DIR：项目源码根目录</li><li>PROJECT_VERSION：项目版本</li><li>PROJECT_BINARY_DIR：项目生成的临时二进制目录，用于存放配置/编译中间文件。</li></ul></li></ul></li><li>add_library：生成库文件<ul><li>add_library(libname [SHARED|STATIC|MODULE][EXCLUDE_FROM_ALL] source)<ul><li>libname： 库名称</li><li>source：源文件，可以使用列表变量，也可以直接添加源文件名称，还可以使用函数 target_source 添加源文件</li><li>SHARED：声明该库仅被作为动态库生成</li><li>STATIC 声明该库仅被作为静态库生成</li></ul></li></ul></li><li>add_executable：生成可执行文件<ul><li>add_executable(exename source)</li></ul></li></ul><h2 id="生成项目">生成项目</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">cmake -G <span class="hljs-string">&quot;Unix Makefiles&quot;</span> ..<br>make<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cmake.exe -S .<span class="hljs-regexp">/sample -B ./</span>sample/binary -G <span class="hljs-string">&quot;Visual Studio 16 2019&quot;</span> -A x64<br>cmake.exe --build .<span class="hljs-regexp">/sample/</span>binary<br></code></pre></td></tr></table></figure><h3 id="命令行参数">命令行参数</h3><ul><li>-S 顶级CMakeLists.txt（包含project声明）所在路径。</li><li>-B 存放临时编译的二进制文件（.obj、.ilk等）和编译器对应的配置文件路径。</li><li>-G 编译器名称</li><li>-A 架构名称</li><li>-D 使用该变量以向cmake传入各种参数，包括选项及覆盖cmake提供的各种默认变量值。</li><li>--toolchain cmake toolchain文件路径。</li><li>--install-prefix 安装的二进制存放路径。</li><li>--trace / --trace-expand 调试时使用，用于打印已执行的cmake代码及行号。否则仅输出函数message中的内容。</li><li>--build 使用cmake直接调用编译器编译项目。</li><li>--config 选择需要编译的项目配置类型。</li><li>--install 安装已编译好的二进制文件至 CMAKE_INSTALL_PREFIX 中。</li></ul><h1 id="依赖管理">依赖管理</h1><h2 id="查找依赖">查找依赖</h2><ul><li><p><a href="https://link.zhihu.com/?target=https://cmake.org/cmake/help/latest/command/find_package.html#id7">find_package</a>：使用预先设置的配置文件来查找依赖项 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs inform7">find_package(PACKAGE_NAME_CASE_SENSITIVE<br>             <span class="hljs-comment">[version]</span> <span class="hljs-comment">[EXACT]</span> <span class="hljs-comment">[QUIET]</span><br>             <span class="hljs-comment">[REQUIRED]</span> <span class="hljs-comment">[<span class="hljs-comment">[COMPONENTS]</span> <span class="hljs-comment">[components...]</span>]</span><br>             <span class="hljs-comment">[OPTIONAL_COMPONENTS components...]</span><br>             <span class="hljs-comment">[CONFIG|NO_MODULE]</span><br>             <span class="hljs-comment">[NO_POLICY_SCOPE]</span><br>             <span class="hljs-comment">[NAMES name1 <span class="hljs-comment">[name2 ...]</span>]</span><br>             <span class="hljs-comment">[CONFIGS config1 <span class="hljs-comment">[config2 ...]</span>]</span><br>             <span class="hljs-comment">[HINTS path1 <span class="hljs-comment">[path2 ... ]</span>]</span><br>             <span class="hljs-comment">[PATHS path1 <span class="hljs-comment">[path2 ... ]</span>]</span><br>             <span class="hljs-comment">[PATH_SUFFIXES suffix1 <span class="hljs-comment">[suffix2 ...]</span>]</span><br>             <span class="hljs-comment">[NO_DEFAULT_PATH]</span><br>             <span class="hljs-comment">[NO_PACKAGE_ROOT_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_ENVIRONMENT_PATH]</span><br>             <span class="hljs-comment">[NO_SYSTEM_ENVIRONMENT_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_PACKAGE_REGISTRY]</span><br>             <span class="hljs-comment">[NO_CMAKE_BUILDS_PATH]</span> # Deprecated; does nothing.<br>             <span class="hljs-comment">[NO_CMAKE_SYSTEM_PATH]</span><br>             <span class="hljs-comment">[NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]</span><br>             <span class="hljs-comment">[CMAKE_FIND_ROOT_PATH_BOTH |</span><br><span class="hljs-comment">              ONLY_CMAKE_FIND_ROOT_PATH |</span><br><span class="hljs-comment">              NO_CMAKE_FIND_ROOT_PATH)</span><br></code></pre></td></tr></table></figure></p><p>常用参数：</p><ul><li>PACKAGE_NAME_CASE_SENSITIVE 查找的库的名称，大小写敏感，与之对应的是调用了包含此名称的配置文件。</li><li>version 依赖的版本号。如果依赖的配置同时提供了版本文件，则会使用该值对比配置中的版本而确定是否可以使用。</li><li>EXACT 版本号必须严格对应配置中的版本号。</li><li>QUIET 关闭了查找信息（不包含查找失败/错误信息）的输出。</li><li>REQUIRED 如果库没找到就报错。</li><li>CONFIG 该关键字声明了需要使用 依赖项通过自己的cmake代码 使用cmake 自动生成的 配置文件，入口配置文件名称一般为 <LOW_CASE_PACKAGE_NAME>-config.cmake 或 <ALL_CASE_PACKAGE_NAME>Config.cmake 。</li></ul></li><li><p>find_library：原始的cmake查找依赖方式，直接查找依赖项库文件。 <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog">find_library (<br>          &lt;<span class="hljs-symbol">LIBRARY_NAME</span>&gt;<br>          name | <span class="hljs-symbol">NAMES</span> name1 [name2 ...] [<span class="hljs-symbol">NAMES_PER_DIR</span>]<br>          [<span class="hljs-symbol">HINTS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>          [<span class="hljs-symbol">PATHS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>          [<span class="hljs-symbol">PATH_SUFFIXES</span> suffix1 [suffix2 ...]]<br>          [<span class="hljs-symbol">DOC</span> <span class="hljs-string">&quot;cache documentation string&quot;</span>]<br>          [<span class="hljs-symbol">NO_CACHE</span>]<br>          [<span class="hljs-symbol">REQUIRED</span>]<br>          [<span class="hljs-symbol">NO_DEFAULT_PATH</span>]<br>          [<span class="hljs-symbol">NO_PACKAGE_ROOT_PATH</span>]<br>          [<span class="hljs-symbol">NO_CMAKE_PATH</span>]<br>          [<span class="hljs-symbol">NO_CMAKE_ENVIRONMENT_PATH</span>]<br>          [<span class="hljs-symbol">NO_SYSTEM_ENVIRONMENT_PATH</span>]<br>          [<span class="hljs-symbol">NO_CMAKE_SYSTEM_PATH</span>]<br>          [<span class="hljs-symbol">CMAKE_FIND_ROOT_PATH_BOTH</span> |<br>           <span class="hljs-symbol">ONLY_CMAKE_FIND_ROOT_PATH</span> |<br>           <span class="hljs-symbol">NO_CMAKE_FIND_ROOT_PATH</span>]<br>         )<br></code></pre></td></tr></table></figure></p><ul><li>LIBRARY_NAME：由于直接查找库文件而不是查找配置文件，此名称仅作为结果中宏的前缀使用。</li><li>NAMES：此项声明了库文件的名称。值得注意的是，在UNIX-style系统中，自动添加“lib”作为库名称的前缀。</li><li>NAMES_PER_DIR：一个名称遍历查找一次，再用另一个名称遍历查找一次。而不是根据路径使用多个名称遍历。</li><li>查找完成后：<ul><li>如果查找到，则会设置 LIBRARY_NAME 为查找到的库文件的名称（包含全路径）。</li><li>如果没有查找到，则会将 LIBRARY_NAME 设置为 <LIBRARY_NAME>-NOTFOUND 。</li></ul><p>所以这里和 find_package 又有不同，我们应当使用以下代码判断是否查找到:</p><p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">PACKAGE_NAME</span> <span class="hljs-variable">MATCHES</span> <span class="hljs-string">&quot;-NOTFOUND&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-title">message</span>(<span class="hljs-variable">FATAL_ERROR</span> <span class="hljs-string">&quot;$&#123;PACKAGE_NAME&#125; not found!&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-title">endif</span>()</span><br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>find_path：这个函数一般是查找头文件或其他的 非库文件 且 非可执行程序。其函数原型为： <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog">find_path (<br>         &lt;<span class="hljs-symbol">FILE_NAME</span>&gt;<br>         name | <span class="hljs-symbol">NAMES</span> name1 [name2 ...]<br>         [<span class="hljs-symbol">HINTS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>         [<span class="hljs-symbol">PATHS</span> [path | <span class="hljs-symbol">ENV</span> var]... ]<br>         [<span class="hljs-symbol">PATH_SUFFIXES</span> suffix1 [suffix2 ...]]<br>         [<span class="hljs-symbol">DOC</span> <span class="hljs-string">&quot;cache documentation string&quot;</span>]<br>         [<span class="hljs-symbol">NO_CACHE</span>]<br>         [<span class="hljs-symbol">REQUIRED</span>]<br>         [<span class="hljs-symbol">NO_DEFAULT_PATH</span>]<br>         [<span class="hljs-symbol">NO_PACKAGE_ROOT_PATH</span>]<br>         [<span class="hljs-symbol">NO_CMAKE_PATH</span>]<br>         [<span class="hljs-symbol">NO_CMAKE_ENVIRONMENT_PATH</span>]<br>         [<span class="hljs-symbol">NO_SYSTEM_ENVIRONMENT_PATH</span>]<br>         [<span class="hljs-symbol">NO_CMAKE_SYSTEM_PATH</span>]<br>         [<span class="hljs-symbol">CMAKE_FIND_ROOT_PATH_BOTH</span> |<br>          <span class="hljs-symbol">ONLY_CMAKE_FIND_ROOT_PATH</span> |<br>          <span class="hljs-symbol">NO_CMAKE_FIND_ROOT_PATH</span>]<br>        )<br></code></pre></td></tr></table></figure> 一般情况下，由于需要cmake表达式来让cmake判断使用哪个配置的库，我们通常这么写：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">find_path</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;_INCLUDE_DIR NAMES header.h PATH_SUFFIXES include/...)</span></span><br><br><span class="hljs-function"><span class="hljs-title">find_library</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;_LIBRARY_RELEASE NAMES name1 name2)</span></span><br><span class="hljs-function"><span class="hljs-title">find_library</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;_LIBRARY_DEBUG NAMES name1d name2d)</span></span><br><span class="hljs-function"><span class="hljs-title">select_library_configurations</span><span class="hljs-params">(&lt;PACKAGE_NAME&gt;)</span></span><br>...<br>target_*(target_name $&#123;&lt;PACKAGE_NAME&gt;&#125;)<br></code></pre></td></tr></table></figure></li><li><p>find_program：这个函数专门用于查找可执行程序</p></li></ul><h2 id="使用依赖">使用依赖</h2><p>经过了上面的狂轰乱炸，我们终于可以使用依赖项了。我们可以将查找到的依赖项用于多个函数中，例如添加头文件路径，添加链接库，添加编译选项等。</p><p>对于不同的查找方式，配置文件或cmake提供了不同的使用方式：</p><ul><li><p>宏 例如 <PACKAGE_NAME>_INCLUDE_DIRS 和 <PACKAGE_NAME>_LIBRARIES 这种方式。</p><p>对于头文件来讲，直接加到include_directories中就好了。而对于库来讲，则复杂点：</p><p>由于不能混合使用debug库及release库，cmake必须明确知道在不同配置下使用哪个库。所以宏中一般使用到了cmake表达式来处理这种情况，比如： <span class="math inline">\(&lt;\)</span><CONFIG:DEBUG>:library.lib&gt; <span class="math inline">\(&lt;\)</span>{NOT:$<CONFIG:DEBUG>&gt;:libraryd.lib&gt; 所以我们在写配置时，尽量将debug和release库均查找后使用 select_library_configurations 来生成表达式以便不同配置下使用。</p></li><li><p>target target 就简单的多了，因为它是一个object，cmake函数可以轻松提取 target 包含的需要使用的属性来使用。 当然，target 包含非namespace与namespace两种形式，不过使用上没区别。 ## 内部依赖</p></li><li><p>add_dependencies： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_dependencies(&lt;<span class="hljs-params">target</span>&gt; [&lt;<span class="hljs-params">target</span>-<span class="hljs-params">dependency</span>&gt;]<span class="hljs-operator">...</span>)</span><br></code></pre></td></tr></table></figure> 向前者添加依赖项（后者），可以添加多个。在编译或某些配置时，优先处理后者。</p></li></ul><h1 id="编译相关函数">编译相关函数</h1><h2 id="关键字">关键字</h2><ul><li><p>target target在cmake中是一个很重要的概念，可以理解为一个实例化对象， 一般是由add_executable()，add_library() 或 add_custom_target() 命令之一创建，它包含了例如以下内容：</p><ul><li>相关的源文件列表</li><li>相关的编译选项</li><li>相关的依赖库</li><li>相关的头文件路径列表</li><li>相关的库文件路径列表</li><li>相关的其他属性</li></ul></li><li>PUBLC PRIVATE INTERFACE 例如 target_link_libraries(A [PUBLIC/PRIVATE/INTERFACE] B)<ul><li>PUBLIC 依赖项B仅链接到目标A，若有C链接了目标A，C不链接依赖项B。</li><li>PRIVATE 依赖项B并不链接到目标A，若有C链接了目标A，C会链接依赖项B。</li><li>INTERFACE 依赖项B链接到目标A，若有C链接了目标A，C也会链接依赖项B。 &gt; <a href="https://www.jianshu.com/p/07761ff7838e">CMake 中的 PUBLIC，PRIVATE，INTERFACE</a></li></ul></li></ul><h2 id="相关函数-1">相关函数</h2><ul><li><p>target_compile_options：向目标添加编译选项 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_compile_options(&lt;<span class="hljs-keyword">target</span>&gt; [BEFORE]<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_compile_options(<span class="hljs-params">sample</span> PUBLIC <span class="hljs-operator">/</span><span class="hljs-params">arch</span>=<span class="hljs-params">avx2</span> <span class="hljs-operator">/</span>Wall)</span><br></code></pre></td></tr></table></figure></p></li><li><p>target_compile_definitions：向目标添加预设宏声明及定义</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_compile_definitions(&lt;<span class="hljs-keyword">target</span>&gt;<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">target_compile_definitions</span><span class="hljs-params">(sample PRIVATE BUILD_DLL PUBLIC <span class="hljs-string">&quot;-DPI=3.14159&quot;</span>)</span></span><br></code></pre></td></tr></table></figure></li><li><p>target_include_directories：声明了编译目标时查找使用头文件的路径。</p><p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_include_directories(&lt;<span class="hljs-keyword">target</span>&gt; [SYSTEM] [AFTER|BEFORE]<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure></p>例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_include_directories(<span class="hljs-params">sample</span> PUBLIC <span class="hljs-params">public</span><span class="hljs-operator">/</span><span class="hljs-params">include</span><span class="hljs-operator">/</span><span class="hljs-params">sample</span> PRIVATE <span class="hljs-params">sample</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>target_link_libraries：声明了链接时需要参与的依赖库名称或target，其名称可包含完整路径。</p><p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_link_libraries(&lt;<span class="hljs-keyword">target</span>&gt;<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">sample</span> PUBLIC CURL::<span class="hljs-params">curl</span> <span class="hljs-params">glib</span> <span class="hljs-params">m</span>)</span><br></code></pre></td></tr></table></figure> 注意：由于一个target中包含多个属性，一般情况下包含了头文件路径。所以使用target作为参数传入此函数时，无需调用 target_include_directories 再次声明添加头文件路径。</p></li><li><p>target_link_libraries：声明了链接时查找依赖库的路径。 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">target_link_libraries(&lt;<span class="hljs-keyword">target</span>&gt; [BEFORE]<br>  &lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items1...]<br>  [&lt;<span class="hljs-keyword">INTERFACE</span>|<span class="hljs-keyword">PUBLIC</span>|<span class="hljs-keyword">PRIVATE</span>&gt; [items2...] ...])<br></code></pre></td></tr></table></figure> 例如： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">sample</span> PUBLIC <span class="hljs-params">third_party</span><span class="hljs-operator">/</span><span class="hljs-params">libs</span><span class="hljs-operator">/</span><span class="hljs-params">x86</span><span class="hljs-operator">/</span><span class="hljs-params">rel</span>)</span><br></code></pre></td></tr></table></figure></p></li></ul><h2 id="target族函数注意事项">target族函数注意事项</h2><p>当需要使用cmake export关键字导出声明的target并附带其中的 PUBLIC 属性时，我们必须 将PUBLIC / PRIVATE / INTERFACE 关键字向这类 target 族函数补齐。且如果一个 target 族函数声明了这三个关键字其中之一，该 target 所属的其他 target 族函数均应当声明关键字。且对于包含路径的值，我们需要声明此值的使用范围：</p><p>编译/链接时使用。必须使用绝对路径。 导出以向下游提供。必须使用相对路径。 所以，我们通常情况下使用以下方式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">target_include_directories(sample <span class="hljs-variable constant_">PRIVATE</span> <span class="hljs-variable">$&lt;</span><span class="hljs-variable constant_">BUILD_INTERFACE</span><span class="hljs-symbol">:</span><span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">CMAKE_SOURCE_DIR</span>&#125;/header/<span class="hljs-keyword">include</span>&gt; <span class="hljs-variable constant_">PUBLIC</span> <span class="hljs-variable">$&lt;</span><span class="hljs-variable constant_">INSTALL_INTERFACE</span><span class="hljs-symbol">:include&gt;</span>)<br></code></pre></td></tr></table></figure><h1 id="reference">Reference</h1><p><a href="https://www.zhihu.com/column/c_1490802622991306752">CMake教程系列</a></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C/C++</category>
      
      <category>CMake</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Academic Writing</title>
    <link href="/Research/Academic-Writing/Effective%20Academic%20Writing/"/>
    <url>/Research/Academic-Writing/Effective%20Academic%20Writing/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="884eb34aa131356643002d0cd5f5394ddc245abd3d301c7f73327a88f55c0138">4630436162ade97ba2718b7d0c4b3b6376f3306e7b9798bdbcb35e81f16aa19b0645320c632847b028c3598cd6616474b46847a04718e53a8112e5f830a8601402ac7c967a18b3f2c246eb0842b3f1834dcd342e58490f5f43bb9235f219e267c2057d968dc7f9f0c13f4da67311d41d6307b40c73edf852f5130449a36972a60c4f3027ea91ae6eb486c7e688ec83d5217ee00edaacb992b47c85caca964b868c2a11ebe6995a3a9dc6e9eb096384f2bc7e3a896140b5196286ea0b5488fc7b82565e00dde5f228946a2bc1646740a85c83d258bcc9c9e1336a05e162b61f643a23c6918fe92d7b29f688ac06e493f91ab4593fe200b362628211b6e846b800c9c248fe44c53ff2667764aab91272eee93ce7b5095d64fca552631a8011710303bf6c16305ccf6fc83e7a5ff6b87a3e88daa2ca433105897a84f7784d9d7a1b295007504ba39fa4bc3a91a16c14b55cb2a057f88d8b416577972886b38af0b647033bc4e820138c7f8e97078ef12dd082c497da4ecbc07f15aae90f07969306c6e2ef2a46020f4350ab537820fbdc6fe370536ff12094d18ed90b2b56b89bc44ef82e716a1fab0aa5fa996b922c32cf3de91bed20d7f957d58bdbcb83889c89fdad2dac4c6fa69f894d9ca6731aef0993bdaca2aa3571235ba900e2aec284c7dfa47f1001e728c6119a7c511cfb18e15ae0c5eb4ea796b59b4cedd7d1d8dce50f827bbeb89877010bf9fd6228545161b273ce998ae8439c0232480fc54a8b83fc13955c892b122bcbc0979e4134eb5979d73e949bd3296db0b0603fcf7cb3aba716edf2d59ddcab5097613582a255e1d276de91fd368bbee7fc36e744f81b44faa9f9d01b4778ec80aa12b36733f392d0e8a285ca4b815261ff8eb5e52f7a1c2c5bb636aed8046008424b281fed923e0ed8767e0b747022bd9e84f37a98382c22c2e71a27bf48cbd983e4f11cd647a8ef8551cb2420275c644215ce3047884884708b0dea219e06e6b5686e63263423532963d145cc7681e075a275045f2d431a7f0c14a6c89b11c09834f2add1f8b357f093a3d65b9586276b2d1a0f978dcaa075ebfc73149c2fcb7dd42c0d98084db4124f63215ab5322e3f35a7b87acbcaa51d600b4952cf77d8b153b272ed51690be4a1fc2c05c2555455e4b48043a99f65b2a473827a7f8c9391b6cd9bc065ac47456e19adf238bc1523a88845b1bb8d0bcba6c5920703e666c84baf56175185e5394f5416a3a61524f6f6eeaffa0a10d3ec4130ed5bcb2f4ecd0035dc55368e56be470976013ffd2021647b72f0f03a11216815b104582c39ea319dea2e0e122eaebef6ad2e7eb64da008e9f46a3135ffd1f8afcc9370c67a4a7b36b19e0c41134a5d9eb436893c3befe20ee158c7599ef09f5be1fe2c813e46fd098d5b3d58010981bfb65724925568b03241a6700112f5309a2fb697ca6feae78763eb6ce007f58584bc427cf36e40fb73b52d368d42e750907a45e2c278d0706fdc3d58a3b80957fb1db474fb6bcb792b8eefe8937ed647b41505dbfa76faf4ebc7659a25c8a8933a6325519279482f7cb912afc0f54aac82131055ba630f78dbd03523379b516351698e6bf4fc9caa8ff981c2f3b546f4f205191f65074c34bcfd56cd2cb156c082cf2ddf7b531d433d743e98f01e239a00688c89b2badbacaf643c282cd1edffd79b416cfa72f76935893a1cd737eb14afcbe3b77820920526d6a561a80e9882e5abd5aaec8446d33a82aaeb1f136ff13ccb2ebceb986f205c02f72d6d72bf9ac567e9dbd3cbf88b5288fb10503630d78154078616f21eca79a735b0180930aa718f1ac16fd05bceca0b57e328ca484b437190663cac2c1e150537f4702c2bd4fbad4956b466ae864e9668cf74af991e24b6e6ab8d56cbb28fa33d59f5e0335e166b2be064c69ba17695d15ce6add2f0421fd821f91a4c0e8bd7060d31d3486dbe4c44ad3dc3c0a0249398a735522bb44faa8c39ae87ec82c710d84585d59e5b45818e14c80b09a384220000a941ffb87c25545f14fd8f960194c1cca76977213d859ce816355c45a955a0cd590a9284f534c48ad88e0d1879fafcd48a4f8ae432eaec7855030c17e8815483d41df9070775b4644d1ef162001ada1c03d3b624040a9ff382803fbd14d2070813a38c5080bc8f2c077d51532c9a45aacc508f24d29edf97659e01c33c9e1eef91d97fcad8e73b9461cccfccefb9308451791e33a0b001e2d6a60fc070589b856cf0327b83c246d371afd2be783c9a3cf826bdffc5c4c5a3b1cbc1dc8ee051068f26f4a633e4530418534295dc339896d5000d14d66141455fb260e5c0c9ef4960a1e0fa8f14b1dcdcab0a948ebf5c319b4e7c77bf11903b897ca59edd0d7307c3afc3dd22678b2627c4d2e1d236d601c1a2ea927540c994317ce04377843fa3a10201a32dee352e7327db229a7161ec3d2fc4111175ce355290af2db716ed1c5a5ee07ec91e8d6da8bfd8c8dc4743e48929f9fa6bf1ac482116cd04402c42f02e4af8c980a33b8b2cc7f80dde4276257a0ec29e349f959af3fe4c068fa84bfd60b54a509db9f00b9d6d212475613f7cebb0688a03bd73b92a47c4838f4f1031f7a476da37cd6c684c0066022edb690ca7cafcd6e7e5ef7d77be1370411ff74cbad329f0effd1a4adb4e687a21c4bc315830f9c56e9d930f02cac1a0cf448cce4fd8e0c7b86b3c374314f9840dd34c4d2579590fa9e978996d4995237dbbd33221c255d71ab94cd01a9768a40105273cd38c9da308e7b39b95146ec53d8a07a2fed15a7aa83dbad116ecf3f4ce8509f6aafe0646d06708f3077985bffab2c470eea3eab98848fe1cb1ffe83484d7697da9c3d7b5fb534be5bafd059f5ef6efafbcc0641429cf8dab809e188b0d6f266cdf4e69240c4666e9b9ae46b1ecce232dfe8f11a6e152556efdbe02cc1933652412c9b3b504371b2a83969dcd69ade13fdee569233f03e8843d24b2ccf97e2f17c8974ef45abfb0b6af08c89705204d7b4c4cea26a2dc3879c64cac84540cf114a428c9e35f7672d9c8d3d1d925da86277975089c7ddba7ceabba2625a1868f9cd19a9d4babdc1eb28828e6a0e1d00aff02014d519f9a88fff7cf6c753f9c70098aab988672eb2db2e64bafb977d16514046e50dd055aef45b32a79ec4b640706a0834a4c4cdfa5aacc91ab49478e890e2a44c2bdb5ed6242fa9f06e6061afef5aed1eccd2f12d6a846f1c833df7c7059bd271b1936352f98b57a7ef13dffe97b3fc808279a26f9e71e171ada71162aaeb8648d20db6fcbd04d57db2e7fa8c3aa4d60710ddc0fbdb5f6c6268c007659a1c2d001565d8da7ae0bedb9949a55032e639eb0c90007d5036fde75835150ab5d73f7f2fbb8967941e11e01df648728d86ddff782a5264062832823849ab84de4c5a2c11784e33a3f884c40a1262b89eed302689e4b31c0933850a68f443bab26b2e5d9c21d3f7df3080f6ef59a680befe584bb9ccb92065f8817ae6665f82b57a6ab927c5fe99dfed3086479ffac6ef7d6094885426458cf1baba9ff58c429d0f541e5d8ee781d424a9651446ed95f477b19f5045e002e6229383489d505d554f59b2c34c50d1c1c959134d0fb65a620494a903640dc8a68360faa94daad34698e8b6742cefc79a5edbb4488a5c57b2de18aa2805d974b01eeae4a89fdd3a2eb90463148a8627dfa1f80adfec7d49a22d9d49ca40b51eddb4412b8242d1d2a9ec3e08b4b5f23b087750fc6a57e2463056578c440fd9a464f6c93b532540b8fc457a1438d3b0b0dfb12c7b374076238aa74554a8b0a768f65c3fa9f631d965198d3ef92e6338f5e3a85da00ecaf7ca079ab1114e19784923bdb5ce364820c04d02f27f7921b977f8e4ec78f3526fe5cdaa839be7f99f1bf425e6c5f1ab5c49c19d59332fbc31c1250effbbb9440f58860fb04fabcbfa10b496744434c25be3b30112069aa70cb89d47162897194f483aea7274248ee3562b78c258ec940c42832fd883fb180657c6c25c5b260953681254c2c69acb99b973ed0642f50bd8d546ac3662822227bae7d0b23683b23ac006bee519ad90e1f8fb955512602b5e63d426e1fdd0b25f8b5dc1bcf6ad69a2562542f6b6a8fa2c3f52e5adf334149c933b31d330cfa80930f96610c08469cf933bbd514c5e60d8625b0c067f17ae3cb0df5323989a3093e8e03d688d0e39cbf4912a5c15afda6bffc4600ec087d45f412bb0baf110a1316d8d112174612565dc6958409c199e9dbabd106fd15e3dc682be7506fd0a17904ecf29fed4fbb707afefc9238147180ab8babd06cd109bf9052ddb1a41b4546602794ab3e716ebbec68764abf0efc6772644bb707ed19b6a8f3e6ae55689bca17b2f3ade7aa1b621f7815a574753fcf6cebf36c7faad4d35adc02067c5542bd1fc5fa204f8b4e05b5db4b24a039addac7334bca3672185e4347a1edd597e041c22101370b69d8a009d1c2807557d2e8eddacb203fb1b65d57b65ec76812aac495955d815b828a19a8ea28eb688faa3174e353469dcd6a798ba251ac8bcb859d0a3186d894c37a458bd5900b64032619e6b90ca6fc50d1c02871e93f1fd2ef04867e94729336093e957565833e2378acdde413d3809f80dd8926722e40802071a075d821193854f8a6897e1b755fd3c2df4c48c835d661b8cef3951fd2f9332ee372c7a73f9b5169637f27323de587c244ccbb74496d7858fa6615a2ccf8ffd1f275af2c2676b5a690a45f11713dc359b265b5becc77e5bd81bbc882497bd87ea0ae4036e7a839b63109ed36070b3f288d22a7ee92cc3abda2a590c0748c829dff9c7aafbf67141c79473073b49125dfbe0a49b61784b32bef59e29bd4a981c6e0005abc21a5707fd1ec1985ec05a32c4609ec9aca814c9a33e0a1f998040286b4791dbd19e14ffba621d3beed50c2e52e489d5fa59331a32a980a3e5d170e8399e5b1587a184d7581d40563d2a2a78483bcde61aa70d9124b4666f967dce66308d1650e83779bc2ca30a40fcb08460626309bb8579f7294774ee3cd724c8d1627c3c8bd61b633db93913c78bd2ae7f4c4e127d5059426b99f436e5fbfe0aaea91429a3e719729bdcde0de370a79319468490f0f0faa5cc3d48ebe29e45270b9510eb1aea434d21395eba8d7087f7ba130b9ee3b90168da40ff2f2007c57319c2c89d51766391d4d4ea6b382d8b1e7de01c6f9dbc722da2677a5092c01130803f914cb588f9edae85bae01828d474ad178f7db211dd09bb69a1b2a14985abd6442874ebf661b6a9af3f45d1526e46b6c5015e6404f6937583ceb268928d57a07a9590a5840ca01d1bc47388dbf65cae8c5633384a61f747b3e372ddcba14a3881896b7d9bb60a4a606d86f015d66c3f7271adf1d39b908412155b13f0fadab002cf994ac3ec3840ccf1533d4367aa2e2ecfd9feb94d648e19758ab733b4151006df010b093bb80f412c33d85568af416865921455d18f8a326fb7eb0d8ead24a6a7780acd65e304d1002cbc783e4b54ff3a4cd62cd4e6e55297b98d7762636b6ce430f82e8c67af0fb2f241e4636108c13b8396c3da53304d1415266cab311d799aff31833562ddfb08e970d4caea0428a41bb6f0167dbe7918260b1c5af5046e1bf7f1d75f98379918b08b58d9ed026f16f6dde5a9fe5513c9d6e213eb1cef2b7ce3a59c40d24799c8bf51fd9b7083dffd5184bb49457ce7c4e0fe0a60a404da7b834e563b725efa0bfd93dba180d446bbf83ec88676b88dc98683f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my blog, enter password to read.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Academic Writing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dive into DL</title>
    <link href="/Programming/DL/Dive%20into%20DL/"/>
    <url>/Programming/DL/Dive%20into%20DL/</url>
    
    <content type="html"><![CDATA[<p><a href="https://chenxindaaa.com/Programming/DL/PyTorch/Dive%20into%20DL-Linear%20Regression/">Linear Regression</a></p><p><a href="https://chenxindaaa.com/Programming/DL/CV/Dive%20into%20DL-Softmax%20Classification/">Softmax Classification</a></p><p><a href="https://chenxindaaa.com/Programming/DL/CV/Dive%20into%20DL-Multilayer%20Perceptron/">Multilayer Perceptron</a></p><p><a href="https://chenxindaaa.com/Programming/DL/NLP/Dive%20into%20DL-Text%20Prepare/">Text Prepare</a></p><p><a href="https://chenxindaaa.com/Programming/DL/NLP/Dive%20into%20DL-Language%20Model/">Language Model</a></p><p><a href="https://chenxindaaa.com/Programming/DL/NLP/Dive%20into%20DL-Recurrent%20Neural%20Network/">Recurrent Neural Network</a></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>DL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dive into DL</title>
    <link href="/Programming/DL/Leetcode/"/>
    <url>/Programming/DL/Leetcode/</url>
    
    <content type="html"><![CDATA[<p><a href="https://chenxindaaa.com/2020/02/14/Dive%20into%20DL-Linear%20Regression/">Linear Regression</a></p><p><a href="https://chenxindaaa.com/2020/02/14/Dive%20into%20DL-Multilayer%20Perceptron/">Multilayer Perceptron</a></p><p><a href="https://chenxindaaa.com/2020/02/14/Dive%20into%20DL-Softmax%20Classification/">Softmax Classification</a></p><p><a href="https://chenxindaaa.com/2020/02/14/Dive%20into%20DL-Text%20Prepare/">Text Prepare</a></p><p><a href="https://chenxindaaa.com/2020/02/14/Dive%20into%20DL-Language%20Model/">Language Model</a></p><p><a href="https://chenxindaaa.com/2020/02/14/Dive%20into%20DL-Recurrent%20Neural%20Network/">Recurrent Neural Network</a></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>DL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dive into DL: Language Model</title>
    <link href="/Programming/DL/NLP/Dive%20into%20DL/Dive%20into%20DL-Language%20Model/"/>
    <url>/Programming/DL/NLP/Dive%20into%20DL/Dive%20into%20DL-Language%20Model/</url>
    
    <content type="html"><![CDATA[<h1 id="语言模型">语言模型</h1><p>一段自然语言文本可以看作是一个离散时间序列，给定一个长度为<span class="math inline">\(T\)</span>的词的序列<span class="math inline">\(w_1, w_2, \ldots, w_T\)</span>，语言模型的目标就是评估该序列是否合理，即计算该序列的概率：</p><p><span class="math display">\[P(w_1, w_2, \ldots, w_T).\]</span></p><p>本节我们介绍基于统计的语言模型，主要是<span class="math inline">\(n\)</span>元语法（<span class="math inline">\(n\)</span>-gram）。在后续内容中，我们将会介绍基于神经网络的语言模型。</p><h2 id="语言模型-1">语言模型</h2><p>假设序列<span class="math inline">\(w_1, w_2, \ldots, w_T\)</span>中的每个词是依次生成的，我们有</p><p>$$</p><p><span class="math display">\[\begin{align*}P(w_1, w_2, \ldots, w_T)&amp;= \prod_{t=1}^T P(w_t \mid w_1, \ldots, w_{t-1})\\&amp;= P(w_1)P(w_2 \mid w_1) \cdots P(w_T \mid w_1w_2\cdots w_{T-1})\end{align*}\]</span></p><p>$$</p><p>例如，一段含有4个词的文本序列的概率</p><p><span class="math display">\[P(w_1, w_2, w_3, w_4) =  P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_1, w_2) P(w_4 \mid w_1, w_2, w_3).\]</span></p><p>语言模型的参数就是词的概率以及给定前几个词情况下的条件概率。设训练数据集为一个大型文本语料库，如维基百科的所有条目，词的概率可以通过该词在训练数据集中的相对词频来计算，例如，<span class="math inline">\(w_1\)</span>的概率可以计算为：</p><p>$$</p><p>P(w_1) = </p><p>$$</p><p>其中<span class="math inline">\(n(w_1)\)</span>为语料库中以<span class="math inline">\(w_1\)</span>作为第一个词的文本的数量，<span class="math inline">\(n\)</span>为语料库中文本的总数量。</p><p>类似的，给定<span class="math inline">\(w_1\)</span>情况下，<span class="math inline">\(w_2\)</span>的条件概率可以计算为：</p><p>$$</p><p>P(w_2 w_1) = </p><p>$$</p><p>其中<span class="math inline">\(n(w_1, w_2)\)</span>为语料库中以<span class="math inline">\(w_1\)</span>作为第一个词，<span class="math inline">\(w_2\)</span>作为第二个词的文本的数量。</p><h2 id="n元语法">n元语法</h2><p>序列长度增加，计算和存储多个词共同出现的概率的复杂度会呈指数级增加。<span class="math inline">\(n\)</span>元语法通过马尔可夫假设简化模型，马尔科夫假设是指一个词的出现只与前面<span class="math inline">\(n\)</span>个词相关，即<span class="math inline">\(n\)</span>阶马尔可夫链（Markov chain of order <span class="math inline">\(n\)</span>），如果<span class="math inline">\(n=1\)</span>，那么有<span class="math inline">\(P(w_3 \mid w_1, w_2) = P(w_3 \mid w_2)\)</span>。基于<span class="math inline">\(n-1\)</span>阶马尔可夫链，我们可以将语言模型改写为</p><p><span class="math display">\[P(w_1, w_2, \ldots, w_T) = \prod_{t=1}^T P(w_t \mid w_{t-(n-1)}, \ldots, w_{t-1}) .\]</span></p><p>以上也叫<span class="math inline">\(n\)</span>元语法（<span class="math inline">\(n\)</span>-grams），它是基于<span class="math inline">\(n - 1\)</span>阶马尔可夫链的概率语言模型。例如，当<span class="math inline">\(n=2\)</span>时，含有4个词的文本序列的概率就可以改写为：</p><p>$$</p><p><span class="math display">\[\begin{align*}P(w_1, w_2, w_3, w_4)&amp;= P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_1, w_2) P(w_4 \mid w_1, w_2, w_3)\\&amp;= P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_2) P(w_4 \mid w_3)\end{align*}\]</span></p><p>$$</p><p>当<span class="math inline">\(n\)</span>分别为1、2和3时，我们将其分别称作一元语法（unigram）、二元语法（bigram）和三元语法（trigram）。例如，长度为4的序列<span class="math inline">\(w_1, w_2, w_3, w_4\)</span>在一元语法、二元语法和三元语法中的概率分别为</p><p>$$</p><p>\begin{aligned} P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2) P(w_3) P(w_4) ,\ P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2 w_1) P(w_3 w_2) P(w_4 w_3) ,\ P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2 w_1) P(w_3 w_1, w_2) P(w_4 w_2, w_3) . \end{aligned}</p><p>$$</p><p>当<span class="math inline">\(n\)</span>较小时，<span class="math inline">\(n\)</span>元语法往往并不准确。例如，在一元语法中，由三个词组成的句子“你走先”和“你先走”的概率是一样的。然而，当<span class="math inline">\(n\)</span>较大时，<span class="math inline">\(n\)</span>元语法需要计算并存储大量的词频和多词相邻频率。</p><p>思考：<span class="math inline">\(n\)</span>元语法可能有哪些缺陷？</p><ol type="1"><li>参数空间过大</li><li>数据稀疏</li></ol><h1 id="语言模型数据集">语言模型数据集</h1><h2 id="读取数据集">读取数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/kesci/input/jaychou_lyrics4703/jaychou_lyrics.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    corpus_chars = f.read()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(corpus_chars))<br><span class="hljs-built_in">print</span>(corpus_chars[: <span class="hljs-number">40</span>])<br>corpus_chars = corpus_chars.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>)<br>corpus_chars = corpus_chars[: <span class="hljs-number">10000</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">63282想要有直升机想要和你飞到宇宙去想要和你融化在一起融化在宇宙里我每天每天每</code></pre><h2 id="建立字符索引">建立字符索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">idx_to_char = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(corpus_chars)) <span class="hljs-comment"># 去重，得到索引到字符的映射</span><br>char_to_idx = &#123;char: i <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(idx_to_char)&#125; <span class="hljs-comment"># 字符到索引的映射</span><br>vocab_size = <span class="hljs-built_in">len</span>(char_to_idx)<br><span class="hljs-built_in">print</span>(vocab_size)<br><br>corpus_indices = [char_to_idx[char] <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> corpus_chars]  <span class="hljs-comment"># 将每个字符转化为索引，得到一个索引的序列</span><br>sample = corpus_indices[: <span class="hljs-number">20</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;chars:&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>.join([idx_to_char[idx] <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> sample]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;indices:&#x27;</span>, sample)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1027chars: 想要有直升机 想要和你飞到宇宙去 想要和indices: [1022, 648, 1025, 366, 208, 792, 199, 1022, 648, 641, 607, 625, 26, 155, 130, 5, 199, 1022, 648, 641]</code></pre><p>定义函数<code>load_data_jay_lyrics</code>，在后续章节中直接调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data_jay_lyrics</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/kesci/input/jaychou_lyrics4703/jaychou_lyrics.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        corpus_chars = f.read()<br>    corpus_chars = corpus_chars.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>)<br>    corpus_chars = corpus_chars[<span class="hljs-number">0</span>:<span class="hljs-number">10000</span>]<br>    idx_to_char = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(corpus_chars))<br>    char_to_idx = <span class="hljs-built_in">dict</span>([(char, i) <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(idx_to_char)])<br>    vocab_size = <span class="hljs-built_in">len</span>(char_to_idx)<br>    corpus_indices = [char_to_idx[char] <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> corpus_chars]<br>    <span class="hljs-keyword">return</span> corpus_indices, char_to_idx, idx_to_char, vocab_size<br></code></pre></td></tr></table></figure><h2 id="时序数据的采样">时序数据的采样</h2><p>在训练中我们需要每次随机读取小批量样本和标签。与之前章节的实验数据不同的是，时序数据的一个样本通常包含连续的字符。假设时间步数为5，样本序列为5个字符，即“想”“要”“有”“直”“升”。该样本的标签序列为这些字符分别在训练集中的下一个字符，即“要”“有”“直”“升”“机”，即<span class="math inline">\(X\)</span>=“想要有直升”，<span class="math inline">\(Y\)</span>=“要有直升机”。</p><p>现在我们考虑序列“想要有直升机，想要和你飞到宇宙去”，如果时间步数为5，有以下可能的样本和标签： * <span class="math inline">\(X\)</span>：“想要有直升”，<span class="math inline">\(Y\)</span>：“要有直升机” * <span class="math inline">\(X\)</span>：“要有直升机”，<span class="math inline">\(Y\)</span>：“有直升机，” * <span class="math inline">\(X\)</span>：“有直升机，”，<span class="math inline">\(Y\)</span>：“直升机，想” * ... * <span class="math inline">\(X\)</span>：“要和你飞到”，<span class="math inline">\(Y\)</span>：“和你飞到宇” * <span class="math inline">\(X\)</span>：“和你飞到宇”，<span class="math inline">\(Y\)</span>：“你飞到宇宙” * <span class="math inline">\(X\)</span>：“你飞到宇宙”，<span class="math inline">\(Y\)</span>：“飞到宇宙去”</p><p>可以看到，如果序列的长度为<span class="math inline">\(T\)</span>，时间步数为<span class="math inline">\(n\)</span>，那么一共有<span class="math inline">\(T-n\)</span>个合法的样本，但是这些样本有大量的重合，我们通常采用更加高效的采样方式。我们有两种方式对时序数据进行采样，分别是随机采样和相邻采样。</p><h3 id="随机采样">随机采样</h3><p>下面的代码每次从数据里随机采样一个小批量。其中批量大小<code>batch_size</code>是每个小批量的样本数，<code>num_steps</code>是每个样本所包含的时间步数。 在随机采样中，每个样本是原始序列上任意截取的一段序列，相邻的两个随机小批量在原始序列上的位置不一定相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter_random</span>(<span class="hljs-params">corpus_indices, batch_size, num_steps, device=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-comment"># 减1是因为对于长度为n的序列，X最多只有包含其中的前n - 1个字符</span><br>    num_examples = (<span class="hljs-built_in">len</span>(corpus_indices) - <span class="hljs-number">1</span>) // num_steps  <span class="hljs-comment"># 下取整，得到不重叠情况下的样本个数</span><br>    example_indices = [i * num_steps <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_examples)]  <span class="hljs-comment"># 每个样本的第一个字符在corpus_indices中的下标</span><br>    random.shuffle(example_indices)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_data</span>(<span class="hljs-params">i</span>):<br>        <span class="hljs-comment"># 返回从i开始的长为num_steps的序列</span><br>        <span class="hljs-keyword">return</span> corpus_indices[i: i + num_steps]<br>    <span class="hljs-keyword">if</span> device <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_examples, batch_size):<br>        <span class="hljs-comment"># 每次选出batch_size个随机样本</span><br>        batch_indices = example_indices[i: i + batch_size]  <span class="hljs-comment"># 当前batch的各个样本的首字符的下标</span><br>        X = [_data(j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> batch_indices]<br>        Y = [_data(j + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> batch_indices]<br>        <span class="hljs-keyword">yield</span> torch.tensor(X, device=device), torch.tensor(Y, device=device)<br></code></pre></td></tr></table></figure><p>测试一下这个函数，我们输入从0到29的连续整数作为一个人工序列，设批量大小和时间步数分别为2和6，打印随机采样每次读取的小批量样本的输入<code>X</code>和标签<code>Y</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_seq = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>))<br><span class="hljs-keyword">for</span> X, Y <span class="hljs-keyword">in</span> data_iter_random(my_seq, batch_size=<span class="hljs-number">2</span>, num_steps=<span class="hljs-number">6</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;X: &#x27;</span>, X, <span class="hljs-string">&#x27;\nY:&#x27;</span>, Y, <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">X:  tensor([[ 6,  7,  8,  9, 10, 11],        [12, 13, 14, 15, 16, 17]]) Y: tensor([[ 7,  8,  9, 10, 11, 12],        [13, 14, 15, 16, 17, 18]]) X:  tensor([[ 0,  1,  2,  3,  4,  5],        [18, 19, 20, 21, 22, 23]]) Y: tensor([[ 1,  2,  3,  4,  5,  6],        [19, 20, 21, 22, 23, 24]]) </code></pre><h3 id="相邻采样">相邻采样</h3><p>在相邻采样中，相邻的两个随机小批量在原始序列上的位置相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter_consecutive</span>(<span class="hljs-params">corpus_indices, batch_size, num_steps, device=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> device <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br>    corpus_len = <span class="hljs-built_in">len</span>(corpus_indices) // batch_size * batch_size  <span class="hljs-comment"># 保留下来的序列的长度</span><br>    corpus_indices = corpus_indices[: corpus_len]  <span class="hljs-comment"># 仅保留前corpus_len个字符</span><br>    indices = torch.tensor(corpus_indices, device=device)<br>    indices = indices.view(batch_size, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># resize成(batch_size, )</span><br>    batch_num = (indices.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) // num_steps<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(batch_num):<br>        i = i * num_steps<br>        X = indices[:, i: i + num_steps]<br>        Y = indices[:, i + <span class="hljs-number">1</span>: i + num_steps + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">yield</span> X, Y<br></code></pre></td></tr></table></figure><p>同样的设置下，打印相邻采样每次读取的小批量样本的输入<code>X</code>和标签<code>Y</code>。相邻的两个随机小批量在原始序列上的位置相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> X, Y <span class="hljs-keyword">in</span> data_iter_consecutive(my_seq, batch_size=<span class="hljs-number">2</span>, num_steps=<span class="hljs-number">6</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;X: &#x27;</span>, X, <span class="hljs-string">&#x27;\nY:&#x27;</span>, Y, <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">X:  tensor([[ 0,  1,  2,  3,  4,  5],        [15, 16, 17, 18, 19, 20]]) Y: tensor([[ 1,  2,  3,  4,  5,  6],        [16, 17, 18, 19, 20, 21]]) X:  tensor([[ 6,  7,  8,  9, 10, 11],        [21, 22, 23, 24, 25, 26]]) Y: tensor([[ 7,  8,  9, 10, 11, 12],        [22, 23, 24, 25, 26, 27]]) </code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>DL</category>
      
      <category>PyTorch</category>
      
      <category>NLP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：235.二叉搜索树的最近公共祖先</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] <img src="https://img-blog.csdnimg.cn/201910081047296.png" alt="在这里插入图片描述" /></p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">输入: root = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,null,null,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], p = <span class="hljs-number">2</span>, q = <span class="hljs-number">8</span><br>输出: <span class="hljs-number">6</span> <br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">8</span> 的最近公共祖先是 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">输入: root = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,null,null,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], p = <span class="hljs-number">2</span>, q = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">2</span><br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是 <span class="hljs-number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure><p>说明:</p><pre><code class="hljs">所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。</code></pre><h2 id="算法实现递归">算法实现：递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root, p, q</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :type p: TreeNode</span><br><span class="hljs-string">        :type q: TreeNode</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> q.val &gt; root.val <span class="hljs-keyword">and</span> p.val &gt; root.val:<br>            <span class="hljs-keyword">return</span> self.lowestCommonAncestor(root.right, p, q)<br>        <span class="hljs-keyword">elif</span> q.val &lt; root.val <span class="hljs-keyword">and</span> p.val &lt; root.val:<br>            <span class="hljs-keyword">return</span> self.lowestCommonAncestor(root.left, p, q)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20191008105016397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：237. 删除链表中的节点</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A237.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A237.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>现有一个链表 -- head = [4,5,1,9]，它可以表示为: <img src="https://img-blog.csdnimg.cn/2019100823150952.png" alt="在这里插入图片描述" /></p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">输入: head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], node = <span class="hljs-number">5</span><br>输出: [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>]<br>解释: 给定你链表中值为 <span class="hljs-number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">9.</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">输入: head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], node = <span class="hljs-number">1</span><br>输出: [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]<br>解释: 给定你链表中值为 <span class="hljs-number">1</span> 的第三个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">9.</span><br></code></pre></td></tr></table></figure><p>说明:</p><p>链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。</p><h2 id="算法实现">算法实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">self, node</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type node: ListNode</span><br><span class="hljs-string">        :rtype: void Do not return anything, modify node in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        node.val = node.<span class="hljs-built_in">next</span>.val<br>        node.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20191008231649898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：238. 除自身以外数组的乘积</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A238.%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A238.%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出: [<span class="hljs-number">24</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">productExceptSelf</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        a = []<br>        temp = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            a.append(temp)<br>            temp *= i<br>        nums.reverse()<br>        temp = <span class="hljs-number">1</span><br>        count = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> nums:<br>            a[count] *= temp<br>            temp *= j<br>            count -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> a<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20191008231923887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：236.二叉树的最近公共祖先</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4] <img src="https://img-blog.csdnimg.cn/20191008105455457.png" alt="在这里插入图片描述" /></p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,null,null,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], p = <span class="hljs-number">5</span>, q = <span class="hljs-number">1</span><br>输出: <span class="hljs-number">3</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,null,null,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], p = <span class="hljs-number">5</span>, q = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">5</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure><p>说明:</p><pre><code class="hljs">所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。</code></pre><h2 id="算法实现递归">算法实现：递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root, p, q</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :type p: TreeNode</span><br><span class="hljs-string">        :type q: TreeNode</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">root, p, q</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">global</span> res<br>            left = helper(root.left, p, q)<br>            right = helper(root.right, p, q)<br>            current = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> root == q <span class="hljs-keyword">or</span> root == p:<br>                current = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> (left <span class="hljs-keyword">and</span> right) <span class="hljs-keyword">or</span> (left <span class="hljs-keyword">and</span> current) <span class="hljs-keyword">or</span> (right <span class="hljs-keyword">and</span> current):<br>                res = root<br>            <span class="hljs-keyword">return</span> left <span class="hljs-keyword">or</span> right <span class="hljs-keyword">or</span> current<br>        helper(root, p, q)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20191008105537111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：292. Nim 游戏</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A292.%20Nim%20%E6%B8%B8%E6%88%8F/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A292.%20Nim%20%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p><p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">输入: <span class="hljs-number">4</span><br>输出: false <br>解释: 如果堆中有 <span class="hljs-number">4</span> 块石头，那么你永远不会赢得比赛；<br>     因为无论你拿走 <span class="hljs-number">1</span> 块、<span class="hljs-number">2</span> 块 还是 <span class="hljs-number">3</span> 块石头，最后一块石头总是会被你的朋友拿走。<br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canWinNim</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> n % <span class="hljs-number">4</span> != <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20191008232204903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：344. 反转字符串</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]<br>输出：[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：[<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]<br>输出：[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: List[str]</span><br><span class="hljs-string">        :rtype: None Do not return anything, modify s in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        a = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            a.append(s.pop())<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> a:<br>            s.append(j)<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20191008232420239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：557. 反转字符串中的单词 III</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A557.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A557.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入: <span class="hljs-string">&quot;Let&#x27;s take LeetCode contest&quot;</span><br>输出: <span class="hljs-string">&quot;s&#x27;teL ekat edoCteeL tsetnoc&quot;</span> <br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        s = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            s[i] = <span class="hljs-built_in">list</span>(s[i])<br>            self.reverseString(s[i])<br>            s[i] = <span class="hljs-string">&#x27;&#x27;</span>.join(s[i])<br>        s = <span class="hljs-string">&#x27; &#x27;</span>.join(s)<br>        <span class="hljs-keyword">return</span> s<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">self, s</span>):<br>        a = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            a.append(s.pop())<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> a:<br>            s.append(j)<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20191008232704354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战215：数组中的第K个最大元素</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A215%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A215%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,2,3,1</span>,<span class="hljs-number">2,4,5,5</span>,<span class="hljs-number">6</span>] 和 k = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="算法实现提前终止的堆排序">算法实现：提前终止的堆排序</h2><p>再重建第k个堆后停止</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-comment">#堆排序</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        vcount = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((vcount + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            nums = self.restore(nums, i, vcount)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vcount, vcount - k, -<span class="hljs-number">1</span>):<br>            temp = nums[<span class="hljs-number">0</span>]<br>            nums[<span class="hljs-number">0</span>] = nums[i]<br>            nums[i] = temp<br>            nums = self.restore(nums, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> nums[-k]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">restore</span>(<span class="hljs-params">self, nums, j, vcount</span>):<span class="hljs-comment">#以j为根节点建堆</span><br>        <span class="hljs-keyword">while</span> j &lt;= ((vcount + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>):<br>            m = <span class="hljs-number">2</span> * (j + <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> * (j + <span class="hljs-number">1</span>) &lt;= vcount <span class="hljs-keyword">and</span> nums[<span class="hljs-number">2</span> * (j + <span class="hljs-number">1</span>)] &gt; nums[<span class="hljs-number">2</span> * (j + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">2</span> * (j + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> nums[j] &lt; nums[m]:<br>                temp = nums[j]<br>                nums[j] = nums[m]<br>                nums[m] = temp<br>                j = m<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20191004102224487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：231.2的幂</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A231.2%E7%9A%84%E5%B9%82/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A231.2%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">输入: <span class="hljs-number">1</span><br>输出: <span class="hljs-literal">true</span><br>解释: <span class="hljs-number">20</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">输入: <span class="hljs-number">16</span><br>输出: <span class="hljs-literal">true</span><br>解释: <span class="hljs-number">24</span> = <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">输入: <span class="hljs-number">218</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><p>如果n时2的幂 n &amp; (n - 1) == 0 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">class <span class="hljs-title function_">Solution</span><span class="hljs-params">(object)</span>:<br>    def <span class="hljs-title function_">isPowerOfTwo</span><span class="hljs-params">(self, n)</span>:<br>        &quot;&quot;&quot;<br>        :type n: <span class="hljs-type">int</span><br>        :rtype: <span class="hljs-type">bool</span><br>        &quot;&quot;&quot;<br>        <span class="hljs-keyword">return</span> n &amp; <span class="hljs-params">(n - <span class="hljs-number">1</span>)</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> n != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></p><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20191004105524292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：217.存在重复元素</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">class <span class="hljs-title function_">Solution</span><span class="hljs-params">(object)</span>:<br>    def <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(self, nums)</span>:<br>        &quot;&quot;&quot;<br>        :type nums: List[<span class="hljs-type">int</span>]<br>        :rtype: <span class="hljs-type">bool</span><br>        &quot;&quot;&quot;<br>        a = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> i in nums:<br>            <span class="hljs-keyword">if</span> i in a:<br>                <span class="hljs-keyword">return</span> True<br>            a.add(i)<br>        <span class="hljs-keyword">return</span> False<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20191004104016807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：230.二叉搜索树中第K小的元素</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A230.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A230.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p>说明： 你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><p>示例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,null,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span><br>   <span class="hljs-number">3</span><br>  / \<br> <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>  \<br>   <span class="hljs-number">2</span><br>输出: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">输入: root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,null,null,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span><br>       <span class="hljs-number">5</span><br>      / \<br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>    / \<br>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span><br>  /<br> <span class="hljs-number">1</span><br>输出: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><p>中序遍历搜索二叉树，在递归中找到第k小的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">class <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(object)</span>:<br>    def __<span class="hljs-title function_">init__</span><span class="hljs-params">(self, x)</span>:<br>        self.val = x<br>        self.left = None<br>        self.right = None<br><br>class Solution(object):<br>    def kthSmallest(self, root, k):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;</span><span class="hljs-string">&quot;&quot;</span><br>        global m<br>        m = k<br>        def helper(root):<br>            global m<br>            global res<br>            <span class="hljs-keyword">if</span> not root:<br>                <span class="hljs-keyword">return</span><br>            helper(root.left)<br>            m -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span>:<br>                res = root.val<br>            helper(root.right)<br>        helper(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20191004104853388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战160.相交链表</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表： <img src="https://img-blog.csdnimg.cn/20190929162255246.png" alt="在这里插入图片描述" /> 在节点 c1 开始相交。</p><p>示例1： <img src="https://img-blog.csdnimg.cn/20190929162325214.png" alt="在这里插入图片描述" /></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Reference of the node with value = <span class="hljs-number">8</span><br>输入解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p>示例2： <img src="https://img-blog.csdnimg.cn/20190929162428544.png" alt="在这里插入图片描述" /></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-keyword">Reference</span> of the <span class="hljs-keyword">node</span> <span class="hljs-title">with</span> value = <span class="hljs-number">2</span><br>输入解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。在 A 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p>示例3： <img src="https://img-blog.csdnimg.cn/20190929162514454.png" alt="在这里插入图片描述" /></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>输入解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 <span class="hljs-literal">null</span>。<br></code></pre></td></tr></table></figure><p>注意：</p><p>如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><h2 id="算法实现">算法实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">self, headA, headB</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head1, head1: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        a = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> headA <span class="hljs-keyword">and</span> headB:<br>            <span class="hljs-keyword">if</span> headB <span class="hljs-keyword">in</span> a:<br>                <span class="hljs-keyword">return</span> headB<br>            a.add(headB)<br>            <span class="hljs-keyword">if</span> headA <span class="hljs-keyword">in</span> a:<br>                <span class="hljs-keyword">return</span> headA<br>            a.add(headA)<br>            headA = headA.<span class="hljs-built_in">next</span><br>            headB = headB.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> headA:<br>            <span class="hljs-keyword">if</span> headA <span class="hljs-keyword">in</span> a:<br>                <span class="hljs-keyword">return</span> headA<br>            a.add(headA)<br>            headA = headA.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> headB:<br>            <span class="hljs-keyword">if</span> headB <span class="hljs-keyword">in</span> a:<br>                <span class="hljs-keyword">return</span> headB<br>            a.add(headB)<br>            headB = headB.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190929162757523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战169.众数</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A169.%E4%BC%97%E6%95%B0/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A169.%E4%BC%97%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p><p>示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,3]</span><br><span class="hljs-section">输出: 3</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1,1,1,2,2]</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">majorityElement</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">nums</span></span>):<br>        &quot;&quot;&quot;<br>        :<span class="hljs-symbol">type</span> <span class="hljs-symbol">nums: <span class="hljs-symbol">List</span></span>[<span class="hljs-symbol">int</span>]<br>        :<span class="hljs-symbol">rtype: <span class="hljs-symbol">int</span></span><br>        &quot;&quot;&quot;<br>        <span class="hljs-symbol">n</span> = <span class="hljs-symbol">len</span>(<span class="hljs-symbol">nums</span>) / <span class="hljs-symbol">2</span><br>        <span class="hljs-symbol">a</span> = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            a[i] = a.<span class="hljs-keyword">get</span>(i, <span class="hljs-number">0</span>)<br>            a[i] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> a[i] &gt; n:<br>                <span class="hljs-keyword">return</span> i<br></code></pre></td></tr></table></figure><h2 id="结果">结果:</h2><figure><img src="https://img-blog.csdnimg.cn/2019092916311678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：206.反转链表</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>反转一个单链表。</p><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br>输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL<br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><h2 id="方法一">方法一：</h2><p>把链表转成数组，再将数组翻转，最后将数组转成链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        a = []<br>        <span class="hljs-keyword">while</span> head:<br>            a.append(head.val)<br>            head = head.<span class="hljs-built_in">next</span><br>        a.reverse()<br>        res = temp = ListNode(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>            temp.<span class="hljs-built_in">next</span> = ListNode(i)<br>            temp = temp.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190929163635831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="方法二">方法二：</h2><p>利用递归将结点用栈的形式存储下来，再利用出栈将链表倒转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> head<br>        a = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">head</span>):<br>            <span class="hljs-keyword">global</span> x<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>                x = head<br>            a.append(head)<br>            helper(head.<span class="hljs-built_in">next</span>)<br>            temp = a.pop()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> a:<br>                temp.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">else</span>:<br>                temp.<span class="hljs-built_in">next</span> = a[-<span class="hljs-number">1</span>]<br>        helper(head)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><h2 id="结果-1">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190929163926676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="方法三">方法三：</h2><p>递归遍历整个链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">return</span> head<br>        x = self.reverseList(head.<span class="hljs-built_in">next</span>)<br>        head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = head<br>        head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><h2 id="结果-2">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190929164034620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="方法四迭代">方法四：迭代</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = ListNode(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> head:<br>            temp = ListNode(head.val)<br>            temp.<span class="hljs-built_in">next</span> = res.<span class="hljs-built_in">next</span><br>            res.<span class="hljs-built_in">next</span> = temp<br>            head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="结果-3">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190929164132140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：148.排序链表</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>示例1：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">4</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span><br>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">-1</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span><br>输出: <span class="hljs-number">-1</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><p>合并排序 + 递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortList</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">return</span> head<br>        slow = head<br>        fast = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            slow = slow.<span class="hljs-built_in">next</span><br>        mid = slow.<span class="hljs-built_in">next</span><br>        slow.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        left = self.sortList(head)<br>        right = self.sortList(mid)<br>        result = temp = ListNode(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> left <span class="hljs-keyword">and</span> right:<br>            <span class="hljs-keyword">if</span> left.val &gt;= right.val:<br>                temp.<span class="hljs-built_in">next</span> = right<br>                right = right.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                temp.<span class="hljs-built_in">next</span> = left<br>                left = left.<span class="hljs-built_in">next</span><br>            temp = temp.<span class="hljs-built_in">next</span><br>        temp.<span class="hljs-built_in">next</span> = left <span class="hljs-keyword">if</span> left <span class="hljs-keyword">else</span> right<br>        <span class="hljs-keyword">return</span> result.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190928204315685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：155.最小栈</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A155.%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A155.%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) -- 将元素 x 推入栈中。 pop() -- 删除栈顶的元素。 top() -- 获取栈顶元素。 getMin() -- 检索栈中的最小元素。 示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">MinStack minStack <span class="hljs-operator">=</span> new MinStack()<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>minStack.push(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>minStack.getMin()<span class="hljs-comment">;   --&gt; 返回 -3.</span><br>minStack.pop()<span class="hljs-comment">;</span><br>minStack.top()<span class="hljs-comment">;      --&gt; 返回 0.</span><br>minStack.getMin()<span class="hljs-comment">;   --&gt; 返回 -2.</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><p>利用一个栈存放元素，一个栈存放入栈后的最小值来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        initialize your data structure here.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.length = <span class="hljs-number">0</span><br>        self.stack = []<br>        self.mini = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        self.minset = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type x: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.stack.append(x)<br>        self.length += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> x &lt; self.mini:<br>            self.mini = x<br>        self.minset.append(self.mini)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.stack.pop()<br>        self.length -= <span class="hljs-number">1</span><br>        self.minset.pop()<br>        <span class="hljs-keyword">if</span> self.length == <span class="hljs-number">0</span>:<br>            self.mini = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.mini = self.minset[self.length - <span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.stack[self.length - <span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.minset[self.length - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/2019092815565964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：142.环形链表II</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例1：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：head</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">4</span>], pos = <span class="hljs-number">1</span><br>输出<span class="hljs-built_in">：tail</span> connects <span class="hljs-keyword">to</span> <span class="hljs-type">node</span> index <span class="hljs-number">1</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190927155655805.png" alt="在这里插入图片描述" /> 示例2：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：head</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], pos = <span class="hljs-number">0</span><br>输出<span class="hljs-built_in">：tail</span> connects <span class="hljs-keyword">to</span> <span class="hljs-type">node</span> index <span class="hljs-number">0</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190927155739410.png" alt="在这里插入图片描述" /> 示例3：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：head = [<span class="hljs-number">1</span>], <span class="hljs-keyword">pos</span> = -<span class="hljs-number">1</span><br>输出：<span class="hljs-keyword">no</span> cycle<br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/20190927155804204.png" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="算法实现方法一">算法实现：方法一</h2><p>根据题目要求，用字典存下索引和结点，然后遇到重复结点时返回索引值。 但是执行时发生错误，说需要返回一个结点，我感觉这个和题目意思不一样，所以这题题目没问题，Leetcode平台执行结果有点问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">detectCycle</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        a = &#123;&#125;<br>        count = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> head:<br>            <span class="hljs-keyword">if</span> head <span class="hljs-keyword">in</span> a:<br>                <span class="hljs-keyword">return</span> head<br>            a[head] = a.get(head, count)<br>            count += <span class="hljs-number">1</span><br>            head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190927155231377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="方法二">方法二：</h2><p>可以用和上一题一模一样的代码也能通过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detectCycle</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        a = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> head:<br>            <span class="hljs-keyword">if</span> head <span class="hljs-keyword">in</span> a:<br>                <span class="hljs-keyword">return</span> head<br>            a.add(head)<br>            head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head<br></code></pre></td></tr></table></figure><h2 id="结果-1">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190927155533554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：146.LRU缓存机制</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A146.LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A146.LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>进阶:</p><p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">LRUCache</span> cache = new LRUCache( <span class="hljs-number">2</span> /* 缓存容量 */ );<br><br><span class="hljs-attribute">cache</span>.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-attribute">cache</span>.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><span class="hljs-attribute">cache</span>.get(<span class="hljs-number">1</span>);       // 返回  <span class="hljs-number">1</span><br><span class="hljs-attribute">cache</span>.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);    // 该操作会使得密钥 <span class="hljs-number">2</span> 作废<br><span class="hljs-attribute">cache</span>.get(<span class="hljs-number">2</span>);       // 返回 -<span class="hljs-number">1</span> (未找到)<br><span class="hljs-attribute">cache</span>.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);    // 该操作会使得密钥 <span class="hljs-number">1</span> 作废<br><span class="hljs-attribute">cache</span>.get(<span class="hljs-number">1</span>);       // 返回 -<span class="hljs-number">1</span> (未找到)<br><span class="hljs-attribute">cache</span>.get(<span class="hljs-number">3</span>);       // 返回  <span class="hljs-number">3</span><br><span class="hljs-attribute">cache</span>.get(<span class="hljs-number">4</span>);       // 返回  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="算法实现队列">算法实现：队列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type capacity: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.capacity = capacity<br>        self.dictionary = &#123;&#125;<br>        self.QueQue = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type key: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.dictionary.get(key, <span class="hljs-number">0</span>):<br>            self.QueQue.remove(key)<br>            self.QueQue.insert(<span class="hljs-number">0</span>, key)<br>            <span class="hljs-keyword">return</span> self.dictionary[key]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type key: int</span><br><span class="hljs-string">        :type value: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.dictionary:<br>            self.QueQue.remove(key)<br>            self.QueQue.insert(<span class="hljs-number">0</span>, key)<br>            self.dictionary[key] = value<br>        <span class="hljs-keyword">elif</span> self.capacity &gt; <span class="hljs-number">0</span>:<br>            self.QueQue.insert(<span class="hljs-number">0</span>, key)<br>            self.dictionary[key] = value<br>            self.capacity -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">del</span> self.dictionary[self.QueQue.pop()]<br>            self.QueQue.insert(<span class="hljs-number">0</span>, key)<br>            self.dictionary[key] = value<br>obj = LRUCache(<span class="hljs-number">2</span>)<br>obj.put(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>obj.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(obj.get(<span class="hljs-number">2</span>))<br>obj.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>obj.put(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(obj.get(<span class="hljs-number">2</span>))<br><br></code></pre></td></tr></table></figure><h2 id="结果">结果:</h2><figure><img src="https://img-blog.csdnimg.cn/20190927211614981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：141.环形链表</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。 如果pos是 - 1，则在该链表中没有环。</p><p>示例1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/20190926185054494.png" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><p>示例2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019092618512484.png" alt="在这里插入图片描述" /> 示例3：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1], pos = -1<br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/20190926185149585.png" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="算法实现-方法一">算法实现： 方法一：</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(object):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, x</span>):<br>        <span class="hljs-variable language_">self</span>.val = x<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-keyword">next</span> = None<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(object):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, head</span>):<br>        flag = False<br>        a = []<br>        <span class="hljs-keyword">while</span> <span class="hljs-symbol">head:</span><br>            <span class="hljs-keyword">if</span> head <span class="hljs-keyword">in</span> <span class="hljs-symbol">a:</span><br>                flag = True<br>                <span class="hljs-keyword">break</span><br>            a.append(head)<br>            head = head.<span class="hljs-keyword">next</span><br>        <span class="hljs-keyword">return</span> flag<br><br>a = ListNode(<span class="hljs-number">1</span>)<br>a.<span class="hljs-keyword">next</span> = ListNode(<span class="hljs-number">5</span>)<br>a.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = ListNode(<span class="hljs-number">5</span>)<br>a.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = a.<span class="hljs-keyword">next</span><br>print(Solution().hasCycle(a))<br></code></pre></td></tr></table></figure><p>用一个列表存下每个结点，如果下一个结点在列表里的话就说明有环，反之无环</p><h2 id="结果">结果：</h2><p>由于每次判断都用了in，所以导致运行时间很长 <img src="https://img-blog.csdnimg.cn/20190926185514148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="方法二快慢指针">方法二：快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head</span>):<br>        fast = head<br>        slow = head<br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            slow = slow.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> fast <span class="hljs-keyword">is</span> slow:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br></code></pre></td></tr></table></figure><h2 id="结果-1">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190926185546228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：136.只出现一次的数字</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [4,1,2,1,2]</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">singleNumber</span>(self, nums: List[int]) -&gt; int:<br>        a = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            a[i] = a.<span class="hljs-keyword">get</span>(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> a:<br>            <span class="hljs-keyword">if</span> a[j] == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> j<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190925222857684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：124.二叉树最大路径和</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A124.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A124.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个非空二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p>示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3]</span><br><br>       1<br>      / \<br>     2   3<br><br><span class="hljs-section">输出: 6</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: [-<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br><br>   -<span class="hljs-number">10</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br><br>输出: <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">self, root</span>):<br>        result = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">nonlocal</span> result<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            left = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, helper(root.left))<br>            right = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, helper(root.right))<br>            temp = left + right + root.val<br>            result = <span class="hljs-built_in">max</span>(result, temp)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + root.val<br>        helper(root)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="思路">思路：</h2><p>我一开始的思路是通过树的遍历把树的每条路径找出来，然后对每条路径求最大子序和来实现寻找树的最大路径和，结果在寻找树的路径时候遇到坑了，最后只能看了一下别人的思路，自己也理解了</p><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190924121234877.png" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：121.买卖股票的最佳时机</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。 示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,1,5,3,6,4]</span><br><span class="hljs-section">输出: 5</span><br><span class="hljs-section">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><p>动态规划</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">class</span> Solution:<br>    def maxProfit(self, prices):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prices:<br><span class="hljs-built_in">            return</span> <span class="hljs-number">0</span><br>        mini = prices[<span class="hljs-number">0</span>]<br>        <span class="hljs-literal">result</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(prices)):<br>            <span class="hljs-keyword">if</span> prices[i] &lt; mini:<br>                mini = prices[i]<br>            <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span> &lt; prices[i] - mini:<br>                <span class="hljs-literal">result</span> = prices[i] - mini<br><span class="hljs-built_in">        return</span> <span class="hljs-literal">result</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190922144502100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：122.买卖股票的最佳时机II</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个数组，它的第i个元素是一支给定股票第i天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [7, 1, 5, 3, 6, 4]<br>输出: 7<br>解释: 在第2天（股票价格 = 1）的时候买入，在第3天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>随后，在第4天（股票价格 = 3）的时候买入，在第5天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1, 2, 3, 4, 5]</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 在第1天（股票价格 = 1）的时候买入，在第5天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br>注意你不能在第1天和第2天接连购买股票，之后再将它们卖出。<br>因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><h2 id="算法实现动态规划">算法实现：动态规划</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution:<br>    def maxProfit(self, prices: List[<span class="hljs-keyword">int</span>]) -&gt; <span class="hljs-keyword">int</span>:<br>        <span class="hljs-keyword">res</span> = []<br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prices) - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">a</span> = (prices[i + <span class="hljs-number">1</span>] - prices[i])<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">a</span> &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">a</span>)<br>        <span class="hljs-keyword">return</span> sum(<span class="hljs-keyword">res</span>)<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190922172420210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：104.二叉树最大深度</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A104.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A104.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。 示例：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定二叉树 [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]，<br><br>    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br><br>返回它的最大深度 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><h2 id="算法实现递归">算法实现：递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root</span>):<br>        n = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">nonlocal</span> n<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>                <span class="hljs-keyword">return</span> n<br>            n += <span class="hljs-number">1</span><br>            root.val = n<br>            a = helper(root.left)<br>            n = root.val<br>            b = helper(root.right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(a, b)<br>        <span class="hljs-keyword">return</span> helper(root)<br></code></pre></td></tr></table></figure><h2 id="结果这次是从开始到现在通过速度最快的一次">结果：这次是从开始到现在通过速度最快的一次</h2><figure><img src="https://img-blog.csdnimg.cn/20190921234222417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：89.格雷编码</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A89.%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A89.%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p><p>示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 2</span><br><span class="hljs-section">输出: [0,1,3,2]</span><br><span class="hljs-section">解释:</span><br>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2<br><br>对于给定的 n，其格雷编码序列并不唯一。<br>例如，[0,2,3,1] 也是一个有效的格雷编码序列。<br><br>00 - 0<br>10 - 2<br>11 - 3<br>01 - 1<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入<span class="hljs-symbol">:</span> <span class="hljs-number">0</span><br>输出<span class="hljs-symbol">:</span> [<span class="hljs-number">0</span>]<br>解释<span class="hljs-symbol">:</span> 我们定义格雷编码序列必须以 <span class="hljs-number">0</span> 开头。<br>     给定编码总位数为 <span class="hljs-built_in">n</span> 的格雷编码序列，其长度为 <span class="hljs-number">2</span><span class="hljs-built_in">n</span>。当 <span class="hljs-built_in">n</span> = <span class="hljs-number">0</span> 时，长度为 <span class="hljs-number">20</span> = <span class="hljs-number">1</span>。<br>     因此，当 <span class="hljs-built_in">n</span> = <span class="hljs-number">0</span> 时，其格雷编码序列为 [<span class="hljs-number">0</span>]。<br></code></pre></td></tr></table></figure><h2 id="算法实现记忆化溯回">算法实现：记忆化溯回</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">grayCode</span>(self, n: int) -&gt; List[int]:<br>        result = &#123;<span class="hljs-number">0</span>:[<span class="hljs-number">0</span>]&#125;<br>        temp = []<br>        def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n)</span></span>:<br>            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> result:<br>                <span class="hljs-keyword">return</span> result[n]<br>            <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n - <span class="hljs-number">1</span>)</span></span><br>            temp1 = temp[:]<br>            temp.append(<span class="hljs-number">2</span> ** (n - <span class="hljs-number">1</span>))<br>            temp.extend(temp1)<br>            b = []<br>            b.extend(result[n - <span class="hljs-number">1</span>])<br>            a = b[-<span class="hljs-number">1</span>] ^ (<span class="hljs-number">2</span> ** (n - <span class="hljs-number">1</span>))<br>            b.append(a)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> temp1:<br>                a = a ^ i<br>                b.append(a)<br>            result.setdefault(n, b)<br>        <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n)</span></span><br>        <span class="hljs-keyword">return</span> result[n]<br></code></pre></td></tr></table></figure><h2 id="思路">思路：</h2><p><img src="https://img-blog.csdnimg.cn/20190920000332798.png" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/20190920000618803.png" alt="在这里插入图片描述" /></p><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190919234152398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：88.合并两个有序数组</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br><br><span class="hljs-section">输出: [1,2,2,3,5,6]</span><br></code></pre></td></tr></table></figure><h2 id="算法实现双指针">算法实现：双指针</h2><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">class</span> Solution:<br>    def merge(self, nums<span class="hljs-number">1</span>: List[int], m: int, nums<span class="hljs-number">2</span>: List[int], n: int) -&gt; None:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify nums1 in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        nums<span class="hljs-number">1</span>[:] = nums<span class="hljs-number">1</span>[:m]<br>        i = <span class="hljs-number">0</span><br>        j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> nums<span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">while</span> i &lt; m and j &lt; n:<br>                <span class="hljs-keyword">if</span> nums<span class="hljs-number">1</span>[i] &gt;= nums<span class="hljs-number">2</span>[j]:<br>                    nums<span class="hljs-number">1</span>.insert(i, nums<span class="hljs-number">2</span>[j])<br>                    j += <span class="hljs-number">1</span><br>                    i += <span class="hljs-number">1</span><br>                    m += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> j &lt;= n:<br>            nums<span class="hljs-number">1</span>.extend(nums<span class="hljs-number">2</span>[j:])<br><br></code></pre></td></tr></table></figure><h2 id="思路">思路:</h2><p>先拷贝nums1，然后用双指针将两个有序数组排序</p><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190919134321225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：78.子集</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A78.%E5%AD%90%E9%9B%86/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A78.%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><br>输入: nums = <span class="hljs-comment">[1,2,3]</span><br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[]</span></span><br><span class="hljs-comment">]</span><br><br></code></pre></td></tr></table></figure><h2 id="算法实现迭代">算法实现：迭代</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nim">class <span class="hljs-type">Solution</span>:<br>    def subsets(self, nums: <span class="hljs-type">List</span>[<span class="hljs-type">int</span>]) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-type">int</span>]]:<br>        <span class="hljs-built_in">result</span> = [[]]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-built_in">result</span> = <span class="hljs-built_in">result</span> + [[i] + j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">result</span>]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span><br></code></pre></td></tr></table></figure><h2 id="思路">思路：</h2><p>将nums中数字带入上一次计算的每个元素中进行迭代得到答案</p><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190918200911254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：70.爬楼梯</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A70.%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A70.%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3. <span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><h2 id="方法一递归">方法一：递归</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">climbStairs</span>(self, n: int) -&gt; int:<br>        a = <span class="hljs-number">0</span><br>        def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n)</span></span>:<br>            nonlocal a<br>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> or n == <span class="hljs-number">0</span>:<br>                a += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n - <span class="hljs-number">1</span>)</span></span><br>                <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n - <span class="hljs-number">2</span>)</span></span><br>        <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n)</span></span><br>        <span class="hljs-keyword">return</span> a<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><p>由于重复步骤太多，导致超出时间限制 <img src="https://img-blog.csdnimg.cn/20190917194622311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="方法二记忆化递归">方法二：记忆化递归</h2><p>利用字典保存每次递归的结果，再下次递归时直接调用结果</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, <span class="hljs-symbol">n:</span> int</span>) -&gt; <span class="hljs-symbol">int:</span><br>        m = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">0</span>: <span class="hljs-number">1</span>&#125;<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">n</span>):<br>            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> <span class="hljs-symbol">m:</span><br>                <span class="hljs-keyword">return</span> m[n]<br>            a = helper(n - <span class="hljs-number">1</span>) + helper(n - <span class="hljs-number">2</span>)<br>            m.setdefault(n, a)<br>            <span class="hljs-keyword">return</span> a<br>        <span class="hljs-keyword">return</span> helper(n)<br></code></pre></td></tr></table></figure><p>结果： <img src="https://img-blog.csdnimg.cn/20190917194829538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="方法三排列组合">方法三：排列组合</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    def climbStairs(self, n: <span class="hljs-built_in">int</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        i = <span class="hljs-number">0</span><br>        a = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt;= n:<br>            a += <span class="hljs-built_in">int</span>(math.factorial(n)/(math.factorial(i) * math.factorial(n - i)))<br>            i += <span class="hljs-number">1</span><br>            n -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> a<br></code></pre></td></tr></table></figure><h2 id="结果-1">结果:</h2><figure><img src="https://img-blog.csdnimg.cn/20190917194924495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：61.旋转链表</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A61.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A61.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><p>示例1：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL, k = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;NULL<br>解释:<br>向右旋转 <span class="hljs-number">1</span> 步: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;NULL<br>向右旋转 <span class="hljs-number">2</span> 步: <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;NULL, k = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL<br>解释:<br>向右旋转 <span class="hljs-number">1</span> 步: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL<br>向右旋转 <span class="hljs-number">2</span> 步: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;NULL<br>向右旋转 <span class="hljs-number">3</span> 步: <span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;NULL<br>向右旋转 <span class="hljs-number">4</span> 步: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL<br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>:<br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, x</span>):<br>        <span class="hljs-variable language_">self</span>.val = x<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-keyword">next</span> = None<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotateRight</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, head, k</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> head<br>        elif <span class="hljs-keyword">not</span> head.<span class="hljs-symbol">next:</span><br>            <span class="hljs-keyword">return</span> head<br>        t = head<br>        count1 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-symbol">t:</span><br>            count1 += <span class="hljs-number">1</span><br>            t = t.<span class="hljs-keyword">next</span><br>        k = k % count1<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">hahaha</span>(<span class="hljs-params">head, k</span>):<br>            <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> head<br>            <span class="hljs-symbol">else:</span><br>                temp = head<br>                <span class="hljs-keyword">while</span> temp.<span class="hljs-keyword">next</span>.<span class="hljs-symbol">next:</span><br>                    temp = temp.<span class="hljs-keyword">next</span><br>                temp2 = ListNode(temp.<span class="hljs-keyword">next</span>.val)<br>                temp.<span class="hljs-keyword">next</span> = None<br>                temp2.<span class="hljs-keyword">next</span> = head<br>                <span class="hljs-keyword">return</span> hahaha(temp2, k - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> hahaha(head, k)<br></code></pre></td></tr></table></figure><h2 id="思路">思路：</h2><p>递归，当k == 1时终止，每次递归将链表最后一个元素提到表头</p><h2 id="结果">结果：</h2><p>并不太高效 <img src="https://img-blog.csdnimg.cn/20190914183153847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：59.螺旋矩阵二</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A59.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E4%BA%8C/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A59.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: 3<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment"> <span class="hljs-comment">[ 1, 2, 3 ]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[ 8, 9, 4 ]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[ 7, 6, 5 ]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">class</span> Solution:<br>    <span class="hljs-attribute">def</span> generateMatrix(self, n):<br>        <span class="hljs-attribute">a</span> =<span class="hljs-meta"> []</span><br>        <span class="hljs-attribute">temp1</span> = <span class="hljs-number">1</span><br>        <span class="hljs-attribute">k</span> = n<br>        <span class="hljs-attribute">for</span> each in range(n):<br>            <span class="hljs-attribute">a</span>.append([])<br>        <span class="hljs-attribute">for</span> i in range((k + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>):<br>            <span class="hljs-attribute">temp2</span> = temp1 + <span class="hljs-number">4</span> * (n - <span class="hljs-number">1</span>) if n != <span class="hljs-number">1</span> else temp1 + <span class="hljs-number">1</span><br>            <span class="hljs-attribute">m</span> = i<br>            <span class="hljs-attribute">y</span> = i<br>            <span class="hljs-attribute">for</span> j in range(temp1, temp2):<br>                <span class="hljs-attribute">if</span> j &lt; temp1 + n:<br>                    <span class="hljs-attribute">a</span>[i].insert(y, j)<br>                    <span class="hljs-attribute">y</span> += <span class="hljs-number">1</span><br>                <span class="hljs-attribute">elif</span> j &lt; temp1 + <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>:<br>                    <span class="hljs-attribute">m</span> += <span class="hljs-number">1</span><br>                    <span class="hljs-attribute">a</span>[m].insert(i, j)<br>                <span class="hljs-attribute">elif</span> j &lt; temp1 + <span class="hljs-number">3</span> * n - <span class="hljs-number">2</span>:<br>                    <span class="hljs-attribute">a</span>[m].insert(i, j)<br>                <span class="hljs-attribute">else</span>:<br>                    <span class="hljs-attribute">m</span> -= <span class="hljs-number">1</span><br>                    <span class="hljs-attribute">a</span>[m].insert(i, j)<br>            <span class="hljs-attribute">n</span> -= <span class="hljs-number">2</span><br>            <span class="hljs-attribute">temp1</span> = temp2<br>        <span class="hljs-attribute">return</span> a<br></code></pre></td></tr></table></figure><h2 id="思路">思路：</h2><p>假设要求n维螺旋矩阵，则需要循环(n + 1) // 2次，即矩阵由(n + 1) // 2个圈构成 每个圈有4 * (n - 1)个数，当n为1的时候有一个数。</p><h2 id="结果">结果:</h2><figure><img src="https://img-blog.csdnimg.cn/20190914122839570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：62.不同路径</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？ <img src="https://img-blog.csdnimg.cn/2019091419145053.png" alt="在这里插入图片描述" /> 例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>说明：m 和 n 的值均不超过 100。 示例1：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">3</span><br>解释:<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><span class="hljs-number">1.</span> 向右 -&gt; 向右 -&gt; 向下<br><span class="hljs-number">2.</span> 向右 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向右<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: m = 7, n = 3</span><br><span class="hljs-section">输出: 28</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><h2 id="方法一">方法一：</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution:<br>    def unique<span class="hljs-constructor">Paths(<span class="hljs-params">self</span>, <span class="hljs-params">m</span>: <span class="hljs-params">int</span>, <span class="hljs-params">n</span>: <span class="hljs-params">int</span>)</span> -&gt; <span class="hljs-built_in">int</span>:<br>        return <span class="hljs-built_in">int</span>(math.factorial(m + n - <span class="hljs-number">2</span>)/(math.factorial(m - <span class="hljs-number">1</span>)<span class="hljs-operator"> * </span>math.factorial(n - <span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><h2 id="思路">思路：</h2><p>设网格为m * n，那么到达终点需要向由走m - 1格，向下走n - 1格，路径数即为m - 1与n - 1的组合</p><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190914191318928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="方法二">方法二：</h2><p>递归</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">uniquePaths</span>(self, m: int, n: int) -&gt; int:<br>        def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(m, n)</span></span>:<br>            nonlocal a<br>            <span class="hljs-keyword">if</span> m == <span class="hljs-number">1</span> or n == <span class="hljs-number">1</span>:<br>                a += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(m, n - <span class="hljs-number">1</span>)</span></span><br>                <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(m - <span class="hljs-number">1</span>, n)</span></span><br>        a = <span class="hljs-number">0</span><br>        <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(m, n)</span></span><br>        <span class="hljs-keyword">return</span> a<br></code></pre></td></tr></table></figure><h2 id="结果-1">结果：</h2><p>超时了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：54.螺旋矩阵</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A54.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A54.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入:<br><span class="hljs-comment">[</span><br><span class="hljs-comment"> <span class="hljs-comment">[ 1, 2, 3 ]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[ 4, 5, 6 ]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[ 7, 8, 9 ]</span></span><br><span class="hljs-comment">]</span><br>输出: <span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1, 2, 3, 4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[5, 6, 7, 8]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,10,11,12]</span></span><br><span class="hljs-comment">]</span><br>输出: <span class="hljs-comment">[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><p>通过不断删除矩阵实现 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">spiralOrder</span>(self, matrix: List[List[int]]) -&gt; List[int]:<br>        def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(matrix)</span></span>:<br>            <span class="hljs-keyword">if</span> len(matrix) == <span class="hljs-number">1</span>:<br>                a.extend(matrix[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> not matrix:<br>                <span class="hljs-keyword">return</span><br>            a.extend(matrix[<span class="hljs-number">0</span>])<br>            del matrix[<span class="hljs-number">0</span>]<br>            i = len(matrix[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span><br>            j = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> j &lt; len(matrix):<br>                a.append(matrix[j][i])<br>                del matrix[j][i]<br>                <span class="hljs-keyword">if</span> not matrix[j]:<br>                    del matrix[j]<br>                    j -= <span class="hljs-number">1</span><br>                j += <span class="hljs-number">1</span><br>            j -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> matrix:<br>                matrix[j].reverse()<br>                a.extend(matrix[j])<br>                del matrix[j]<br>            <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span>:<br>                j -= <span class="hljs-number">1</span><br>                a.append(matrix[j][<span class="hljs-number">0</span>])<br>                del matrix[j][<span class="hljs-number">0</span>]<br>                <span class="hljs-keyword">if</span> not matrix[j]:<br>                    del matrix[j]<br>            <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(matrix)</span></span><br>        a = []<br>        <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(matrix)</span></span><br>        <span class="hljs-keyword">return</span> a<br></code></pre></td></tr></table></figure></p><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190913123438364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：53.最大子序和</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目： 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4],<br>输出: 6<br>解释: 连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6。<br></code></pre></td></tr></table></figure><p>算法实现：双指针 今天这题是写的最不满意的，脑子不好使了，明天再修改</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs smali">class Solution:<br>    def maxSubArray(self, nums: List[int]) -&gt; int:<br>        count1 = 0<br>        count2 = len(nums) - 1<br>        a = float(&#x27;-inf&#x27;)<br>        while True:<br>            while nums[count1] &lt;= 0<span class="hljs-built_in"> and </span>count1 &lt; count2:<br>                count1 += 1<br>            while nums[count2] &lt;= 0<span class="hljs-built_in"> and </span>count2 &gt; count1:<br>                count2 -= 1<br>            i = count1 + 1<br>            j = count2 - 1<br>            temp1 = sum(nums[count1:i + 1])<br>            temp2 = sum(nums[j:count2 + 1])<br>            while (temp1 &gt; 0<span class="hljs-built_in"> or </span>temp2 &gt; 0)<span class="hljs-built_in"> and </span>i &lt;= j:<br>                a = nums[count1]<span class="hljs-built_in"> if </span>nums[count1] &gt; a else a<br>                a = nums[count2]<span class="hljs-built_in"> if </span>nums[count2] &gt; a else a<br>               <span class="hljs-built_in"> if </span>temp1 &gt; 0:<br>                    a = temp1<span class="hljs-built_in"> if </span>temp1 &gt; a else a<br>                    i += 1<br>                    temp1 += nums[i]<br>                else:<br>                    count1 = i + 1<br>                    while nums[count1] &lt;= 0<span class="hljs-built_in"> and </span>count1 &lt; count2:<br>                        count1 += 1<br>                    i = count1 + 1<br>                    temp1 = nums[count1]<br>               <span class="hljs-built_in"> if </span>temp2 &gt; 0:<br>                    a = temp2<span class="hljs-built_in"> if </span>temp2 &gt; a else a<br>                    j -= 1<br>                    temp2 += nums[j]<br>                else:<br>                    count2 = j - 1<br>                    while nums[count2] &lt;= 0<span class="hljs-built_in"> and </span>count2 &gt; count1:<br>                        count2 -= 1<br>                    j = count2 - 1<br>                    temp2 = nums[count2]<br>               <span class="hljs-built_in"> if </span>i &gt; j:<br>                   <span class="hljs-built_in"> return </span>sum(nums[count1:count2 + 1])<span class="hljs-built_in"> if </span>sum(nums[count1:count2 + 1]) &gt; a else a<br>           <span class="hljs-built_in"> if </span>count1 == count2:<br>               <span class="hljs-built_in"> return </span>max(nums)<br>           <span class="hljs-built_in"> if </span>sum(nums[count1:i + 1]) &lt;= 0:<br>                count1 += 1<br>           <span class="hljs-built_in"> if </span>sum(nums[j:count2 + 1]) &lt;= 0:<br>                count2 -= 1<br>           <span class="hljs-built_in"> if </span>count1 == count2 - 1:<br>               <span class="hljs-built_in"> return </span>sum(nums[count1:count2 + 1])<span class="hljs-built_in"> if </span>sum(nums[count1:count2 + 1]) &gt; a else a<br></code></pre></td></tr></table></figure><p>结果： <img src="https://img-blog.csdnimg.cn/20190912231122593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：46.全排列</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A46.%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A46.%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个没有重复数字的序列，返回其所有可能的全排列。 示例：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,2,3]</span><br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,2,1]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">permute</span>(self, nums: List[int]) -&gt; List[List[int]]:<br>        j = len(nums)<br>        result = []<br>        def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(i)</span></span>:<br>            <span class="hljs-keyword">if</span> i == j:  <br>                result.append(nums.copy())<br>            <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> range(i, j):<br>                nums[i], nums[each] = nums[each], nums[i]<br>                <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(i + <span class="hljs-number">1</span>)</span></span><br>                nums[i], nums[each] = nums[each], nums[i]     <br>        <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190911214847615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：33.搜索旋转排序数组</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><p>二分法：列出了所有可能的情况与相应的操作，非常繁琐</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">search</span>(self, nums: List[int], target: int) -&gt; int:<br>        count1 = <span class="hljs-number">0</span><br>        count2 = len(nums) - <span class="hljs-number">1</span><br>        temp = (count2 - count1) <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">while</span> count1 &lt;= count2:<br>            <span class="hljs-keyword">if</span> nums[temp] &gt; target:<br>                <span class="hljs-keyword">if</span> nums[count1] == target:<br>                    <span class="hljs-keyword">return</span> count1<br>                elif nums[count2] == target:<br>                    <span class="hljs-keyword">return</span> count2<br>                elif nums[count1] &gt; nums[temp] or (nums[count1] &lt; nums[temp] and target &gt; nums[count1]):<br>                    count2 = temp<br>                    temp = count1 + (count2 - count1) <span class="hljs-comment">// 2</span><br>                elif (nums[count1] == nums[temp] and count1 != temp) or (nums[count1] &lt; nums[temp] and target &lt; nums[count1]):<br>                    count1 = temp<br>                    temp = count1 + (count2 - count1) <span class="hljs-comment">// 2</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>            elif nums[temp] &lt; target:<br>                <span class="hljs-keyword">if</span> nums[count1] == target:<br>                    <span class="hljs-keyword">return</span> count1<br>                elif nums[count2] == target:<br>                    <span class="hljs-keyword">return</span> count2<br>                elif nums[count1] &lt; nums[temp] or (nums[count1] &gt; nums[temp] and nums[count1] &gt; target):<br>                    count1 = temp<br>                    temp = (count2 - count1) <span class="hljs-comment">// 2 + count1</span><br>                elif nums[count1] == nums[temp]:<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>                elif nums[count1] &gt; nums[temp] and nums[count1] &lt; target:<br>                    count2 = temp<br>                    temp = (count2 - count1) <span class="hljs-comment">// 2 + count1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> temp<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190910025650162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：43.字符串相乘</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A43.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A43.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例1：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;3&quot;</span><br>输出: <span class="hljs-string">&quot;6&quot;</span><br></code></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;456&quot;</span><br>输出: <span class="hljs-string">&quot;56088&quot;</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    def multiply(self, num1: <span class="hljs-built_in">str</span>, num2: <span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        count1 = len(num1) - <span class="hljs-number">1</span><br>        result1 = <span class="hljs-number">0</span><br>        count2 = len(num2) - <span class="hljs-number">1</span><br>        result2 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> each1 <span class="hljs-keyword">in</span> num1:<br>            result1 += <span class="hljs-built_in">int</span>(each1) * (<span class="hljs-number">10</span> ** count1)<br>            count1 -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> each2 <span class="hljs-keyword">in</span> num2:<br>            result2 += <span class="hljs-built_in">int</span>(each2) * (<span class="hljs-number">10</span> ** count2)<br>            count2 -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(result1 * result2)<br>s = Solution()<br><span class="hljs-keyword">print</span>(s.multiply(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;456&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190910094755811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：26.删除排序数组中重复的项</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E9%A1%B9/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例1：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">给定数组 nums </span>=<span class="hljs-string"> [1,1,2], </span><br><span class="hljs-string"></span><br><span class="hljs-string">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="hljs-string"></span><br><span class="hljs-string">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">给定 nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,2,2,3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br><br>函数应该返回新的长度 <span class="hljs-number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>。<br><br>你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下: <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">len</span> = removeDuplicates(nums);<br><br><span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>; i++) &#123;<br>    <span class="hljs-built_in">print</span>(nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure> ## 算法实现：</p><h2 id="方法一集合">方法一：集合</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">class Solution:<br>    def removeDuplicates(self, nums: List[int]) -&gt; int:<br>        <span class="hljs-keyword">a</span> = list(<span class="hljs-built_in">set</span>(tuple(nums)))<br>        <span class="hljs-keyword">a</span>.<span class="hljs-built_in">sort</span>()<br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">len</span>(<span class="hljs-keyword">a</span>)):<br>            nums[<span class="hljs-keyword">each</span>] = <span class="hljs-keyword">a</span>[<span class="hljs-keyword">each</span>]<br>        <span class="hljs-literal">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-keyword">a</span>)<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><p>没有想象中那么慢 <img src="https://img-blog.csdnimg.cn/20190908155001801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="方法二双指针">方法二：双指针</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">if</span> not nums:<br>    return <span class="hljs-number">0</span><br>each1 = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> each2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>    <span class="hljs-keyword">if</span> nums<span class="hljs-selector-attr">[each1]</span> != nums<span class="hljs-selector-attr">[each2]</span>:<br>        each1 += <span class="hljs-number">1</span><br>        nums<span class="hljs-selector-attr">[each1]</span> = nums<span class="hljs-selector-attr">[each2]</span><br>return each1 + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="结果-1">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190908160119547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：23.合并K个排序链表</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入:<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, x</span>):<br>        <span class="hljs-variable language_">self</span>.val = x<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-keyword">next</span> = None<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, lists</span>):<br>        <span class="hljs-variable language_">self</span>.sets = []<br>        result = temp = ListNode(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> <span class="hljs-symbol">lists:</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-symbol">each:</span><br>                <span class="hljs-variable language_">self</span>.sets.append(each.val)<br>                each = each.<span class="hljs-keyword">next</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> sorted(<span class="hljs-variable language_">self</span>.sets):<br>            temp.<span class="hljs-keyword">next</span> = ListNode(x)<br>            temp = temp.<span class="hljs-keyword">next</span><br>        <span class="hljs-keyword">return</span> result.<span class="hljs-keyword">next</span><br><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190907231248116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：21.合并两个有序链表</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span><br>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, x</span>):<br>        <span class="hljs-variable language_">self</span>.val = x<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-keyword">next</span> = None<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, l1, l2</span>):<br>        result = ListNode(<span class="hljs-number">0</span>)<br>        temp = result<br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">and</span> <span class="hljs-symbol">l2:</span><br>            <span class="hljs-keyword">if</span> l1.val &gt;= l2.<span class="hljs-symbol">val:</span><br>                temp.<span class="hljs-keyword">next</span> = l1<br>                l2 = l2.<span class="hljs-keyword">next</span><br>                temp = temp.<span class="hljs-keyword">next</span><br>            <span class="hljs-symbol">else:</span><br>                temp.<span class="hljs-keyword">next</span> = l1<br>                l1 = l1.<span class="hljs-keyword">next</span><br>                temp = temp.<span class="hljs-keyword">next</span><br>        temp.<span class="hljs-keyword">next</span> = l1 <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> l2<br>        <span class="hljs-keyword">return</span> result.<span class="hljs-keyword">next</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190905235440335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：16.最接近的三数之和</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">例如，给定数组 nums = [<span class="hljs-string">-1</span>，2，1，<span class="hljs-string">-4</span>], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (<span class="hljs-string">-1</span> + 2 + 1 = 2).<br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSumClosest</span>(<span class="hljs-params">self, nums, target</span>):<br>        nums.sort()<br>        <span class="hljs-built_in">sum</span> = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &gt;= <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">if</span> nums[each] == nums[each - <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            count1 = each + <span class="hljs-number">1</span><br>            count2 = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> count2 &gt; count1:<br>                temp = nums[count1] + nums[count2] + nums[each]<br>                rest = temp - target<br>                <span class="hljs-built_in">sum</span> = temp <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">sum</span> - target) &gt; <span class="hljs-built_in">abs</span>(temp - target) <span class="hljs-keyword">else</span> <span class="hljs-built_in">sum</span><br>                <span class="hljs-keyword">if</span> rest &lt; <span class="hljs-number">0</span>:<br>                    count1 += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> count2 &gt; count1 <span class="hljs-keyword">and</span> nums[count1] == nums[count1 - <span class="hljs-number">1</span>]:<br>                        count1 += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> rest &gt; <span class="hljs-number">0</span>:<br>                    count2 -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> count2 &gt; count1 <span class="hljs-keyword">and</span> nums[count2] == nums[count2 + <span class="hljs-number">1</span>]:<br>                        count2 -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> target<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br>s = Solution()<br><span class="hljs-built_in">print</span>(s.threeSumClosest([-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">55</span>],<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190904203647238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：20.有效的括号</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 1.左括号必须用相同类型的右括号闭合。 2.左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串 示例1：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;()&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;(]&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;([)]&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例5：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;&#123;[]&#125;&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br><span class="hljs-keyword">class</span> Solution:<br>    <span class="hljs-keyword">def</span> isValid(self, s: str) -&gt; bool:<br>            <span class="hljs-keyword">if</span> len(s) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span><br>            <span class="hljs-keyword">each</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">abs</span>(<span class="hljs-keyword">each</span>) &lt; len(s) - <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> s[<span class="hljs-keyword">each</span>] == <span class="hljs-string">&#x27;(&#x27;</span> and s[<span class="hljs-keyword">each</span> + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                    s = s[:<span class="hljs-keyword">each</span>] + s[<span class="hljs-keyword">each</span> + <span class="hljs-number">2</span>:]<br>                    <span class="hljs-keyword">each</span> -= <span class="hljs-number">2</span><br>                elif s[<span class="hljs-keyword">each</span>] == <span class="hljs-string">&#x27;&#123;&#x27;</span> and s[<span class="hljs-keyword">each</span> + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;&#125;&#x27;</span>:<br>                    s = s[:<span class="hljs-keyword">each</span>] + s[<span class="hljs-keyword">each</span> + <span class="hljs-number">2</span>:]<br>                    <span class="hljs-keyword">each</span> -= <span class="hljs-number">2</span><br>                elif s[<span class="hljs-keyword">each</span>] == <span class="hljs-string">&#x27;[&#x27;</span> and s[<span class="hljs-keyword">each</span> + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;]&#x27;</span>:<br>                    s= s[:<span class="hljs-keyword">each</span>] + s[<span class="hljs-keyword">each</span> + <span class="hljs-number">2</span>:]<br>                    <span class="hljs-keyword">each</span> -= <span class="hljs-number">2</span><br>                <span class="hljs-keyword">each</span> = <span class="hljs-keyword">each</span> + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">each</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> s:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span><br><br></code></pre></td></tr></table></figure><h2 id="思路">思路：</h2><p>此算法通过不断消去成对括号来实现判断括号是否有效 例如'{[()]}' 首先消去内部的'()'变为'{[]}' 然后消去'[]'变为'{}' 最后消去'{}' 当s为空串时，括号即为有效</p><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190904225520251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：15.三数之和</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">例如, 给定数组 nums = <span class="hljs-comment">[-1, 0, 1, 2, -1, -4]</span>，<br>满足要求的三元组集合为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[-1, 0, 1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[-1, -1, 2]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><h2 id="方法一暴力法">方法一：暴力法</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">class Solution:<br>    def threeSum(self, <span class="hljs-built_in">num</span>):<br>        <span class="hljs-built_in">result</span> = []<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">num</span>) &gt;= <span class="hljs-number">3</span>:<br>            <span class="hljs-built_in">length</span> = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">num</span>) - <span class="hljs-number">2</span><br>            count1 = <span class="hljs-number">1</span><br>            count2 = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span> * (<span class="hljs-built_in">length</span> + <span class="hljs-number">1</span>)<span class="hljs-comment"> // 2):</span><br>                temp = []<br>                temp.extend([<span class="hljs-built_in">num</span>[<span class="hljs-number">0</span>], <span class="hljs-built_in">num</span>[count1], <span class="hljs-built_in">num</span>[count2]])<br>                <span class="hljs-keyword">if</span> count2 == <span class="hljs-built_in">length</span> + <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(temp) == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> sorted(temp) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">result</span>:<br>                        <span class="hljs-built_in">result</span>.append(sorted(temp))<br>                    count1 += <span class="hljs-number">1</span><br>                    count2 = count1 + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(temp) == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> sorted(temp) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">result</span>:<br>                        <span class="hljs-built_in">result</span>.append(sorted(temp))<br>                    count2 += <span class="hljs-number">1</span><br>            del <span class="hljs-built_in">num</span>[<span class="hljs-number">0</span>]<br>        <span class="hljs-literal">return</span> <span class="hljs-built_in">result</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190903212545503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="方法二双指针">方法二：双指针</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">class Solution:<br>    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-literal">return</span><br>        nums.<span class="hljs-built_in">sort</span>()<br>        <span class="hljs-built_in">result</span> = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-keyword">each</span>] &gt; <span class="hljs-number">0</span>:<br>                break<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">each</span> is <span class="hljs-keyword">not</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[<span class="hljs-keyword">each</span>] == nums[<span class="hljs-keyword">each</span> - <span class="hljs-number">1</span>]:<br>                count1 += <span class="hljs-number">1</span><br>                continue<br>            count1 = <span class="hljs-keyword">each</span> + <span class="hljs-number">1</span><br>            count2 = <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>            <span class="hljs-keyword">while</span> count1 &lt; count2:<br>                s = nums[<span class="hljs-keyword">each</span>] + nums[count1] + nums[count2]<br>                <span class="hljs-keyword">if</span> s &gt; <span class="hljs-number">0</span>:<br>                    count2 -= <span class="hljs-number">1</span><br>                elif s &lt; <span class="hljs-number">0</span>:<br>                    count1 += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">result</span>.<span class="hljs-built_in">add</span>((nums[<span class="hljs-keyword">each</span>], nums[count1], nums[count2]))<br>                    count1 += <span class="hljs-number">1</span><br>                    count2 -= <span class="hljs-number">1</span><br>        <span class="hljs-literal">return</span> <span class="hljs-built_in">result</span><br></code></pre></td></tr></table></figure><h2 id="结果-1">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190903212738272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：14.最长公共前缀</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 ""。 示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: [<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>]<br>输出: <span class="hljs-string">&quot;fl&quot;</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>]<br>输出: <span class="hljs-string">&quot;&quot;</span><br>解释: 输入不存在公共前缀。<br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution:<br>    <span class="hljs-keyword">def</span> longestCommonPrefix(self, strs: List[str]) -&gt; str:<br>        <span class="hljs-keyword">if</span> not strs:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span><br>        result = <span class="hljs-string">&#x27;&#x27;</span><br>        minlength = min(list(len(x) <span class="hljs-keyword">for</span> x in strs))<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">count</span> == minlength:<br>                <span class="hljs-keyword">return</span> result<br>            <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> in range(len(strs)):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">each</span> == <span class="hljs-number">0</span>:<br>                    result += strs[<span class="hljs-keyword">each</span>][<span class="hljs-keyword">count</span>]<br>                <span class="hljs-keyword">if</span> strs[<span class="hljs-keyword">each</span>][<span class="hljs-keyword">count</span>] != result[<span class="hljs-keyword">count</span>]:<br>                    <span class="hljs-keyword">return</span> result[:<span class="hljs-keyword">count</span>]<br>            <span class="hljs-keyword">count</span> += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190902081323755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：11.盛最多水的容器</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 <img src="https://img-blog.csdnimg.cn/2019090118022528.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出: <span class="hljs-number">49</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><h2 id="方法一暴力法">方法一:暴力法</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">class</span> Solution:<br>    <span class="hljs-attribute">def</span> maxArea(self, height):<br>        <span class="hljs-attribute">result</span> = <span class="hljs-number">0</span><br>        <span class="hljs-attribute">n</span> = len(height)<br>        <span class="hljs-attribute">while</span> n &gt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-attribute">for</span> each in range(n - <span class="hljs-number">1</span>):<br>                <span class="hljs-attribute">result</span> = max(min(height[each], height[n - <span class="hljs-number">1</span>]) * (n - each - <span class="hljs-number">1</span>), result)<br>            <span class="hljs-attribute">n</span> -= <span class="hljs-number">1</span><br>        <span class="hljs-attribute">return</span> result<br><span class="hljs-attribute">s</span> = Solution()<br><span class="hljs-attribute">print</span>(s.maxArea([<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]))<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190901180454230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="方法二双指针">方法二：双指针</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">class Solution:<br>    def maxArea(self, height):<br>        <span class="hljs-built_in">start</span> = <span class="hljs-number">0</span><br>        <span class="hljs-function"><span class="hljs-keyword">end</span> = <span class="hljs-title">len</span>(<span class="hljs-title">height</span>) - <span class="hljs-title">1</span></span><br>        <span class="hljs-built_in">result</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">start</span> &lt; <span class="hljs-keyword">end</span>:<br>            <span class="hljs-built_in">result</span> = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">result</span>, <span class="hljs-built_in">min</span>(height[<span class="hljs-built_in">start</span>], height[<span class="hljs-keyword">end</span>]) * (<span class="hljs-function"><span class="hljs-keyword">end</span> - <span class="hljs-title">start</span>))</span><br>            <span class="hljs-keyword">if</span> height[<span class="hljs-built_in">start</span>] &gt;= height[<span class="hljs-keyword">end</span>]:<br>                <span class="hljs-function"><span class="hljs-keyword">end</span> -= <span class="hljs-title">1</span></span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">start</span> += <span class="hljs-number">1</span><br>        <span class="hljs-literal">return</span> <span class="hljs-built_in">result</span><br>s = Solution()<br>print(s.maxArea([<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]))<br><br></code></pre></td></tr></table></figure><h2 id="结果-1">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190901180415284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：8.字符串转换整数</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A8.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A8.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意： 假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例1： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;42&quot;</span><br><span class="hljs-section">输出: 42</span><br></code></pre></td></tr></table></figure> 示例2： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;   -42&quot;</span><br><span class="hljs-section">输出: -42</span><br><span class="hljs-section">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br>我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 <br></code></pre></td></tr></table></figure> 示例3： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;4193 with words&quot;</span><br><span class="hljs-section">输出: 4193</span><br><span class="hljs-section">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br></code></pre></td></tr></table></figure> 示例4： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;words and 987&quot;</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br>因此无法执行有效的转换。<br></code></pre></td></tr></table></figure> 示例5： <figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: &quot;-<span class="hljs-number">91283472332</span>&quot;<br>输出: -<span class="hljs-number">2147483648</span><br>解释: 数字 &quot;-<span class="hljs-number">91283472332</span>&quot; 超过 <span class="hljs-number">32</span> 位有符号整数范围。 <br>因此返回 INT_MIN (−<span class="hljs-number">231</span>) 。<br><br></code></pre></td></tr></table></figure></p><h2 id="算法实现">算法实现：</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">class Solution:<br>    def myAtoi(self, s: str) -&gt; int:<br>        s = s.strip()<br>        <span class="hljs-keyword">a</span> = lambda <span class="hljs-built_in">num</span>:True <span class="hljs-keyword">if</span> <span class="hljs-built_in">num</span> &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">num</span> &lt;= <span class="hljs-string">&#x27;9&#x27;</span> <span class="hljs-keyword">else</span> False<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> s == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">or</span> s == <span class="hljs-string">&#x27;-&#x27;</span>:<br>            <span class="hljs-literal">return</span> <span class="hljs-number">0</span><br>        elif s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">or</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">a</span>(s[<span class="hljs-number">0</span>]):<br>            count = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">a</span>(s[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>            <span class="hljs-built_in">result</span> = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">a</span>(s[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;-&#x27;</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">a</span>(s[count]):<br>                <span class="hljs-built_in">result</span> += s[count]<br>                <span class="hljs-keyword">if</span> count &lt; <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>:<br>                    count += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    break<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">result</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">result</span> == <span class="hljs-string">&#x27;-&#x27;</span>:<br>                <span class="hljs-literal">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-literal">return</span> int(<span class="hljs-built_in">result</span>) <span class="hljs-keyword">if</span> int(<span class="hljs-built_in">result</span>) &lt;= <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> int(<span class="hljs-built_in">result</span>) &gt;= <span class="hljs-number">-2</span> ** <span class="hljs-number">31</span> <span class="hljs-keyword">else</span> (<span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> int(<span class="hljs-built_in">result</span>) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">-2</span> ** <span class="hljs-number">31</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-literal">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190830142743661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：9.回文数</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A9.%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A9.%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例1： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 121</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure> 示例2： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: -121</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></code></pre></td></tr></table></figure> 示例3： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 10</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></code></pre></td></tr></table></figure> 进阶: 你能不将整数转为字符串来解决这个问题吗？</p><h2 id="算法实现">算法实现：</h2><h2 id="方法一">方法一：</h2><p>递归 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">isPalindrome</span>(self, x: int) -&gt; bool:<br>        x = str(x)<br>        <span class="hljs-keyword">if</span> not x or len(x) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> x[<span class="hljs-number">0</span>] != x[-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">return</span> Solution().isPalindrome(x[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure></p><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190830210325744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="方法二">方法二：</h2><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sqf">class Solution:<br>    def isPalindrome(self, x: int) -&gt; bool:<br>        <span class="hljs-built_in">flag</span> = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-built_in">in</span> range(len(<span class="hljs-built_in">str</span>(x)) <span class="hljs-comment">// 2 + 1):</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>(x)[i] != <span class="hljs-built_in">str</span>(x)[len(<span class="hljs-built_in">str</span>(x)) - i - <span class="hljs-number">1</span>]:<br>                <span class="hljs-built_in">flag</span> = <span class="hljs-literal">False</span><br>        return <span class="hljs-built_in">flag</span><br></code></pre></td></tr></table></figure><h2 id="结果-1">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190830210427772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：7.整数反转</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A7.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A7.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 示例1： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 123</span><br><span class="hljs-section">输出: 321</span><br></code></pre></td></tr></table></figure> 示例2： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: -123</span><br><span class="hljs-section">输出: -321</span><br></code></pre></td></tr></table></figure> 示例3： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 120</span><br><span class="hljs-section">输出: 21</span><br></code></pre></td></tr></table></figure></p><h2 id="算法实现">算法实现：</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    def <span class="hljs-keyword">reverse</span>(self, x: <span class="hljs-built_in">int</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        old = list(<span class="hljs-built_in">str</span>(x))<br>        old.<span class="hljs-keyword">reverse</span>()<br>        <span class="hljs-keyword">if</span> old[<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>:<br>            <span class="hljs-keyword">new</span> = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>(old[:<span class="hljs-number">-1</span>]))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">new</span> &gt;= <span class="hljs-number">-2</span> ** <span class="hljs-number">31</span> and <span class="hljs-keyword">new</span> &lt;= <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">new</span> = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>(old))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">new</span> &gt;= <span class="hljs-number">-2</span> ** <span class="hljs-number">31</span> and <span class="hljs-keyword">new</span> &lt;= <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190829173515371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：5.最长回文子串</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例1：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;babad&quot;</span><br>输出: <span class="hljs-string">&quot;bab&quot;</span><br>注意: <span class="hljs-string">&quot;aba&quot;</span> 也是一个有效答案<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;cbbd&quot;</span><br>输出: <span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">class Solution:<br>    def longestPalindrome(self, s: str) -&gt; str:<br>        firststr = <span class="hljs-string">&#x27;&#x27;</span><br>        secondstr = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt; <span class="hljs-number">1000</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1000</span>):<br>            m, n = <span class="hljs-keyword">each</span>, <span class="hljs-keyword">each</span><br>            <span class="hljs-keyword">while</span> m &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n &lt;= <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[m] == s[n]:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(firststr) &lt;= n - m + <span class="hljs-number">1</span>: firststr = s[m:n + <span class="hljs-number">1</span>]<br>                    m -= <span class="hljs-number">1</span><br>                    n += <span class="hljs-number">1</span><br>            m, n = <span class="hljs-keyword">each</span>, <span class="hljs-keyword">each</span> + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> m &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n &lt;= <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[m] == s[n]:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(secondstr) &lt;= n - m + <span class="hljs-number">1</span>: secondstr = s[m:n + <span class="hljs-number">1</span>]<br>                    m -= <span class="hljs-number">1</span><br>                    n += <span class="hljs-number">1</span><br>        <span class="hljs-literal">return</span> firststr <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(firststr) &gt; <span class="hljs-built_in">len</span>(secondstr) <span class="hljs-keyword">else</span> secondstr<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190828200831231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战：4.寻找两个有序数组的中位数</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例1：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">nums1</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]<br><span class="hljs-attr">nums2</span> = [<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>则中位数是 2.0 示例2：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">nums1</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><span class="hljs-attr">nums2</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>则中位数是 (2 + 3)/2 = 2.5</p><h2 id="算法实现">算法实现：</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">class</span> Solution:<br>    <span class="hljs-attribute">def</span> findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:<br>        <span class="hljs-attribute">if</span> nums1 or nums2:<br>            <span class="hljs-attribute">a</span> = lambda x, nums: nums[x // <span class="hljs-number">2</span> ] if x % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> else (nums[x // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + nums[x // <span class="hljs-number">2</span>]) / <span class="hljs-number">2</span><br>            <span class="hljs-attribute">nums1</span>.extend(nums2)<br>            <span class="hljs-attribute">nums1</span>.sort()<br>            <span class="hljs-attribute">return</span> a(len(nums1), nums1)<br><span class="hljs-attribute">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-attribute">s</span> = Solution()<br>    <span class="hljs-attribute">print</span>(s.findMedianSortedArrays([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>],<span class="hljs-meta"> [3, 4]))</span><br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190828201947311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode实战： 2.两数相加</title>
    <link href="/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/uncategorized/Leetcode/Leetcode%E5%AE%9E%E6%88%98%EF%BC%9A2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目：</h2><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span><br><br></code></pre></td></tr></table></figure><h2 id="算法实现">算法实现：</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>:<br>    def __init__(self, x):<br>        self.val = x<br>        self.<span class="hljs-keyword">next</span> = None<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:<br>        head = ListNode(<span class="hljs-number">0</span>)<br>        test, rest = head, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 or l2:<br>            <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">sum</span> += l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">sum</span> += l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">sum</span> += rest<br>            rest = <span class="hljs-keyword">sum</span> <span class="hljs-comment">// 10</span><br>            test.<span class="hljs-keyword">next</span> = ListNode(<span class="hljs-keyword">sum</span> % <span class="hljs-number">10</span>)<br>            test = test.<span class="hljs-keyword">next</span><br>            l1, l2 = l1.<span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> None, l2.<span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span>  l2 <span class="hljs-keyword">else</span> None<br>        <span class="hljs-keyword">if</span> rest &gt; <span class="hljs-number">0</span>:<br>            test.<span class="hljs-keyword">next</span> = ListNode(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> head.<span class="hljs-keyword">next</span><br><br>def getListNode(line):<br>    list1 = line.split(<span class="hljs-string">&#x27; -&gt; &#x27;</span>)<br>    head = ListNode(<span class="hljs-number">0</span>)<br>    test = head<br>    <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> list1:<br>        test.<span class="hljs-keyword">next</span> = ListNode(<span class="hljs-built_in">int</span>(each))<br>        test = test.<span class="hljs-keyword">next</span><br>    <span class="hljs-keyword">return</span> head.<span class="hljs-keyword">next</span><br><br>def getStr(l1: ListNode) -&gt; <span class="hljs-built_in">str</span>:<br>    result = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> l1:<br>        result +=  <span class="hljs-built_in">str</span>(l1.val)<br>        <span class="hljs-keyword">if</span> l1.<span class="hljs-keyword">next</span>:<br>            result += <span class="hljs-string">&#x27; -&gt; &#x27;</span><br>        l1 = l1.<span class="hljs-keyword">next</span><br><br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    l1, l2 = getListNode(<span class="hljs-string">&#x27;1&#x27;</span>), getListNode(<span class="hljs-string">&#x27;9 -&gt; 9&#x27;</span>)<br>    add = Solution()<br>    <span class="hljs-keyword">print</span>(getStr(add.addTwoNumbers(l1, l2)))<br></code></pre></td></tr></table></figure><h2 id="结果">结果：</h2><figure><img src="https://img-blog.csdnimg.cn/20190828201825124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzE1OTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
